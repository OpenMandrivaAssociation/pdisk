diff -Npur diskdev_cmds.org/Makefile.lnx diskdev_cmds/Makefile.lnx
--- diskdev_cmds.org/Makefile.lnx	1970-01-01 01:00:00.000000000 +0100
+++ diskdev_cmds/Makefile.lnx	2003-07-07 15:19:30.000000000 +0200
@@ -0,0 +1,9 @@
+CC := gcc
+CFLAGS := -g -O2 -Wall -I$(PWD)/include -DDEBUG_BUILD=0 -D_FILE_OFFSET_BITS=64
+
+SUBDIRS := newfs_hfs.tproj fsck_hfs.tproj
+
+all clean:
+	for d in $(SUBDIRS); do $(MAKE) -C $$d -f Makefile.lnx $@; done
+
+export CC CFLAGS
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/Makefile.lnx diskdev_cmds/fsck_hfs.tproj/Makefile.lnx
--- diskdev_cmds.org/fsck_hfs.tproj/Makefile.lnx	1970-01-01 01:00:00.000000000 +0100
+++ diskdev_cmds/fsck_hfs.tproj/Makefile.lnx	2003-05-05 13:40:54.000000000 +0200
@@ -0,0 +1,15 @@
+CFILES = fsck_hfs.c strings.c utilities.c cache.c
+OFILES = $(CFILES:.c=.o)
+
+all: fsck_hfs
+
+fsck_hfs: $(OFILES) dfalib/libdfa.a
+
+dfalib/libdfa.a: FORCE
+	$(MAKE) -C dfalib -f Makefile.lnx libdfa.a
+
+clean:
+	$(RM) fsck_hfs $(OFILES)
+	$(MAKE) -C dfalib -f Makefile.lnx clean
+
+.PHONY : FORCE clean
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/cache.c diskdev_cmds/fsck_hfs.tproj/cache.c
--- diskdev_cmds.org/fsck_hfs.tproj/cache.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/cache.c	2003-06-30 11:27:50.000000000 +0200
@@ -24,6 +24,7 @@
 #include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
 #include <sys/types.h>
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/BTree.c diskdev_cmds/fsck_hfs.tproj/dfalib/BTree.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/BTree.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/BTree.c	2003-05-05 12:28:21.000000000 +0200
@@ -340,7 +340,7 @@ OSStatus	BTOpenPath			(SFCB					*filePtr
 	btreePtr = (BTreeControlBlock*) AllocateClearMemory( sizeof( BTreeControlBlock ) );
 	if (btreePtr == nil)
 	{
-		Panic ("\pBTOpen: no memory for btreePtr.");
+		Panic ("BTOpen: no memory for btreePtr.");
 		return	memFullErr;
 	}
 
@@ -367,7 +367,7 @@ OSStatus	BTOpenPath			(SFCB					*filePtr
 						kGetBlock,
 						&nodeRec );
 
-	PanicIf (err != noErr, "\pBTOpen: getNodeProc returned error getting header node.");
+	PanicIf (err != noErr, "BTOpen: getNodeProc returned error getting header node.");
 	M_ExitOnError (err);
 
 	header = (BTHeaderRec*) (nodeRec.buffer + sizeof(BTNodeDescriptor));
@@ -381,21 +381,21 @@ OSStatus	BTOpenPath			(SFCB					*filePtr
 
 	///////////////////// Initalize fields from header //////////////////////////
 	
-	PanicIf ( (filePtr->fcbVolume->vcbSigWord != 'BD') && (btreePtr->nodeSize == 512), "\p BTOpenPath: wrong node size for HFS+ volume!");
+	//PanicIf ( (filePtr->fcbVolume->vcbSigWord != 'BD') && (btreePtr->nodeSize == 512), " BTOpenPath: wrong node size for HFS+ volume!");
 
-	btreePtr->treeDepth			= header->treeDepth;
-	btreePtr->rootNode			= header->rootNode;
-	btreePtr->leafRecords		= header->leafRecords;
-	btreePtr->firstLeafNode		= header->firstLeafNode;
-	btreePtr->lastLeafNode		= header->lastLeafNode;
-	btreePtr->nodeSize			= header->nodeSize;
-	btreePtr->maxKeyLength		= header->maxKeyLength;
-	btreePtr->totalNodes		= header->totalNodes;
-	btreePtr->freeNodes			= header->freeNodes;
+	btreePtr->treeDepth			= SWAP_BE16(header->treeDepth);
+	btreePtr->rootNode			= SWAP_BE32(header->rootNode);
+	btreePtr->leafRecords		= SWAP_BE32(header->leafRecords);
+	btreePtr->firstLeafNode		= SWAP_BE32(header->firstLeafNode);
+	btreePtr->lastLeafNode		= SWAP_BE32(header->lastLeafNode);
+	btreePtr->nodeSize			= SWAP_BE16(header->nodeSize);
+	btreePtr->maxKeyLength		= SWAP_BE16(header->maxKeyLength);
+	btreePtr->totalNodes		= SWAP_BE32(header->totalNodes);
+	btreePtr->freeNodes			= SWAP_BE32(header->freeNodes);
 	// ignore					  header->clumpSize;	//ее rename this field?
 	btreePtr->btreeType			= header->btreeType;
 
-	btreePtr->attributes		= header->attributes;
+	btreePtr->attributes		= SWAP_BE32(header->attributes);
 
 	if ( btreePtr->maxKeyLength > 40 )
 		btreePtr->attributes |= (kBTBigKeysMask + kBTVariableIndexKeysMask);	//ее we need a way to save these attributes
@@ -663,7 +663,7 @@ OSStatus	BTSearchRecord		(SFCB						*fil
 		if( err == noErr )
 		{
 			if ( ((BTNodeDescriptor*) node.buffer)->kind		== kBTLeafNode &&
-				 ((BTNodeDescriptor*) node.buffer)->numRecords	>  0 )
+				 SWAP_BE16(((BTNodeDescriptor*) node.buffer)->numRecords)	>  0 )
 			{
 				foundRecord = SearchNode (btreePtr, node.buffer, &searchIterator->key, &index);
 
@@ -696,7 +696,7 @@ OSStatus	BTSearchRecord		(SFCB						*fil
 		if( err == noErr )
 		{
 			if ( ((BTNodeDescriptor*) node.buffer)->kind		== kBTLeafNode &&
-				 ((BTNodeDescriptor*) node.buffer)->numRecords	>  0 )
+				 SWAP_BE16(((BTNodeDescriptor*) node.buffer)->numRecords)	>  0 )
 			{
 				foundRecord = SearchNode (btreePtr, node.buffer, &searchIterator->key, &index);
 			}
@@ -739,7 +739,7 @@ OSStatus	BTSearchRecord		(SFCB						*fil
 
 			recordSize = record->itemCount * record->itemSize;
 			
-			PanicIf(len > recordSize, "\pBTSearchRecord: truncating record!");
+			PanicIf(len > recordSize, "BTSearchRecord: truncating record!");
 
 			if (len > recordSize)	len = recordSize;
 
@@ -794,7 +794,7 @@ ErrorExit:
 
 		resultIterator->version			= 0;
 		resultIterator->reserved		= 0;
-		resultIterator->key.length16	= 0;	// zero out two bytes to cover both types of keys
+		SET_SWAP_BE16(resultIterator->key.length16, 0);	// zero out two bytes to cover both types of keys
 	}
 
 	if ( err == fsBTEmptyErr )
@@ -891,7 +891,7 @@ OSStatus	BTIterateRecord		(SFCB						*fi
 		M_ExitOnError (err);
 
 		if ( ((NodeDescPtr) node.buffer)->kind			!= kBTLeafNode ||
-			 ((NodeDescPtr) node.buffer)->numRecords	<=  0 )
+			 SWAP_BE16(((NodeDescPtr) node.buffer)->numRecords)	<=  0 )
 		{
 			err = ReleaseNode (btreePtr, &node);
 			M_ExitOnError (err);
@@ -901,7 +901,7 @@ OSStatus	BTIterateRecord		(SFCB						*fi
 		}
 
 		if (operation == kBTreeFirstRecord)		index = 0;
-		else									index = ((BTNodeDescriptor*) node.buffer)->numRecords - 1;
+		else									index = SWAP_BE16(((BTNodeDescriptor*) node.buffer)->numRecords) - 1;
 
 		goto CopyData;						//ее is there a cleaner way?
 	}
@@ -926,7 +926,7 @@ OSStatus	BTIterateRecord		(SFCB						*fi
 		{
 			if (left.buffer == nil)
 			{
-				nodeNum = ((NodeDescPtr) node.buffer)->bLink;
+				nodeNum = SWAP_BE32(((NodeDescPtr) node.buffer)->bLink);
 				if ( nodeNum > 0)
 				{
 					err = GetNode (btreePtr, nodeNum, &left);
@@ -944,25 +944,25 @@ OSStatus	BTIterateRecord		(SFCB						*fi
 			right		= node;
 			node		= left;
 			left.buffer	= nil;
-			index 		= ((NodeDescPtr) node.buffer)->numRecords -1;
+			index 		= SWAP_BE16(((NodeDescPtr) node.buffer)->numRecords) -1;
 		}
 	}
 	else if (operation == kBTreeNextRecord)
 	{
 		if ((foundRecord != true) &&
-			(((NodeDescPtr) node.buffer)->fLink == 0) &&
-			(index == ((NodeDescPtr) node.buffer)->numRecords))
+			SWAP_BE32(((NodeDescPtr) node.buffer)->fLink) == 0 &&
+			(index == SWAP_BE16(((NodeDescPtr) node.buffer)->numRecords)))
 		{
 			err = fsBTEndOfIterationErr;
 			goto ErrorExit;
 		} 
 	
 		// we did not find the record but the index is already positioned correctly
-		if ((foundRecord == false) && (index != ((NodeDescPtr) node.buffer)->numRecords)) 
+		if ((foundRecord == false) && (index != SWAP_BE16(((NodeDescPtr) node.buffer)->numRecords))) 
 			goto CopyData;
 
 		// we found the record OR we have to look in the next node
-		if (index < ((NodeDescPtr) node.buffer)->numRecords -1)
+		if (index < SWAP_BE16(((NodeDescPtr) node.buffer)->numRecords) -1)
 		{
 			++index;
 		}
@@ -970,7 +970,7 @@ OSStatus	BTIterateRecord		(SFCB						*fi
 		{
 			if (right.buffer == nil)
 			{
-				nodeNum = ((NodeDescPtr) node.buffer)->fLink;
+				nodeNum = SWAP_BE32(((NodeDescPtr) node.buffer)->fLink);
 				if ( nodeNum > 0)
 				{
 					err = GetNode (btreePtr, nodeNum, &right);
@@ -995,7 +995,7 @@ OSStatus	BTIterateRecord		(SFCB						*fi
 	{
 		// make sure we have something... <CS9>
 		if ((foundRecord != true) &&
-			(index >= ((NodeDescPtr) node.buffer)->numRecords))
+			(index >= SWAP_BE16(((NodeDescPtr) node.buffer)->numRecords)))
 		{
 			err = fsBTEndOfIterationErr;
 			goto ErrorExit;
@@ -1018,7 +1018,7 @@ CopyData:
 
 		recordSize = record->itemCount * record->itemSize;
 
-		PanicIf(len > recordSize, "\pBTIterateRecord: truncating record!");
+		PanicIf(len > recordSize, "BTIterateRecord: truncating record!");
 	
 		if (len > recordSize)	len = recordSize;
 
@@ -1082,7 +1082,7 @@ ErrorExit:
 
 		iterator->version			= 0;
 		iterator->reserved			= 0;
-		iterator->key.length16		= 0;
+		SET_SWAP_BE16(iterator->key.length16, 0);
 	}
 
 	if ( err == fsBTEmptyErr || err == fsBTEndOfIterationErr )
@@ -1661,7 +1661,9 @@ OSStatus	BTGetInformation	(SFCB					*fil
 								 UInt16					 version,
 								 BTreeInfoRec			*info )
 {
+#ifdef __APPLE__
 #pragma unused (version)
+#endif
 
 	BTreeControlBlockPtr	btreePtr;
 
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/BTreeAllocate.c diskdev_cmds/fsck_hfs.tproj/dfalib/BTreeAllocate.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/BTreeAllocate.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/BTreeAllocate.c	2003-06-30 11:28:21.000000000 +0200
@@ -296,17 +296,17 @@ OSStatus	ExtendBTree	(BTreeControlBlockP
 		recStartBit	= totalMapBits;				// bit number of first bit in map record
 		totalMapBits  += mapBits;
 		
-	} while ( ((BTNodeDescriptor*)mapNode.buffer)->fLink != 0 );
+	} while ( SWAP_BE32(((BTNodeDescriptor*)mapNode.buffer)->fLink) != 0 );
 
 	if (DEBUG_BUILD && totalMapBits != CalcMapBits (btreePtr))
-		Panic ("\pExtendBTree: totalMapBits != CalcMapBits");
+		Panic ("ExtendBTree: totalMapBits != CalcMapBits");
 		
 	/////////////////////// Extend LEOF If Necessary ////////////////////////////
 
 	minEOF = (UInt64)newTotalNodes * (UInt64)nodeSize;
 	if ( filePtr->fcbLogicalSize < minEOF )
 	{
-		maxEOF = ((UInt64)0xFFFFFFFFFFFFFFFF);  
+		maxEOF = ((UInt64)0xFFFFFFFFFFFFFFFFULL);  
 
 		err = btreePtr->setEndOfForkProc (btreePtr->fcbPtr, minEOF, maxEOF);
 		M_ExitOnError (err);
@@ -341,7 +341,7 @@ OSStatus	ExtendBTree	(BTreeControlBlockP
 
 	/////////////////////// Initialize New Map Nodes ////////////////////////////
 
-	((BTNodeDescriptor*)mapNode.buffer)->fLink = firstNewMapNodeNum;
+	SET_SWAP_BE32(((BTNodeDescriptor*)mapNode.buffer)->fLink, firstNewMapNodeNum);
 
 	nodeNum		= firstNewMapNodeNum;
 	while (true)
@@ -349,7 +349,7 @@ OSStatus	ExtendBTree	(BTreeControlBlockP
 		err = GetNewNode (btreePtr, nodeNum, &newNode);
 		M_ExitOnError (err);
 		
-		((NodeDescPtr)newNode.buffer)->numRecords	= 1;
+		SET_SWAP_BE16(((NodeDescPtr)newNode.buffer)->numRecords, 1);
 		((NodeDescPtr)newNode.buffer)->kind			= kBTMapNode;
 		
 		// set free space offset
@@ -358,7 +358,7 @@ OSStatus	ExtendBTree	(BTreeControlBlockP
 		if (nodeNum++ == lastNewMapNodeNum)
 			break;
 
-		((BTNodeDescriptor*)newNode.buffer)->fLink = nodeNum;	// point to next map node
+		SET_SWAP_BE32(((BTNodeDescriptor*)newNode.buffer)->fLink, nodeNum);	// point to next map node
 			
 		err = UpdateNode (btreePtr, &newNode);
 		M_ExitOnError (err);
@@ -376,7 +376,7 @@ OSStatus	ExtendBTree	(BTreeControlBlockP
 
 		while (bitInRecord >= mapBits)
 		{
-			nextNodeNum = ((NodeDescPtr)mapNode.buffer)->fLink;
+			nextNodeNum = SWAP_BE32(((NodeDescPtr)mapNode.buffer)->fLink);
 			if ( nextNodeNum == 0)
 			{
 				err = fsBTNoMoreMapNodesErr;
@@ -396,7 +396,7 @@ OSStatus	ExtendBTree	(BTreeControlBlockP
 			
 			if (DEBUG_BUILD && mapSize != M_MapRecordSize (btreePtr->nodeSize) )
 			{
-				Panic ("\pExtendBTree: mapSize != M_MapRecordSize");
+				Panic ("ExtendBTree: mapSize != M_MapRecordSize");
 			}
 			
 			mapBits		= mapSize << 3;		// mapSize (in bytes) * 8
@@ -475,7 +475,7 @@ OSStatus	GetMapNode (BTreeControlBlockPt
 	
 	if (nodePtr->buffer != nil)		// if iterator is valid...
 	{
-		nextNodeNum = ((NodeDescPtr)nodePtr->buffer)->fLink;
+		nextNodeNum = SWAP_BE32(((NodeDescPtr)nodePtr->buffer)->fLink);
 		if (nextNodeNum == 0)
 		{
 			err = fsBTNoMoreMapNodesErr;
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/BTreeMiscOps.c diskdev_cmds/fsck_hfs.tproj/dfalib/BTreeMiscOps.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/BTreeMiscOps.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/BTreeMiscOps.c	2003-05-05 12:28:51.000000000 +0200
@@ -85,7 +85,7 @@ OSStatus	VerifyHeader	(SFCB				*filePtr,
 	UInt32		totalNodes;
 	
 
-	switch (header->nodeSize)							// node size == 512*2^n
+	switch (SWAP_BE16(header->nodeSize))							// node size == 512*2^n
 	{
 		case   512:
 		case  1024:
@@ -97,26 +97,26 @@ OSStatus	VerifyHeader	(SFCB				*filePtr,
 		default:		return	fsBTInvalidHeaderErr;			//ее E_BadNodeType
 	}
 	
-	totalNodes = header->totalNodes;
+	totalNodes = SWAP_BE32(header->totalNodes);
 
-	forkSize = totalNodes * header->nodeSize;
+	forkSize = totalNodes * SWAP_BE16(header->nodeSize);
 	
 	if ( forkSize != filePtr->fcbLogicalSize )
 		return fsBTInvalidHeaderErr;
 	
-	if ( header->freeNodes >= totalNodes )
+	if ( SWAP_BE32(header->freeNodes) >= totalNodes )
 		return fsBTInvalidHeaderErr;
 	
-	if ( header->rootNode >= totalNodes )
+	if ( SWAP_BE32(header->rootNode) >= totalNodes )
 		return fsBTInvalidHeaderErr;
 	
-	if ( header->firstLeafNode >= totalNodes )
+	if ( SWAP_BE32(header->firstLeafNode) >= totalNodes )
 		return fsBTInvalidHeaderErr;
 	
-	if ( header->lastLeafNode >= totalNodes )
+	if ( SWAP_BE32(header->lastLeafNode) >= totalNodes )
 		return fsBTInvalidHeaderErr;
 	
-	if ( header->treeDepth > kMaxTreeDepth )
+	if ( SWAP_BE16(header->treeDepth) > kMaxTreeDepth )
 		return fsBTInvalidHeaderErr;
 
 
@@ -167,15 +167,15 @@ OSStatus	UpdateHeader	(BTreeControlBlock
 	
 	header = (BTHeaderRec*) (node.buffer + sizeof(BTNodeDescriptor));
 	
-	header->treeDepth		= btreePtr->treeDepth;
-	header->rootNode		= btreePtr->rootNode;
-	header->leafRecords		= btreePtr->leafRecords;
-	header->firstLeafNode	= btreePtr->firstLeafNode;
-	header->lastLeafNode	= btreePtr->lastLeafNode;
-	header->nodeSize		= btreePtr->nodeSize;			//ее this shouldn't change
-	header->maxKeyLength	= btreePtr->maxKeyLength;		//ее neither should this
-	header->totalNodes		= btreePtr->totalNodes;
-	header->freeNodes		= btreePtr->freeNodes;
+	SET_SWAP_BE16(header->treeDepth, btreePtr->treeDepth);
+	SET_SWAP_BE32(header->rootNode, btreePtr->rootNode);
+	SET_SWAP_BE32(header->leafRecords, btreePtr->leafRecords);
+	SET_SWAP_BE32(header->firstLeafNode, btreePtr->firstLeafNode);
+	SET_SWAP_BE32(header->lastLeafNode, btreePtr->lastLeafNode);
+	SET_SWAP_BE16(header->nodeSize, btreePtr->nodeSize);			//ее this shouldn't change
+	SET_SWAP_BE16(header->maxKeyLength, btreePtr->maxKeyLength);		//ее neither should this
+	SET_SWAP_BE32(header->totalNodes, btreePtr->totalNodes);
+	SET_SWAP_BE32(header->freeNodes, btreePtr->freeNodes);
 	header->btreeType		= btreePtr->btreeType;
 
 	// ignore	header->clumpSize;							//ее rename this field?
@@ -273,7 +273,7 @@ OSStatus	FindIteratorPosition	(BTreeCont
 	M_ExitOnError (err);
 	
 	if ( ((NodeDescPtr) middle->buffer)->kind		!=	kBTLeafNode ||
-		 ((NodeDescPtr) middle->buffer)->numRecords	<=  0 )
+		 SWAP_BE16(((NodeDescPtr) middle->buffer)->numRecords)	<=  0 )
 	{	
 		goto SearchTheTree;
 	}
@@ -288,18 +288,18 @@ OSStatus	FindIteratorPosition	(BTreeCont
 	
 	if (index == 0)
 	{
-		if (((NodeDescPtr) middle->buffer)->bLink == 0)		// before 1st btree record
+		if (SWAP_BE32(((NodeDescPtr) middle->buffer)->bLink) == 0)		// before 1st btree record
 		{
 			goto SuccessfulExit;
 		}
 		
-		nodeNum = ((NodeDescPtr) middle->buffer)->bLink;
+		nodeNum = SWAP_BE32(((NodeDescPtr) middle->buffer)->bLink);
 		
 		err = GetLeftSiblingNode (btreePtr, middle->buffer, left);
 		M_ExitOnError (err);
 		
 		if ( ((NodeDescPtr) left->buffer)->kind			!=	kBTLeafNode ||
-			 ((NodeDescPtr) left->buffer)->numRecords	<=  0 )
+			 SWAP_BE16(((NodeDescPtr)left->buffer)->numRecords)	<=  0 )
 		{	
 			goto SearchTheTree;
 		}
@@ -319,11 +319,11 @@ OSStatus	FindIteratorPosition	(BTreeCont
 		{
 			goto SearchTheTree;
 		}
-		else if (leftIndex >= ((NodeDescPtr) left->buffer)->numRecords)
+		else if (leftIndex >= SWAP_BE16(((NodeDescPtr) left->buffer)->numRecords))
 		{
-			nodeNum = ((NodeDescPtr) left->buffer)->fLink;
+			nodeNum = SWAP_BE32(((NodeDescPtr) left->buffer)->fLink);
 			
-			PanicIf (index != 0, "\pFindIteratorPosition: index != 0");	//ее just checking...
+			PanicIf (index != 0, "FindIteratorPosition: index != 0");	//ее just checking...
 			goto SuccessfulExit;
 		}
 		else
@@ -336,26 +336,26 @@ OSStatus	FindIteratorPosition	(BTreeCont
 			goto SuccessfulExit;
 		}
 	}
-	else if (index >= ((NodeDescPtr) middle->buffer)->numRecords)
+	else if (index >= SWAP_BE16(((NodeDescPtr) middle->buffer)->numRecords))
 	{
-		if (((NodeDescPtr) middle->buffer)->fLink == 0)	// beyond last record
+		if (SWAP_BE32(((NodeDescPtr) middle->buffer)->fLink) == 0)	// beyond last record
 		{
 			goto SuccessfulExit;
 		}
 		
-		nodeNum = ((NodeDescPtr) middle->buffer)->fLink;
+		nodeNum = SWAP_BE32(((NodeDescPtr) middle->buffer)->fLink);
 		
 		err = GetRightSiblingNode (btreePtr, middle->buffer, right);
 		M_ExitOnError (err);
 		
 		if ( ((NodeDescPtr) right->buffer)->kind		!= kBTLeafNode ||
-			 ((NodeDescPtr) right->buffer)->numRecords	<=  0 )
+			 SWAP_BE16(((NodeDescPtr) right->buffer)->numRecords)	<=  0 )
 		{	
 			goto SearchTheTree;
 		}
 
 		foundIt = SearchNode (btreePtr, right->buffer, &iterator->key, &rightIndex);
-		if (rightIndex >= ((NodeDescPtr) right->buffer)->numRecords)		// we're lost
+		if (rightIndex >= SWAP_BE16(((NodeDescPtr) right->buffer)->numRecords))		// we're lost
 		{
 			goto SearchTheTree;
 		}
@@ -537,7 +537,7 @@ OSStatus	TrySimpleReplace		(BTreeControl
 		didItFit = InsertKeyRecord (btreePtr, nodePtr, index,
 										&iterator->key, KeyLength(btreePtr, &iterator->key),
 										record->bufferAddress, recordLen);
-		PanicIf (didItFit == false, "\pTrySimpleInsert: InsertKeyRecord returned false!");
+		PanicIf (didItFit == false, "TrySimpleInsert: InsertKeyRecord returned false!");
 
 		*recordInserted = true;
 	}
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/BTreeNodeOps.c diskdev_cmds/fsck_hfs.tproj/dfalib/BTreeNodeOps.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/BTreeNodeOps.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/BTreeNodeOps.c	2003-06-30 11:29:31.000000000 +0200
@@ -77,7 +77,7 @@ UInt16		GetRecordOffset		(BTreeControlBl
 								 NodeDescPtr			 node,
 								 UInt16					 index );
 
-UInt16	   *GetOffsetAddress	(BTreeControlBlockPtr	btreePtr,
+u_big_int16_t *GetOffsetAddress	(BTreeControlBlockPtr	btreePtr,
 								 NodeDescPtr			 node,
 								 UInt16					index );
 								 
@@ -93,7 +93,7 @@ void		DeleteOffset		(BTreeControlBlockPt
 
 /////////////////////////////////////////////////////////////////////////////////
 
-#define GetRecordOffset(btreePtr,node,index)		(*(short *) ((UInt8 *)(node) + (btreePtr)->nodeSize - ((index) << 1) - kOffsetSize))
+#define GetRecordOffset(btreePtr,node,index)		SWAP_BE16(*(u_big_int16_t *) ((UInt8 *)(node) + (btreePtr)->nodeSize - ((index) << 1) - kOffsetSize))
 
 static void PrintNode(const NodeDescPtr node, UInt16 nodeSize, UInt32 nodeNumber);
 
@@ -126,7 +126,7 @@ OSStatus	GetNode		(BTreeControlBlockPtr	
 	//ее is nodeNum within proper range?
 	if( nodeNum >= btreePtr->totalNodes )
 	{
-		Panic("\pGetNode:nodeNum >= totalNodes");
+		Panic("GetNode:nodeNum >= totalNodes");
 		err = fsBTInvalidNodeErr;
 		goto ErrorExit;
 	}
@@ -139,7 +139,7 @@ OSStatus	GetNode		(BTreeControlBlockPtr	
 
 	if (err != noErr)
 	{
-		Panic ("\pGetNode: getNodeProc returned error.");
+		Panic ("GetNode: getNodeProc returned error.");
 		nodePtr->buffer = nil;
 		goto ErrorExit;
 	}
@@ -156,7 +156,7 @@ OSStatus	GetNode		(BTreeControlBlockPtr	
 		err = CheckNode (btreePtr, nodePtr->buffer);
 		if (err != noErr)
 		{
-			if (DEBUG_BUILD && ((NodeDescPtr)nodePtr->buffer)->numRecords != 0)
+			if (DEBUG_BUILD && SWAP_BE16(((NodeDescPtr)nodePtr->buffer)->numRecords) != 0)
 				PrintNode(nodePtr->buffer, btreePtr->nodeSize, nodeNum);
 
 			if (DEBUG_BUILD)
@@ -179,7 +179,7 @@ OSStatus	GetNode		(BTreeControlBlockPtr	
 					{
 						if( *cur++ != 0 )
 						{
-							Panic ("\pGetNode: CheckNode returned error.");
+							Panic ("GetNode: CheckNode returned error.");
 							break;
 						}
 					}
@@ -242,7 +242,7 @@ OSStatus	GetNewNode	(BTreeControlBlockPt
 					   
 	if (err != noErr)
 	{
-		Panic ("\pGetNewNode: getNodeProc returned error.");
+		Panic ("GetNewNode: getNodeProc returned error.");
 		returnNodePtr->buffer = nil;
 		return err;
 	}
@@ -256,7 +256,7 @@ OSStatus	GetNewNode	(BTreeControlBlockPt
 	ClearNode (btreePtr, node);						// clear the node
 
 	pos = (char *)node + btreePtr->nodeSize - 2;	// find address of last offset
-	*(UInt16 *)pos = sizeof (BTNodeDescriptor);		// set offset to beginning of free space
+	SET_SWAP_BE16(*(u_big_int16_t *)pos, sizeof (BTNodeDescriptor));		// set offset to beginning of free space
 
 
 	return noErr;
@@ -294,7 +294,7 @@ OSStatus	ReleaseNode	(BTreeControlBlockP
 		err = releaseNodeProc (btreePtr->fcbPtr,
 							   nodePtr,
 							   kReleaseBlock );
-		PanicIf (err, "\pReleaseNode: releaseNodeProc returned error.");
+		PanicIf (err, "ReleaseNode: releaseNodeProc returned error.");
 		++btreePtr->numReleaseNodes;
 	}
 	
@@ -398,7 +398,7 @@ OSStatus	CheckNode	(BTreeControlBlockPtr
 	
 	maxNode = (btreePtr->fcbPtr->fcbLogicalSize / nodeSize) - 1;
 	
-	if ( (node->fLink > maxNode) || (node->bLink > maxNode) )
+	if ( (SWAP_BE32(node->fLink) > maxNode) || (SWAP_BE32(node->bLink) > maxNode) )
 		return fsBTInvalidNodeErr;
 	
 	
@@ -419,13 +419,13 @@ OSStatus	CheckNode	(BTreeControlBlockPtr
 	//XXX can we calculate a more accurate minimum record size?
 	maxRecords = ( nodeSize - sizeof (BTNodeDescriptor) ) >> 3;
 	
-	if (node->numRecords > maxRecords)
+	if (SWAP_BE16(node->numRecords) > maxRecords)
 		return fsBTInvalidNodeErr;
 
 
 	////////////////////////// check record offsets /////////////////////////////
 
-	index = node->numRecords;		/* start index at free space */
+	index = SWAP_BE16(node->numRecords);		/* start index at free space */
 	prevOffset = nodeSize - (index << 1);	/* use 2 bytes past end of free space */
 
 	do {
@@ -439,7 +439,7 @@ OSStatus	CheckNode	(BTreeControlBlockPtr
 		
 		/* reject keys that overflow record slot */
 		if ((node->kind == kBTLeafNode) &&
-		    (index < node->numRecords) &&	/* ignore free space record */
+		    (index < SWAP_BE16(node->numRecords)) &&	/* ignore free space record */
 		    (CalcKeySize(btreePtr, (KeyPtr) ((Ptr)node + offset)) > (prevOffset - offset))) {
 			return fsBTInvalidNodeErr;
 		}
@@ -454,7 +454,7 @@ OSStatus	CheckNode	(BTreeControlBlockPtr
 }
 
 
-#if BSD
+#if __unix__
 static void PrintNode(const NodeDescPtr node, UInt16 nodeSize, UInt32 nodeNumber)
 {
 	struct row {
@@ -470,8 +470,10 @@ static void PrintNode(const NodeDescPtr 
 	lp = (UInt32*) node;
 	offset = 0;
 	
-	while (rows-- > 0)
-		printf("%04X: %08X %08X %08X %08X\n", (u_int)offset++, *lp++, *lp++, *lp++, *lp++);
+	while (rows-- > 0) {
+		printf("%04X: %08X %08X %08X %08X\n", (u_int)offset++, lp[0], lp[1], lp[2], lp[3]);
+		lp += 4;
+	}
 }
 #endif
 
@@ -536,7 +538,7 @@ Boolean		InsertRecord	(BTreeControlBlock
 	//// make hole for new record
 
 	indexOffset = GetRecordOffset (btreePtr, node, index);
-	freeOffset	= GetRecordOffset (btreePtr, node, node->numRecords);
+	freeOffset	= GetRecordOffset (btreePtr, node, SWAP_BE16(node->numRecords));
 
 	src = ((Ptr) node) + indexOffset;
 	dst = ((Ptr) src)  + recSize;
@@ -621,7 +623,7 @@ Boolean		InsertKeyRecord		(BTreeControlB
 	//// make hole for new record
 
 	indexOffset = GetRecordOffset (btreePtr, node, index);
-	freeOffset	= GetRecordOffset (btreePtr, node, node->numRecords);
+	freeOffset	= GetRecordOffset (btreePtr, node, SWAP_BE16(node->numRecords));
 
 	src = ((UInt8 *) node) + indexOffset;
 	dst = ((UInt8 *) src) + keySize + recSize;
@@ -640,8 +642,8 @@ Boolean		InsertKeyRecord		(BTreeControlB
 
 	if ( btreePtr->attributes & kBTBigKeysMask )
 	{
-		*((UInt16*) dst)++ = keyLength;		// use keyLength rather than key.length
-		rawKeyLength = keyPtr->length16;
+		SET_SWAP_BE16(*((u_big_int16_t *) dst)++, keyLength);		// use keyLength rather than key.length
+		rawKeyLength = SWAP_BE16(keyPtr->length16);
 		sizeOfLength = 2;
 	}
 	else
@@ -696,7 +698,7 @@ void		DeleteRecord	(BTreeControlBlockPtr
 	//// compress records
 	indexOffset = GetRecordOffset (btreePtr, node, index);
 	nextOffset	= GetRecordOffset (btreePtr, node, index + 1);
-	freeOffset	= GetRecordOffset (btreePtr, node, node->numRecords);
+	freeOffset	= GetRecordOffset (btreePtr, node, SWAP_BE16(node->numRecords));
 
 	src = ((Ptr) node) + nextOffset;
 	dst = ((Ptr) node) + indexOffset;
@@ -744,7 +746,7 @@ Boolean		SearchNode		(BTreeControlBlockP
 #endif	
 
 	lowerBound = 0;
-	upperBound = node->numRecords - 1;
+	upperBound = SWAP_BE16(node->numRecords) - 1;
 	
 	while (lowerBound <= upperBound)
 	{
@@ -805,7 +807,7 @@ OSStatus	GetRecordByIndex	(BTreeControlB
 	//
 	//	Make sure index is valid (in range 0..numRecords-1)
 	//
-	if (index >= node->numRecords)
+	if (index >= SWAP_BE16(node->numRecords))
 		return fsBTRecordNotFoundErr;
 
 	//// find keyPtr
@@ -846,9 +848,9 @@ UInt16		GetNodeDataSize	(BTreeControlBlo
 {
 	UInt16 freeOffset;
 	
-	freeOffset = GetRecordOffset (btreePtr, node, node->numRecords);
+	freeOffset = GetRecordOffset (btreePtr, node, SWAP_BE16(node->numRecords));
 	
-	return	freeOffset + (node->numRecords << 1) - sizeof (BTNodeDescriptor);
+	return	freeOffset + (SWAP_BE16(node->numRecords) << 1) - sizeof (BTNodeDescriptor);
 }
 
 
@@ -869,9 +871,9 @@ UInt16		GetNodeFreeSize	(BTreeControlBlo
 {
 	UInt16	freeOffset;
 	
-	freeOffset = GetRecordOffset (btreePtr, node, node->numRecords);	//ее inline?
+	freeOffset = GetRecordOffset (btreePtr, node, SWAP_BE16(node->numRecords));	//ее inline?
 	
-	return btreePtr->nodeSize - freeOffset - (node->numRecords << 1) - kOffsetSize;
+	return btreePtr->nodeSize - freeOffset - (SWAP_BE16(node->numRecords) << 1) - kOffsetSize;
 }
 
 
@@ -899,7 +901,7 @@ UInt16		GetRecordOffset	(BTreeControlBlo
 		
 	pos = (UInt8 *)node + btreePtr->nodeSize - (index << 1) - kOffsetSize;
 	
-	return *(short *)pos;
+	return *(u_big_int16_t *)pos;
 }
 #endif
 
@@ -952,11 +954,11 @@ UInt16		GetRecordSize		(BTreeControlBloc
 								 NodeDescPtr			node,
 								 UInt16					index )
 {
-	UInt16	*pos;
+	u_big_int16_t	*pos;
 		
-	pos = (UInt16 *) ((Ptr)node + btreePtr->nodeSize - (index << 1) - kOffsetSize);
+	pos = (u_big_int16_t *) ((Ptr)node + btreePtr->nodeSize - (index << 1) - kOffsetSize);
 	
-	return  *(pos-1) - *pos;
+	return  SWAP_BE16(*(pos-1)) - SWAP_BE16(*pos);
 }
 
 
@@ -973,7 +975,7 @@ Input:		btreePtr		- pointer to BTree con
 Result:		- pointer to offset for record "index".
 -------------------------------------------------------------------------------*/
 
-UInt16	   *GetOffsetAddress	(BTreeControlBlockPtr	btreePtr,
+u_big_int16_t *GetOffsetAddress	(BTreeControlBlockPtr	btreePtr,
 								 NodeDescPtr			node,
 								 UInt16					index )
 {
@@ -981,7 +983,7 @@ UInt16	   *GetOffsetAddress	(BTreeContro
 	
 	pos = (Ptr)node + btreePtr->nodeSize - (index << 1) -2;
 	
-	return (UInt16 *)pos;
+	return (u_big_int16_t *)pos;
 }
 
 
@@ -1035,15 +1037,16 @@ void		InsertOffset		(BTreeControlBlockPt
 								 UInt16					 index,
 								 UInt16					 delta )
 {
-	UInt16		*src, *dst;
+	u_big_int16_t *src, *dst;
 	UInt16		 numOffsets;
 	
-	src = GetOffsetAddress (btreePtr, node, node->numRecords);	// point to free offset
+	src = GetOffsetAddress (btreePtr, node, SWAP_BE16(node->numRecords));	// point to free offset
 	dst = src - 1; 												// point to new offset
-	numOffsets = node->numRecords++ - index;			// subtract index  & postincrement
+	numOffsets = SWAP_BE16(node->numRecords) - index;			// subtract index  & postincrement
+	SET_SWAP_BE16(node->numRecords, SWAP_BE16(node->numRecords) + 1);
 	
 	do {
-		*dst++ = *src++ + delta;								// to tricky?
+		SET_SWAP_BE16(*dst++, SWAP_BE16(*src++) + delta);		// to tricky?
 	} while (numOffsets--);
 }
 
@@ -1068,18 +1071,19 @@ void		DeleteOffset		(BTreeControlBlockPt
 								 NodeDescPtr			 node,
 								 UInt16					 index )
 {
-	UInt16		*src, *dst;
+	u_big_int16_t *src, *dst;
 	UInt16		 numOffsets;
 	UInt16		 delta;
 	
 	dst			= GetOffsetAddress (btreePtr, node, index);
 	src			= dst - 1;
-	delta		= *src - *dst;
-	numOffsets	= --node->numRecords - index;	// predecrement numRecords & subtract index
+	delta		= SWAP_BE16(*src) - SWAP_BE16(*dst);
+	SET_SWAP_BE16(node->numRecords, SWAP_BE16(node->numRecords) - 1);
+	numOffsets	= SWAP_BE16(node->numRecords) - index;	// predecrement numRecords & subtract index
 	
 	while (numOffsets--)
 	{
-		*--dst = *--src - delta;				// work our way left
+		SET_SWAP_BE16(*--dst, SWAP_BE16(*--src) - delta);	// work our way left
 	}
 }
 
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/BTreePrivate.h diskdev_cmds/fsck_hfs.tproj/dfalib/BTreePrivate.h
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/BTreePrivate.h	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/BTreePrivate.h	2003-05-05 12:36:30.000000000 +0200
@@ -148,10 +148,10 @@ typedef struct BTreeControlBlock {					/
 
 
 UInt32 CalcKeySize(const BTreeControlBlock *btcb, const BTreeKey *key);
-#define CalcKeySize(btcb, key)			( ((btcb)->attributes & kBTBigKeysMask) ? ((key)->length16 + 2) : ((key)->length8 + 1) )
+#define CalcKeySize(btcb, key)			( ((btcb)->attributes & kBTBigKeysMask) ? (SWAP_BE16((key)->length16) + 2) : ((key)->length8 + 1) )
 
 UInt32 KeyLength(const BTreeControlBlock *btcb, const BTreeKey *key);
-#define KeyLength(btcb, key)			( ((btcb)->attributes & kBTBigKeysMask) ? (key)->length16 : (key)->length8 )
+#define KeyLength(btcb, key)			( ((btcb)->attributes & kBTBigKeysMask) ? SWAP_BE16((key)->length16) : (key)->length8 )
 
 
 
@@ -296,13 +296,13 @@ OSStatus	GetLeftSiblingNode		(BTreeContr
 									 NodeDescPtr			 node,
 									 NodeRec				*left );
 
-#define		GetLeftSiblingNode(btree,node,left)			GetNode ((btree), ((NodeDescPtr)(node))->bLink, (left))
+#define		GetLeftSiblingNode(btree,node,left)			GetNode ((btree), SWAP_BE32(((NodeDescPtr)(node))->bLink), (left))
 
 OSStatus	GetRightSiblingNode		(BTreeControlBlockPtr	 btreePtr,
 									 NodeDescPtr			 node,
 									 NodeRec				*right );
 
-#define		GetRightSiblingNode(btree,node,right)		GetNode ((btree), ((NodeDescPtr)(node))->fLink, (right))
+#define		GetRightSiblingNode(btree,node,right)		GetNode ((btree), SWAP_BE32(((NodeDescPtr)(node))->fLink), (right))
 
 
 OSStatus	GetNewNode				(BTreeControlBlockPtr	 btreePtr,
@@ -372,7 +372,7 @@ UInt8 *		GetRecordAddress		(BTreeControl
 									 NodeDescPtr			 node,
 									 UInt16					 index );
 
-#define GetRecordAddress(btreePtr,node,index)		((UInt8 *)(node) + (*(short *) ((UInt8 *)(node) + (btreePtr)->nodeSize - ((index) << 1) - kOffsetSize)))
+#define GetRecordAddress(btreePtr,node,index)		((UInt8 *)(node) + SWAP_BE16(*(u_big_int16_t *) ((UInt8 *)(node) + (btreePtr)->nodeSize - ((index) << 1) - kOffsetSize)))
 
 
 UInt16		GetRecordSize			(BTreeControlBlockPtr	 btree,
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/BTreeTreeOps.c diskdev_cmds/fsck_hfs.tproj/dfalib/BTreeTreeOps.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/BTreeTreeOps.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/BTreeTreeOps.c	2003-05-05 12:29:40.000000000 +0200
@@ -221,7 +221,7 @@ OSStatus	SearchTree	(BTreeControlBlockPt
         //
         if (curNodeNum == 0)
         {
-//          Panic("\pSearchTree: curNodeNum is zero!");
+//          Panic("SearchTree: curNodeNum is zero!");
             err = fsBTInvalidNodeErr;
             goto ErrorExit;
         }
@@ -251,7 +251,7 @@ OSStatus	SearchTree	(BTreeControlBlockPt
 		treePathTable [level].index = index;
 		
 		GetRecordByIndex (btreePtr, nodeRec.buffer, index, &keyPtr, &dataPtr, &dataSize);
-		curNodeNum = *(UInt32 *)dataPtr;
+		curNodeNum = SWAP_BE32(*(u_big_int32_t *)dataPtr);
 		err = ReleaseNode (btreePtr, &nodeRec);
 		if (err != noErr)
 		{
@@ -383,7 +383,7 @@ OSStatus	InsertLevel (BTreeControlBlockP
 		M_ExitOnError (err);
 		
 		if ( DEBUG_BUILD && updateParent && newRoot )
-			DebugStr("\p InsertLevel: New root from primary key, update from secondary key...");
+			DebugStr(" InsertLevel: New root from primary key, update from secondary key...");
 	}
 
 	//////////////////////// Update Parent(s) ///////////////////////////////
@@ -398,7 +398,7 @@ OSStatus	InsertLevel (BTreeControlBlockP
 		
 		secondaryKey = nil;
 		
-		PanicIf ( (level == btreePtr->treeDepth), "\p InsertLevel: unfinished insert!?");
+		PanicIf ( (level == btreePtr->treeDepth), " InsertLevel: unfinished insert!?");
 
 		++level;
 
@@ -406,7 +406,7 @@ OSStatus	InsertLevel (BTreeControlBlockP
 		index = treePathTable [level].index;
 		parentNodeNum = treePathTable [level].node;
 
-		PanicIf ( parentNodeNum == 0, "\p InsertLevel: parent node is zero!?");
+		PanicIf ( parentNodeNum == 0, " InsertLevel: parent node is zero!?");
 
 		err = GetNode (btreePtr, parentNodeNum, &parentNode);	// released as target node in next level up
 		M_ExitOnError (err);
@@ -420,7 +420,7 @@ OSStatus	InsertLevel (BTreeControlBlockP
 		{
 			//ее╩debug: check if ptr == targetNodeNum
 			GetRecordByIndex (btreePtr, parentNode.buffer, index, &keyPtr, &recPtr, &recSize);
-			PanicIf( (*(UInt32 *) recPtr) != targetNodeNum, "\p InsertLevel: parent ptr doesn't match target node!");
+			PanicIf( SWAP_BE32(*(u_big_int32_t*) recPtr) != targetNodeNum, " InsertLevel: parent ptr doesn't match target node!");
 			
 			// need to delete and re-insert this parent key/ptr
 			// we delete it here and it gets re-inserted in the
@@ -482,7 +482,7 @@ ErrorExit:
 	(void) ReleaseNode (btreePtr, targetNode);
 	(void) ReleaseNode (btreePtr, &siblingNode);
 
-	Panic ("\p InsertLevel: an error occured!");
+	Panic (" InsertLevel: an error occured!");
 
 	return	err;
 
@@ -516,10 +516,10 @@ static OSErr	InsertNode	(BTreeControlBlo
 
 	*rootSplit = false;
 	
-	PanicIf ( targetNode->buffer == siblingNode->buffer, "\p InsertNode: targetNode == siblingNode, huh?");
+	PanicIf ( targetNode->buffer == siblingNode->buffer, " InsertNode: targetNode == siblingNode, huh?");
 	
-	leftNodeNum = ((NodeDescPtr) targetNode->buffer)->bLink;
-	rightNodeNum = ((NodeDescPtr) targetNode->buffer)->fLink;
+	leftNodeNum = SWAP_BE32(((NodeDescPtr) targetNode->buffer)->bLink);
+	rightNodeNum = SWAP_BE32(((NodeDescPtr) targetNode->buffer)->fLink);
 
 
 	/////////////////////// Try Simple Insert ///////////////////////////////
@@ -556,7 +556,7 @@ static OSErr	InsertNode	(BTreeControlBlo
 	
 	if ( leftNodeNum > 0 )
 	{
-		PanicIf ( siblingNode->buffer != nil, "\p InsertNode: siblingNode already aquired!");
+		PanicIf ( siblingNode->buffer != nil, " InsertNode: siblingNode already aquired!");
 
 		if ( siblingNode->buffer == nil )
 		{
@@ -564,7 +564,7 @@ static OSErr	InsertNode	(BTreeControlBlo
 			M_ExitOnError (err);
 		}
 
-		PanicIf ( ((NodeDescPtr) siblingNode->buffer)->fLink != nodeNum, "\p InsertNode, RotateLeft: invalid sibling link!" );
+		PanicIf ( SWAP_BE32(((NodeDescPtr) siblingNode->buffer)->fLink) != nodeNum, " InsertNode, RotateLeft: invalid sibling link!" );
 
 		if ( !key->skipRotate )		// are rotates allowed?
 		{
@@ -653,13 +653,13 @@ OSStatus	DeleteTree			(BTreeControlBlock
 
 	targetNodeNum = treePathTable[level].node;
 	targetNodePtr = targetNode->buffer;
-	PanicIf (targetNodePtr == nil, "\pDeleteTree: targetNode has nil buffer!");
+	PanicIf (targetNodePtr == nil, "DeleteTree: targetNode has nil buffer!");
 
 	DeleteRecord (btreePtr, targetNodePtr, index);
 		
 	//ее coalesce remaining records?
 
-	if ( targetNodePtr->numRecords == 0 )	// did we delete the last record?
+	if ( SWAP_BE16(targetNodePtr->numRecords) == 0 )	// did we delete the last record?
 	{
 		BlockDescriptor		siblingNode;
 		UInt32				siblingNodeNum;
@@ -668,7 +668,7 @@ OSStatus	DeleteTree			(BTreeControlBlock
 		
 		////////////////// Get Siblings & Update Links //////////////////////////
 		
-		siblingNodeNum = targetNodePtr->bLink;				// Left Sibling Node
+		siblingNodeNum = SWAP_BE32(targetNodePtr->bLink);				// Left Sibling Node
 		if ( siblingNodeNum != 0 )
 		{
 			err = GetNode (btreePtr, siblingNodeNum, &siblingNode);
@@ -679,10 +679,10 @@ OSStatus	DeleteTree			(BTreeControlBlock
 		}
 		else if ( targetNodePtr->kind == kBTLeafNode )		// update firstLeafNode
 		{
-			btreePtr->firstLeafNode = targetNodePtr->fLink;
+			btreePtr->firstLeafNode = SWAP_BE32(targetNodePtr->fLink);
 		}
 
-		siblingNodeNum = targetNodePtr->fLink;				// Right Sibling Node
+		siblingNodeNum = SWAP_BE32(targetNodePtr->fLink);				// Right Sibling Node
 		if ( siblingNodeNum != 0 )
 		{
 			err = GetNode (btreePtr, siblingNodeNum, &siblingNode);
@@ -693,7 +693,7 @@ OSStatus	DeleteTree			(BTreeControlBlock
 		}
 		else if ( targetNodePtr->kind == kBTLeafNode )		// update lastLeafNode
 		{
-			btreePtr->lastLeafNode = targetNodePtr->bLink;
+			btreePtr->lastLeafNode = SWAP_BE32(targetNodePtr->bLink);
 		}
 		
 		//////////////////////// Free Empty Node ////////////////////////////////
@@ -721,7 +721,7 @@ OSStatus	DeleteTree			(BTreeControlBlock
 			btreePtr->rootNode  = 0;
 			btreePtr->treeDepth = 0;
 		}
-		else if ( ((NodeDescPtr)targetNode->buffer)->numRecords == 1 )
+		else if ( SWAP_BE16(((NodeDescPtr)targetNode->buffer)->numRecords) == 1 )
 		{
 			err = CollapseTree (btreePtr, targetNode);
 			M_ExitOnError (err);
@@ -747,7 +747,7 @@ OSStatus	DeleteTree			(BTreeControlBlock
 			 
 			//ее╩debug: check if ptr == targetNodeNum
 			GetRecordByIndex (btreePtr, parentNode.buffer, index, &keyPtr, &recPtr, &recSize);
-			PanicIf( (*(UInt32 *) recPtr) != targetNodeNum, "\p DeleteTree: parent ptr doesn't match targetNodeNum!!");
+			PanicIf( SWAP_BE32(*(u_big_int32_t *) recPtr) != targetNodeNum, " DeleteTree: parent ptr doesn't match targetNodeNum!!");
 			
 			// need to delete and re-insert this parent key/ptr
 			DeleteRecord (btreePtr, parentNode.buffer, index);
@@ -797,7 +797,7 @@ static OSStatus	CollapseTree	(BTreeContr
 	
 	while (true)
 	{
-		if ( ((NodeDescPtr)blockPtr->buffer)->numRecords > 1)
+		if ( SWAP_BE16(((NodeDescPtr)blockPtr->buffer)->numRecords) > 1)
 			break;							// this will make a fine root node
 		
 		if ( ((NodeDescPtr)blockPtr->buffer)->kind == kBTLeafNode)
@@ -962,26 +962,26 @@ static OSStatus	RotateLeft		(BTreeContro
 		{
 			UInt16	leftInsertIndex;
 			
-			leftInsertIndex = leftNode->numRecords;
+			leftInsertIndex = SWAP_BE16(leftNode->numRecords);
 
 			didItFit = InsertKeyRecord (btreePtr, leftNode, leftInsertIndex,
 										keyPtr, keyLength, recPtr, recSize);
 			if ( !didItFit )
 			{
-				Panic ("\pRotateLeft: InsertKeyRecord (left) returned false!");
+				Panic ("RotateLeft: InsertKeyRecord (left) returned false!");
 				err = fsBTBadRotateErr;
 				goto ErrorExit;
 			}
 			
 			*insertIndex = leftInsertIndex;
-			*insertNodeNum = rightNode->bLink;
+			*insertNodeNum = SWAP_BE32(rightNode->bLink);
 		}
 		else
 		{
 			didItFit = RotateRecordLeft (btreePtr, leftNode, rightNode);
 			if ( !didItFit )
 			{
-				Panic ("\pRotateLeft: RotateRecordLeft returned false!");
+				Panic ("RotateLeft: RotateRecordLeft returned false!");
 				err = fsBTBadRotateErr;
 				goto ErrorExit;
 			}
@@ -998,13 +998,13 @@ static OSStatus	RotateLeft		(BTreeContro
 									keyPtr, keyLength, recPtr, recSize);
 		if ( !didItFit )
 		{
-			Panic ("\pRotateLeft: InsertKeyRecord (right) returned false!");
+			Panic ("RotateLeft: InsertKeyRecord (right) returned false!");
 			err = fsBTBadRotateErr;
 			goto ErrorExit;
 		}
 	
 		*insertIndex = rightInsertIndex;
-		*insertNodeNum = leftNode->fLink;
+		*insertNodeNum = SWAP_BE32(leftNode->fLink);
 	}
 
 #if DEBUG_TREEOPS
@@ -1067,7 +1067,7 @@ static OSStatus	SplitLeft		(BTreeControl
 	right = rightNode->buffer;
 	left  = leftNode->buffer;
 	
-	PanicIf ( right->bLink != 0 && left == 0, "\p SplitLeft: left sibling missing!?" );
+	PanicIf ( right->bLink != 0 && left == 0, " SplitLeft: left sibling missing!?" );
 	
 	//ее type should be kLeafNode or kIndexNode
 	
@@ -1166,7 +1166,7 @@ static Boolean RotateRecordLeft (BTreeCo
 	size	= GetRecordSize (btreePtr, rightNode, 0);
 	recPtr	= GetRecordAddress (btreePtr, rightNode, 0);
 	
-	recordFit = InsertRecord (btreePtr, leftNode, leftNode->numRecords, recPtr, size);
+	recordFit = InsertRecord (btreePtr, leftNode, SWAP_BE16(leftNode->numRecords), recPtr, size);
 	
 	if ( !recordFit )
 		return false;
@@ -1190,8 +1190,8 @@ static OSStatus	AddNewRootNode	(BTreeCon
 	Boolean				didItFit;
 	UInt16				keyLength;	
 	
-	PanicIf (leftNode == nil, "\pAddNewRootNode: leftNode == nil");
-	PanicIf (rightNode == nil, "\pAddNewRootNode: rightNode == nil");
+	PanicIf (leftNode == nil, "AddNewRootNode: leftNode == nil");
+	PanicIf (rightNode == nil, "AddNewRootNode: rightNode == nil");
 	
 	
 	/////////////////////// Initialize New Root Node ////////////////////////////
@@ -1214,7 +1214,7 @@ static OSStatus	AddNewRootNode	(BTreeCon
 	didItFit = InsertKeyRecord ( btreePtr, rootNode.buffer, 0, keyPtr, keyLength,
 								 (UInt8 *) &rightNode->bLink, 4 );
 
-	PanicIf ( !didItFit, "\pAddNewRootNode:InsertKeyRecord failed for left index record");
+	PanicIf ( !didItFit, "AddNewRootNode:InsertKeyRecord failed for left index record");
 
 
 	//////////////////// Insert Right Node Index Record /////////////////////////
@@ -1225,7 +1225,7 @@ static OSStatus	AddNewRootNode	(BTreeCon
 	didItFit = InsertKeyRecord ( btreePtr, rootNode.buffer, 1, keyPtr, keyLength,
 								 (UInt8 *) &leftNode->fLink, 4 );
 
-	PanicIf ( !didItFit, "\pAddNewRootNode:InsertKeyRecord failed for right index record");
+	PanicIf ( !didItFit, "AddNewRootNode:InsertKeyRecord failed for right index record");
 
 
 #if DEBUG_TREEOPS
@@ -1298,14 +1298,14 @@ static OSStatus	SplitRight		(BTreeContro
 
 	leftPtr  = nodePtr->buffer;
 	
-	if ( leftPtr->fLink != 0 )
+	if ( SWAP_BE32(leftPtr->fLink) != 0 )
 	{
-		err = GetNode( btreePtr, leftPtr->fLink, rightNodePtr );
+		err = GetNode( btreePtr, SWAP_BE32(leftPtr->fLink), rightNodePtr );
 		M_ExitOnError( err );
 	}
 	rightPtr = rightNodePtr->buffer;
 	
-	PanicIf ( leftPtr->fLink != 0 && rightPtr == 0, "\p SplitRight: right sibling missing!?" );
+	PanicIf ( SWAP_BE32(leftPtr->fLink) != 0 && rightPtr == 0, " SplitRight: right sibling missing!?" );
 	
 	//ее type should be kLeafNode or kIndexNode
 	
@@ -1314,7 +1314,7 @@ static OSStatus	SplitRight		(BTreeContro
 	
 	if ( rightPtr != nil )
 	{
-		if ( rightPtr->bLink != nodeNum )
+		if ( SWAP_BE32(rightPtr->bLink) != nodeNum )
 			return fsBTInvalidNodeErr;										//ее E_BadSibling ?
 	
 		if ( rightPtr->height != leftPtr->height )
@@ -1334,7 +1334,7 @@ static OSStatus	SplitRight		(BTreeContro
 
 	if ( rightPtr != nil )
 	{
-		rightPtr->bLink	= newNodeNum;
+		SET_SWAP_BE32(rightPtr->bLink, newNodeNum);
 		err = UpdateNode (btreePtr, rightNodePtr);
 		M_ExitOnError (err);
 	}
@@ -1345,7 +1345,7 @@ static OSStatus	SplitRight		(BTreeContro
 	M_ExitOnError (err);
 	
 	rightPtr			= rightNodePtr->buffer;
-	rightPtr->bLink		= nodeNum;
+	SET_SWAP_BE32(rightPtr->bLink, nodeNum);
 	
 
 	// Steal Info From Left Node
@@ -1354,9 +1354,9 @@ static OSStatus	SplitRight		(BTreeContro
 	rightPtr->kind   = leftPtr->kind;
 	rightPtr->height = leftPtr->height;
 	
-	leftPtr->fLink		= newNodeNum;			// update Left fLink
+	SET_SWAP_BE32(leftPtr->fLink, newNodeNum);			// update Left fLink
 
-	if ( (rightPtr->kind == kBTLeafNode) && (rightPtr->fLink == 0) )
+	if ( (rightPtr->kind == kBTLeafNode) && (SWAP_BE32(rightPtr->fLink) == 0) )
 	{
 		// if we're adding a new last leaf node - update BTreeInfoRec
 		
@@ -1458,14 +1458,14 @@ static OSStatus	RotateRight		(BTreeContr
 	rightSize		= nodeSize - GetNodeFreeSize( btreePtr, rightNodePtr );
 	leftSize		= nodeSize - GetNodeFreeSize( btreePtr, leftNodePtr ) + insertSize;
 
-	moveIndex	= leftNodePtr->numRecords - 1; // start at last record in the node
+	moveIndex	= SWAP_BE16(leftNodePtr->numRecords) - 1; // start at last record in the node
 	moveSize	= 0;
 
 	while ( rightSize < leftSize )
 	{
 		moveSize = GetRecordSize( btreePtr, leftNodePtr, moveIndex ) + 2;
 
-		if ( moveIndex == leftInsertIndex || leftNodePtr->numRecords == leftInsertIndex )
+		if ( moveIndex == leftInsertIndex || SWAP_BE16(leftNodePtr->numRecords) == leftInsertIndex )
 			moveSize += insertSize;
 		
 		leftSize	-= moveSize;
@@ -1495,26 +1495,26 @@ static OSStatus	RotateRight		(BTreeContr
 	//////////////////////////// Rotate Records /////////////////////////////////
 
 	*didRecordFitPtr	= true;
-	index				= leftNodePtr->numRecords - 1;
+	index				= SWAP_BE16(leftNodePtr->numRecords) - 1;
 	*recsRotatedPtr		= index - moveIndex;
 	myInsertIndex 		= 0;
 	
 	// handle case where the new record is inserting after the last
 	// record in our left node.
-	if ( leftNodePtr->numRecords == leftInsertIndex )
+	if ( SWAP_BE16(leftNodePtr->numRecords) == leftInsertIndex )
 	{
 		didItFit = InsertKeyRecord (btreePtr, rightNodePtr, 0,
 									keyPtr, keyLength, recPtr, recSize);
 		if ( !didItFit )
 		{
-			Panic ("\pRotateRight: InsertKeyRecord (left) returned false!");
+			Panic ("RotateRight: InsertKeyRecord (left) returned false!");
 			err = fsBTBadRotateErr;
 			goto ErrorExit;
 		}
 		
 		// NOTE - our insert location will slide as we insert more records
 		doIncrement = true;
-		*newNodeNumPtr = leftNodePtr->fLink;
+		*newNodeNumPtr = SWAP_BE32(leftNodePtr->fLink);
 	}
 
 	while ( index > moveIndex )
@@ -1522,7 +1522,7 @@ static OSStatus	RotateRight		(BTreeContr
 		didItFit = RotateRecordRight( btreePtr, leftNodePtr, rightNodePtr );
 		if ( !didItFit )
 		{
-			Panic ("\pRotateRight: RotateRecordRight returned false!");
+			Panic ("RotateRight: RotateRecordRight returned false!");
 			err = fsBTBadRotateErr;
 			goto ErrorExit;
 		}
@@ -1533,7 +1533,7 @@ static OSStatus	RotateRight		(BTreeContr
 										keyPtr, keyLength, recPtr, recSize);
 			if ( !didItFit )
 			{
-				Panic ("\pRotateRight: InsertKeyRecord (left) returned false!");
+				Panic ("RotateRight: InsertKeyRecord (left) returned false!");
 				err = fsBTBadRotateErr;
 				goto ErrorExit;
 			}
@@ -1541,7 +1541,7 @@ static OSStatus	RotateRight		(BTreeContr
 			// NOTE - our insert index will slide as we insert more records
 			doIncrement = true;
 			myInsertIndex = -1;
-			*newNodeNumPtr = leftNodePtr->fLink;
+			*newNodeNumPtr = SWAP_BE32(leftNodePtr->fLink);
 		}
 
 		if ( doIncrement )
@@ -1557,13 +1557,13 @@ static OSStatus	RotateRight		(BTreeContr
 									keyPtr, keyLength, recPtr, recSize);
 		if ( !didItFit )
 		{
-			Panic ("\pRotateRight: InsertKeyRecord (right) returned false!");
+			Panic ("RotateRight: InsertKeyRecord (right) returned false!");
 			err = fsBTBadRotateErr;
 			goto ErrorExit;
 		}
 	
 		*insertIndexPtr = leftInsertIndex;
-		*newNodeNumPtr = rightNodePtr->bLink;
+		*newNodeNumPtr = SWAP_BE32(rightNodePtr->bLink);
 	}
 
 #if DEBUG_TREEOPS
@@ -1620,14 +1620,14 @@ static Boolean RotateRecordRight (BTreeC
 	UInt8 *		recPtr;
 	Boolean		didRecordFit;
 	
-	size	= GetRecordSize( btreePtr, leftNodePtr, leftNodePtr->numRecords - 1 ) ;
-	recPtr	= GetRecordAddress( btreePtr, leftNodePtr, leftNodePtr->numRecords - 1 ) ;
+	size	= GetRecordSize( btreePtr, leftNodePtr, SWAP_BE16(leftNodePtr->numRecords) - 1 ) ;
+	recPtr	= GetRecordAddress( btreePtr, leftNodePtr, SWAP_BE16(leftNodePtr->numRecords) - 1 ) ;
 	
 	didRecordFit = InsertRecord( btreePtr, rightNodePtr, 0, recPtr, size );
 	if ( !didRecordFit )
 		return false;
 	
-	DeleteRecord( btreePtr, leftNodePtr, leftNodePtr->numRecords - 1 );
+	DeleteRecord( btreePtr, leftNodePtr, SWAP_BE16(leftNodePtr->numRecords) - 1 );
 	
 	return true;
 	
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/CatalogCheck.c diskdev_cmds/fsck_hfs.tproj/dfalib/CatalogCheck.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/CatalogCheck.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/CatalogCheck.c	2003-05-05 12:30:32.000000000 +0200
@@ -61,7 +61,7 @@ static int  CheckFile_HFS(const HFSCatal
 static int  CheckThread_HFS(const HFSCatalogKey * key, const HFSCatalogThread * thread);
 
 static void CheckBSDInfo(const HFSPlusCatalogKey * key, const HFSPlusBSDInfo * bsdInfo, int isdir);
-static int  CheckCatalogName(u_int16_t charCount, const u_int16_t *uniChars,
+static int  CheckCatalogName(u_int16_t charCount, const u_big_int16_t *uniChars,
                              u_int32_t parentID, Boolean thread);
 static int  CheckCatalogName_HFS(u_int16_t charCount, const u_char *filename,
                                  u_int32_t parentID, Boolean thread);
@@ -75,7 +75,7 @@ static 	OSErr	UniqueDotName( 	SGlobPtr G
                                 UInt32 theParID, 
                                 Boolean isSingleDotName,
                                 Boolean isHFSPlus );
-static Boolean 	FixDecomps(	u_int16_t charCount, const u_int16_t *inFilename, HFSUniStr255 *outFilename );
+static Boolean 	FixDecomps(	u_int16_t charCount, const u_big_int16_t *inFilename, HFSUniStr255 *outFilename );
 static void 	PrintName( int theCount, const UInt8 *theNamePtr, Boolean isUnicodeString );
 
 /*
@@ -169,9 +169,9 @@ CheckCatalogRecord(const HFSPlusCatalogK
 	if (!gScavGlobals->isHFSPlus)
 		return CheckCatalogRecord_HFS((HFSCatalogKey *)key, rec, reclen);
 
-	gScavGlobals->CNType = rec->recordType;
+	gScavGlobals->CNType = SWAP_BE16(rec->recordType);
 
-	switch (rec->recordType) {
+	switch (SWAP_BE16(rec->recordType)) {
 	case kHFSPlusFolderRecord:
 		++gCIS.dirCount;
 		if (reclen != sizeof(HFSPlusCatalogFolder)){
@@ -179,12 +179,12 @@ CheckCatalogRecord(const HFSPlusCatalogK
 			result = E_LenDir;
 			break;
 		}
-		if (key->parentID != gCIS.parentID) {
-			result = CaptureMissingThread(key->parentID, key);
+		if (SWAP_BE32(key->parentID) != gCIS.parentID) {
+			result = CaptureMissingThread(SWAP_BE32(key->parentID), key);
 			if (result) break;
 			/* Pretend thread record was there */
 			++gCIS.dirThreads;
-			gCIS.parentID = key->parentID;
+			gCIS.parentID = SWAP_BE32(key->parentID);
 		}
 		result = CheckDirectory(key, (HFSPlusCatalogFolder *)rec);
 		break;
@@ -196,23 +196,23 @@ CheckCatalogRecord(const HFSPlusCatalogK
 			result = E_LenFil;
 			break;
 		}
-		if (key->parentID != gCIS.parentID) {
-			result = CaptureMissingThread(key->parentID, key);
+		if (SWAP_BE32(key->parentID) != gCIS.parentID) {
+			result = CaptureMissingThread(SWAP_BE32(key->parentID), key);
 			if (result) break;
 			/* Pretend thread record was there */
 			++gCIS.dirThreads;
-			gCIS.parentID = key->parentID;
+			gCIS.parentID = SWAP_BE32(key->parentID);
 		}
 		result = CheckFile(key, (HFSPlusCatalogFile *)rec);
 		break;
 
 	case kHFSPlusFolderThreadRecord:
 		++gCIS.dirThreads;
-		gCIS.parentID = key->parentID;
+		gCIS.parentID = SWAP_BE32(key->parentID);
 		/* Fall through */
 
 	case kHFSPlusFileThreadRecord:
-		if (rec->recordType == kHFSPlusFileThreadRecord)
+		if (SWAP_BE16(rec->recordType) == kHFSPlusFileThreadRecord)
 			++gCIS.fileThreads;
 
 		if (reclen > sizeof(HFSPlusCatalogThread) ||
@@ -244,53 +244,53 @@ CheckCatalogRecord_HFS(const HFSCatalogK
 {
 	int result = 0;
 
-	gScavGlobals->CNType = rec->recordType;
+	gScavGlobals->CNType = SWAP_BE16(rec->recordType);
 
-	switch (rec->recordType) {
+	switch (SWAP_BE16(rec->recordType)) {
 	case kHFSFolderRecord:
 		++gCIS.dirCount;
-		if (key->parentID == kHFSRootFolderID )
+		if (SWAP_BE32(key->parentID) == kHFSRootFolderID )
 			++gCIS.rootDirCount;
 		if (reclen != sizeof(HFSCatalogFolder)){
 			RcdError(gScavGlobals, E_LenDir);
 			result = E_LenDir;
 			break;
 		}
-		if (key->parentID != gCIS.parentID) {
-			result = CaptureMissingThread(key->parentID, (HFSPlusCatalogKey *)key);
+		if (SWAP_BE32(key->parentID) != gCIS.parentID) {
+			result = CaptureMissingThread(SWAP_BE32(key->parentID), (HFSPlusCatalogKey *)key);
 			if (result) break;
 			/* Pretend thread record was there */
 			++gCIS.dirThreads;
-			gCIS.parentID = key->parentID;
+			gCIS.parentID = SWAP_BE32(key->parentID);
 		}
 		result = CheckDirectory_HFS(key, (HFSCatalogFolder *)rec);
 		break;
 
 	case kHFSFileRecord:
 		++gCIS.fileCount;
-		if (key->parentID == kHFSRootFolderID )
+		if (SWAP_BE32(key->parentID) == kHFSRootFolderID )
 			++gCIS.rootFileCount;
 		if (reclen != sizeof(HFSCatalogFile)){
 			RcdError(gScavGlobals, E_LenFil);
 			result = E_LenFil;
 			break;
 		}
-		if (key->parentID != gCIS.parentID) {
-			result = CaptureMissingThread(key->parentID, (HFSPlusCatalogKey *)key);
+		if (SWAP_BE32(key->parentID) != gCIS.parentID) {
+			result = CaptureMissingThread(SWAP_BE32(key->parentID), (HFSPlusCatalogKey *)key);
 			if (result) break;
 			/* Pretend thread record was there */
 			++gCIS.dirThreads;
-			gCIS.parentID = key->parentID;
+			gCIS.parentID = SWAP_BE32(key->parentID);
 		}
 		result = CheckFile_HFS(key, (HFSCatalogFile *)rec);
 		break;
 
 	case kHFSFolderThreadRecord:
 		++gCIS.dirThreads;
-		gCIS.parentID = key->parentID;
+		gCIS.parentID = SWAP_BE32(key->parentID);
 		/* Fall through */
 	case kHFSFileThreadRecord:
-		if (rec->recordType == kHFSFileThreadRecord)
+		if (SWAP_BE16(rec->recordType) == kHFSFileThreadRecord)
 			++gCIS.fileThreads;
 
 		if (reclen != sizeof(HFSCatalogThread)) {
@@ -322,18 +322,18 @@ CheckDirectory(const HFSPlusCatalogKey *
 	UInt32 dirID;
 	int result = 0;
 
-	dirID = dir->folderID;
+	dirID = SWAP_BE32(dir->folderID);
 
 	if (dirID == kHFSRootFolderID) {
 		size_t len;
 
 		(void) utf_encodestr(key->nodeName.unicode,
-					key->nodeName.length * 2,
+					SWAP_BE16(key->nodeName.length) * 2,
 					gScavGlobals->volumeName, &len);
 		gScavGlobals->volumeName[len] = '\0';
 	}
 
-	if (dir->flags != 0) {
+	if (SWAP_BE16(dir->flags) != 0) {
 		RcdError(gScavGlobals, E_CatalogFlagsNotZero);
 		gScavGlobals->CBTStat |= S_ReservedNotZero;
 	}
@@ -346,11 +346,11 @@ CheckDirectory(const HFSPlusCatalogKey *
 	if (dirID >= gCIS.nextCNID )
 		gCIS.nextCNID = dirID + 1;
 
-	gCIS.encodings |= (1 << MapEncodingToIndex(dir->textEncoding & 0x7F));
+	gCIS.encodings |= (1 << MapEncodingToIndex(SWAP_BE32(dir->textEncoding) & 0x7F));
 
         CheckBSDInfo(key, &dir->bsdInfo, true);
 	
-	CheckCatalogName(key->nodeName.length, &key->nodeName.unicode[0], key->parentID, false);
+	CheckCatalogName(SWAP_BE16(key->nodeName.length), key->nodeName.unicode, SWAP_BE32(key->parentID), false);
 	
 	return (result);
 }
@@ -373,7 +373,7 @@ CheckFile(const HFSPlusCatalogKey * key,
 	char filename[256 * 3];
 
 	(void) utf_encodestr(key->nodeName.unicode,
-				key->nodeName.length * 2,
+				SWAP_BE16(key->nodeName.length) * 2,
 				filename, &len);
 	filename[len] = '\0';
 
@@ -384,11 +384,11 @@ CheckFile(const HFSPlusCatalogKey * key,
 	 * Macintosh: Files documents this bit for HFS volumes, and some non-Mac implementations
 	 * appear to set the bit.  Therefore, we ignore it.
 	 */
-	if ((file->flags & (UInt16) ~(0X83)) != 0) {
+	if ((SWAP_BE16(file->flags) & (UInt16) ~(0X83)) != 0) {
 		RcdError(gScavGlobals, E_CatalogFlagsNotZero);
 		gScavGlobals->CBTStat |= S_ReservedNotZero;
 	}
-	fileID = file->fileID;
+	fileID = SWAP_BE32(file->fileID);
 	if (fileID < kHFSFirstUserCatalogNodeID) {
 		RcdError(gScavGlobals, E_InvalidID);
 		result = E_InvalidID;
@@ -397,57 +397,57 @@ CheckFile(const HFSPlusCatalogKey * key,
 	if (fileID >= gCIS.nextCNID )
 		gCIS.nextCNID = fileID + 1;
 
-	gCIS.encodings |= (1 << MapEncodingToIndex(file->textEncoding & 0x7F));
+	gCIS.encodings |= (1 << MapEncodingToIndex(SWAP_BE32(file->textEncoding) & 0x7F));
 
         CheckBSDInfo(key, &file->bsdInfo, false);
 
 	/* check out data fork extent info */
-	result = CheckFileExtents(gScavGlobals, file->fileID, 0,
+	result = CheckFileExtents(gScavGlobals, SWAP_BE32(file->fileID), 0,
                                 file->dataFork.extents, &blocks);
 	if (result != noErr)
 		return (result);
 
-	if (file->dataFork.totalBlocks != blocks) {
-		result = RecordBadAllocation(key->parentID, filename, kDataFork,
-					file->dataFork.totalBlocks, blocks);
+	if (SWAP_BE32(file->dataFork.totalBlocks) != blocks) {
+		result = RecordBadAllocation(SWAP_BE32(key->parentID), filename, kDataFork,
+					SWAP_BE32(file->dataFork.totalBlocks), blocks);
 		if (result)
 			return (result);
 	} else {
 		bytes = (UInt64)blocks * (UInt64)gScavGlobals->calculatedVCB->vcbBlockSize;
-		if (file->dataFork.logicalSize > bytes) {
-			result = RecordTruncation(key->parentID, filename, kDataFork,
-					file->dataFork.logicalSize, bytes);
+		if (SWAP_BE64(file->dataFork.logicalSize) > bytes) {
+			result = RecordTruncation(SWAP_BE32(key->parentID), filename, kDataFork,
+					SWAP_BE64(file->dataFork.logicalSize), bytes);
 			if (result)
 				return (result);
 		}
 	}
 	/* check out resource fork extent info */
-	result = CheckFileExtents(gScavGlobals, file->fileID, 0xFF,
+	result = CheckFileExtents(gScavGlobals, SWAP_BE32(file->fileID), 0xFF,
 	                          file->resourceFork.extents, &blocks);
 	if (result != noErr)
 		return (result);
 
-	if (file->resourceFork.totalBlocks != blocks) {
-		result = RecordBadAllocation(key->parentID, filename, kRsrcFork,
-					file->resourceFork.totalBlocks, blocks);
+	if (SWAP_BE32(file->resourceFork.totalBlocks) != blocks) {
+		result = RecordBadAllocation(SWAP_BE32(key->parentID), filename, kRsrcFork,
+					SWAP_BE32(file->resourceFork.totalBlocks), blocks);
 		if (result)
 			return (result);
 	} else {
 		bytes = (UInt64)blocks * (UInt64)gScavGlobals->calculatedVCB->vcbBlockSize;
-		if (file->resourceFork.logicalSize > bytes) {
-			result = RecordTruncation(key->parentID, filename, kRsrcFork,
-					file->resourceFork.logicalSize, bytes);
+		if (SWAP_BE64(file->resourceFork.logicalSize) > bytes) {
+			result = RecordTruncation(SWAP_BE32(key->parentID), filename, kRsrcFork,
+					SWAP_BE64(file->resourceFork.logicalSize), bytes);
 			if (result)
 				return (result);
 		}
 	}
 
 	/* Collect indirect link info for later */
-	if (file->userInfo.fdType == kHardLinkFileType  &&
-            file->userInfo.fdCreator == kHFSPlusCreator)
-		CaptureHardLink(gCIS.hardLinkRef, file->bsdInfo.special.iNodeNum);
+	if (SWAP_BE32(file->userInfo.fdType) == kHardLinkFileType  &&
+            SWAP_BE32(file->userInfo.fdCreator) == kHFSPlusCreator)
+		CaptureHardLink(gCIS.hardLinkRef, SWAP_BE32(file->bsdInfo.special.iNodeNum));
 
-	CheckCatalogName(key->nodeName.length, &key->nodeName.unicode[0], key->parentID, false);
+	CheckCatalogName(SWAP_BE16(key->nodeName.length), key->nodeName.unicode, SWAP_BE32(key->parentID), false);
 
 	return (result);
 }
@@ -462,32 +462,32 @@ CheckThread(const HFSPlusCatalogKey * ke
 {
 	int result = 0;
 
-	if (key->nodeName.length != 0) {
+	if (SWAP_BE16(key->nodeName.length) != 0) {
 		RcdError(gScavGlobals, E_ThdKey);
 		return (E_ThdKey);
 	}
 
-	result = CheckCatalogName(thread->nodeName.length, &thread->nodeName.unicode[0],
-                         thread->parentID, true);
+	result = CheckCatalogName(SWAP_BE16(thread->nodeName.length), thread->nodeName.unicode,
+                         SWAP_BE32(thread->parentID), true);
 	if (result != noErr) {
 		RcdError(gScavGlobals, E_ThdCN);
 		return (E_ThdCN);
 	}	
 
-	if (key->parentID < kHFSFirstUserCatalogNodeID  &&
-            key->parentID != kHFSRootParentID  &&
-            key->parentID != kHFSRootFolderID) {
+	if (SWAP_BE32(key->parentID) < kHFSFirstUserCatalogNodeID  &&
+            SWAP_BE32(key->parentID) != kHFSRootParentID  &&
+            SWAP_BE32(key->parentID) != kHFSRootFolderID) {
 		RcdError(gScavGlobals, E_InvalidID);
 		return (E_InvalidID);
 	}
 
-	if (thread->parentID == kHFSRootParentID) {
-		if (key->parentID != kHFSRootFolderID) {
+	if (SWAP_BE32(thread->parentID) == kHFSRootParentID) {
+		if (SWAP_BE32(key->parentID) != kHFSRootFolderID) {
 			RcdError(gScavGlobals, E_InvalidID);
 			return (E_InvalidID);
 		}
-	} else if (thread->parentID < kHFSFirstUserCatalogNodeID &&
-	           thread->parentID != kHFSRootFolderID) {
+	} else if (SWAP_BE32(thread->parentID) < kHFSFirstUserCatalogNodeID &&
+	           SWAP_BE32(thread->parentID) != kHFSRootFolderID) {
 		RcdError(gScavGlobals, E_InvalidID);
 		return (E_InvalidID);
 	}
@@ -507,14 +507,14 @@ CheckDirectory_HFS(const HFSCatalogKey *
 	UInt32 dirID;
 	int result = 0;
 
-	dirID = dir->folderID;
+	dirID = SWAP_BE32(dir->folderID);
 
 	if (dirID == kHFSRootFolderID) {
 		bcopy(&key->nodeName[1], gScavGlobals->volumeName, key->nodeName[0]);
 		gScavGlobals->volumeName[key->nodeName[0]] = '\0';
 	}
 
-	if (dir->flags != 0) {
+	if (SWAP_BE16(dir->flags) != 0) {
 		RcdError(gScavGlobals, E_CatalogFlagsNotZero);
 		gScavGlobals->CBTStat |= S_ReservedNotZero;
 	}
@@ -527,7 +527,7 @@ CheckDirectory_HFS(const HFSCatalogKey *
 	if (dirID >= gCIS.nextCNID )
 		gCIS.nextCNID = dirID + 1;
 	
-	CheckCatalogName_HFS(key->nodeName[0], &key->nodeName[1], key->parentID, false);
+	CheckCatalogName_HFS(key->nodeName[0], &key->nodeName[1], SWAP_BE32(key->parentID), false);
 	
 	return (result);
 }
@@ -559,15 +559,15 @@ CheckFile_HFS(const HFSCatalogKey * key,
 	 * appear to set the bit.  Therefore, we ignore it.
 	 */
 	if ((file->flags & (UInt8) ~(0X83)) ||
-	    (file->dataStartBlock)          ||
-	    (file->rsrcStartBlock)          ||
+	    (SWAP_BE16(file->dataStartBlock))          ||
+	    (SWAP_BE16(file->rsrcStartBlock))          ||
 	    (file->reserved))
 	{
 		RcdError(gScavGlobals, E_CatalogFlagsNotZero);
 		gScavGlobals->CBTStat |= S_ReservedNotZero;
 	}
 
-	fileID = file->fileID;
+	fileID = SWAP_BE32(file->fileID);
 	if (fileID < kHFSFirstUserCatalogNodeID) {
 		RcdError(gScavGlobals, E_InvalidID);
 		result = E_InvalidID;
@@ -577,29 +577,29 @@ CheckFile_HFS(const HFSCatalogKey * key,
 		gCIS.nextCNID = fileID + 1;
 
 	/* check out data fork extent info */
-	result = CheckFileExtents(gScavGlobals, file->fileID, 0,
+	result = CheckFileExtents(gScavGlobals, SWAP_BE32(file->fileID), 0,
                                 file->dataExtents, &blocks);
 	if (result != noErr)
 		return (result);
-	if (file->dataPhysicalSize > ((UInt64)blocks * (UInt64)gScavGlobals->calculatedVCB->vcbBlockSize)) {
+	if (SWAP_BE32(file->dataPhysicalSize) > ((UInt64)blocks * (UInt64)gScavGlobals->calculatedVCB->vcbBlockSize)) {
 		PrintError(gScavGlobals, E_PEOF, 1, "");
 		return (noErr);		/* we don't fix this, ignore the error */
 	}
-	if (file->dataLogicalSize > file->dataPhysicalSize) {
+	if (SWAP_BE32(file->dataLogicalSize) > SWAP_BE32(file->dataPhysicalSize)) {
 		PrintError(gScavGlobals, E_LEOF, 1, "");
                 return (noErr);		/* we don't fix this, ignore the error */
 	}
 
 	/* check out resource fork extent info */
-	result = CheckFileExtents(gScavGlobals, file->fileID, 0xFF,
+	result = CheckFileExtents(gScavGlobals, SWAP_BE32(file->fileID), 0xFF,
 				file->rsrcExtents, &blocks);
 	if (result != noErr)
 		return (result);
-	if (file->rsrcPhysicalSize > ((UInt64)blocks * (UInt64)gScavGlobals->calculatedVCB->vcbBlockSize)) {
+	if (SWAP_BE32(file->rsrcPhysicalSize) > ((UInt64)blocks * (UInt64)gScavGlobals->calculatedVCB->vcbBlockSize)) {
 		PrintError(gScavGlobals, E_PEOF, 1, "");
                 return (noErr);		/* we don't fix this, ignore the error */
 	}
-	if (file->rsrcLogicalSize > file->rsrcPhysicalSize) {
+	if (SWAP_BE32(file->rsrcLogicalSize) > SWAP_BE32(file->rsrcPhysicalSize)) {
 		PrintError(gScavGlobals, E_LEOF, 1, "");
                 return (noErr);		/* we don't fix this, ignore the error */
 	}
@@ -608,7 +608,7 @@ CheckFile_HFS(const HFSCatalogKey * key,
 	if (PtrAndHand(&file->fileID, (Handle)gScavGlobals->validFilesList, sizeof(UInt32) ) )
 		return (R_NoMem);
 #endif
-	CheckCatalogName_HFS(key->nodeName[0], &key->nodeName[1], key->parentID, false);
+	CheckCatalogName_HFS(key->nodeName[0], &key->nodeName[1], SWAP_BE32(key->parentID), false);
 
 	return (result);
 }
@@ -629,26 +629,26 @@ CheckThread_HFS(const HFSCatalogKey * ke
 	}
 
 	result = CheckCatalogName_HFS(thread->nodeName[0], &thread->nodeName[1],
-                         	  thread->parentID, true);
+                         	  SWAP_BE32(thread->parentID), true);
 	if (result != noErr) {
 		RcdError(gScavGlobals, E_ThdCN);
 		return (E_ThdCN);
 	}	
 
-	if (key->parentID < kHFSFirstUserCatalogNodeID  &&
-            key->parentID != kHFSRootParentID  &&
-            key->parentID != kHFSRootFolderID) {
+	if (SWAP_BE32(key->parentID) < kHFSFirstUserCatalogNodeID  &&
+            SWAP_BE32(key->parentID) != kHFSRootParentID  &&
+            SWAP_BE32(key->parentID) != kHFSRootFolderID) {
 		RcdError(gScavGlobals, E_InvalidID);
 		return (E_InvalidID);
 	}
 
-	if (thread->parentID == kHFSRootParentID) {
-		if (key->parentID != kHFSRootFolderID) {
+	if (SWAP_BE32(thread->parentID) == kHFSRootParentID) {
+		if (SWAP_BE32(key->parentID) != kHFSRootFolderID) {
 			RcdError(gScavGlobals, E_InvalidID);
 			return (E_InvalidID);
 		}
-	} else if (thread->parentID < kHFSFirstUserCatalogNodeID &&
-	           thread->parentID != kHFSRootFolderID) {
+	} else if (SWAP_BE32(thread->parentID) < kHFSFirstUserCatalogNodeID &&
+	           SWAP_BE32(thread->parentID) != kHFSRootFolderID) {
 		RcdError(gScavGlobals, E_InvalidID);
 		return (E_InvalidID);
 	}
@@ -682,10 +682,10 @@ CheckBSDInfo(const HFSPlusCatalogKey * k
 	Boolean reset = false;
 
 	/* skip uninitialized BSD info */
-	if (bsdInfo->fileMode == 0)
+	if (SWAP_BE16(bsdInfo->fileMode) == 0)
 		return;
 	
-	switch (bsdInfo->fileMode & FT_MASK) {
+	switch (SWAP_BE16(bsdInfo->fileMode) & FT_MASK) {
 	  case FT_DIR:
 		if (!isdir)
 			reset = true;
@@ -704,13 +704,13 @@ CheckBSDInfo(const HFSPlusCatalogKey * k
 	}
 	
 	if (reset ||
-	    ((long)bsdInfo->ownerID == kObsoleteUnknownUID) ||
-	    ((long)bsdInfo->groupID == kObsoleteUnknownUID)) {
+	    ((long)SWAP_BE32(bsdInfo->ownerID) == kObsoleteUnknownUID) ||
+	    ((long)SWAP_BE32(bsdInfo->groupID) == kObsoleteUnknownUID)) {
 		RepairOrderPtr p;
 		int n;
 		
 		if (reset) {
-			gScavGlobals->TarBlock = bsdInfo->fileMode & FT_MASK;
+			gScavGlobals->TarBlock = SWAP_BE16(bsdInfo->fileMode) & FT_MASK;
 			RcdError(gScavGlobals, E_InvalidPermissions);
 		}
 
@@ -725,17 +725,17 @@ CheckBSDInfo(const HFSPlusCatalogKey * k
 		if (reset) {
 			p->type      = E_InvalidPermissions;
 			p->correct   = 0;
-			p->incorrect = bsdInfo->fileMode;
+			p->incorrect = SWAP_BE16(bsdInfo->fileMode);
 		} else {
 			p->type      = E_InvalidUID;
 			p->correct   = kUnknownUID;
-			if ((long)bsdInfo->ownerID == kObsoleteUnknownUID)
-				p->incorrect = bsdInfo->ownerID;
+			if ((long)SWAP_BE32(bsdInfo->ownerID) == kObsoleteUnknownUID)
+				p->incorrect = SWAP_BE32(bsdInfo->ownerID);
 			else 
-				p->incorrect = bsdInfo->groupID;
+				p->incorrect = SWAP_BE32(bsdInfo->groupID);
 		}
 
-                p->parid = key->parentID;
+                p->parid = SWAP_BE32(key->parentID);
 		p->hint = 0;
 		
 		gScavGlobals->CatStat |= S_Permissions;
@@ -751,10 +751,10 @@ CheckBSDInfo(const HFSPlusCatalogKey * k
  * if repairable then log the error and create a repair order
  */
 static int
-CheckCatalogName(u_int16_t charCount, const u_int16_t *uniChars, u_int32_t parentID, Boolean thread)
+CheckCatalogName(u_int16_t charCount, const u_big_int16_t *uniChars, u_int32_t parentID, Boolean thread)
 {
 	OSErr 				result;
-	u_int16_t *			myPtr;
+	u_big_int16_t *		myPtr;
 	RepairOrderPtr 		roPtr;
 	int					myLength;
     CatalogName			newName;
@@ -769,9 +769,9 @@ CheckCatalogName(u_int16_t charCount, co
     // look for objects with illegal names of "." or "..".  We only do this for
     // file or folder catalog records (the thread records will be taken care of
     // in the repair routines).
-    if ( charCount < 3 && *uniChars == 0x2E )
+    if ( charCount < 3 && SWAP_BE16(*uniChars) == 0x2E )
     {
-        if ( charCount == 1 || (charCount == 2 && *(uniChars + 1) == 0x2E) )
+        if ( charCount == 1 || (charCount == 2 && SWAP_BE16(*(uniChars + 1)) == 0x2E) )
         {
 			PrintError( gScavGlobals, E_IllegalName, 0 );
             if ( gScavGlobals->logLevel >= kDebugLog ) {
@@ -792,21 +792,21 @@ CheckCatalogName(u_int16_t charCount, co
             //   2 byte length of new name
             //   unicode characters for new name 
             myLength = (charCount + 1) * 2; // bytes needed for old name 
-            myLength += ((newName.ustr.length + 1) * 2); // bytes needed for new name
+            myLength += ((SWAP_BE16(newName.ustr.length) + 1) * 2); // bytes needed for new name
 
             roPtr = AllocMinorRepairOrder( gScavGlobals, myLength );
             if ( roPtr == NULL ) 
                 return( noErr );
 
-            myPtr = (u_int16_t *) &roPtr->name;
-            *myPtr++ = charCount; // copy in length of old name and bump past it
+            myPtr = (u_big_int16_t *) &roPtr->name;
+            SET_SWAP_BE16(*myPtr++, charCount); // copy in length of old name and bump past it
             CopyMemory( uniChars, myPtr, (charCount * 2) ); // copy in old name
             myPtr += charCount; // bump past old name
             *myPtr++ = newName.ustr.length; // copy in length of new name and bump past it
-            CopyMemory( newName.ustr.unicode, myPtr, (newName.ustr.length * 2) ); // copy in new name
+            CopyMemory( newName.ustr.unicode, myPtr, SWAP_BE16(newName.ustr.length) * 2 ); // copy in new name
             if ( gScavGlobals->logLevel >= kDebugLog ) {
                 printf( "\treplacement name is 0x" );
-                PrintName( newName.ustr.length, (UInt8 *) &newName.ustr.unicode, true );
+                PrintName( SWAP_BE16(newName.ustr.length), (UInt8 *) &newName.ustr.unicode, true );
            }
 
  			roPtr->type = E_IllegalName;
@@ -843,21 +843,21 @@ CheckCatalogName(u_int16_t charCount, co
         //   2 byte length of new name
         //   unicode characters for new name 
         myLength = (charCount + 1) * 2; // bytes needed for old name 
-        myLength += ((newName.ustr.length + 1) * 2); // bytes needed for new name
+        myLength += (SWAP_BE16(newName.ustr.length) + 1) * 2; // bytes needed for new name
 
         roPtr = AllocMinorRepairOrder( gScavGlobals, myLength );
         if ( roPtr == NULL ) 
             return( noErr );
 
-        myPtr = (u_int16_t *) &roPtr->name;
-        *myPtr++ = charCount; // copy in length of old name and bump past it
+        myPtr = (u_big_int16_t *) &roPtr->name;
+        SET_SWAP_BE16(*myPtr++, charCount); // copy in length of old name and bump past it
         CopyMemory( uniChars, myPtr, (charCount * 2) ); // copy in old name
         myPtr += charCount; // bump past old name
         *myPtr++ = newName.ustr.length; // copy in length of new name and bump past it
-        CopyMemory( newName.ustr.unicode, myPtr, (newName.ustr.length * 2) ); // copy in new name
+        CopyMemory( newName.ustr.unicode, myPtr, SWAP_BE16(newName.ustr.length) * 2 ); // copy in new name
         if ( gScavGlobals->logLevel >= kDebugLog ) {
             printf( "\treplacement name is 0x" );
-            PrintName( newName.ustr.length, (UInt8 *) &newName.ustr.unicode, true );
+            PrintName( SWAP_BE16(newName.ustr.length), (UInt8 *) &newName.ustr.unicode, true );
         }
 
         roPtr->type = E_IllegalName;
@@ -980,9 +980,9 @@ UniqueDotName( 	SGlobPtr GPtr, 
     if ( isHFSPlus )
     {
         int		i;
-        theNewNamePtr->ustr.length = nameLen;
-        for ( i = 0; i < theNewNamePtr->ustr.length; i++ )
-            theNewNamePtr->ustr.unicode[ i ] = (u_int16_t) *(myPtr + i);
+        SET_SWAP_BE16(theNewNamePtr->ustr.length, nameLen);
+        for ( i = 0; i < SWAP_BE16(theNewNamePtr->ustr.length); i++ )
+            SET_SWAP_BE16(theNewNamePtr->ustr.unicode[ i ], (u_int16_t) *(myPtr + i));
     }
     else
     {
@@ -1003,8 +1003,8 @@ UniqueDotName( 	SGlobPtr GPtr, 
         // new name is already there, try another
         if ( isHFSPlus )
         {
-            theNewNamePtr->ustr.unicode[ nameLen ] = (u_int16_t) newChar;
-            theNewNamePtr->ustr.length = nameLen + 1;
+            SET_SWAP_BE16(theNewNamePtr->ustr.unicode[ nameLen ], (u_int16_t) newChar);
+            SET_SWAP_BE16(theNewNamePtr->ustr.length, nameLen + 1);
         }
         else
         {
@@ -1134,7 +1134,7 @@ CaptureMissingThread(UInt32 threadID, co
 	gScavGlobals->missingThreadList = mtp;
 	
 	mtp->threadID = threadID;	
-	CopyMemory(nextKey, &mtp->nextKey, nextKey->keyLength + 2);
+	CopyMemory(nextKey, &mtp->nextKey, SWAP_BE16(nextKey->keyLength) + 2);
 
 	if (gScavGlobals->RepLevel == repairLevelNoProblemsFound)
 		gScavGlobals->RepLevel = repairLevelVolumeRecoverable;
@@ -1205,17 +1205,17 @@ outFilename.
 
  */
 static Boolean 
-FixDecomps(	u_int16_t charCount, const u_int16_t *inFilename, HFSUniStr255 *outFilename ) 
+FixDecomps(	u_int16_t charCount, const u_big_int16_t *inFilename, HFSUniStr255 *outFilename ) 
 {
     // input filename: address of curr input char,
-	const u_int16_t *	inNamePtr		= inFilename;
+	const u_big_int16_t *	inNamePtr		= inFilename;
     // and of last input char.
-	const u_int16_t *	inNameLastPtr	= &inFilename[charCount - 1];	
+	const u_big_int16_t *	inNameLastPtr	= &inFilename[charCount - 1];	
     // output filename buffer: addr of next output char,
-	u_int16_t *	outNamePtr			= outFilename->unicode;	
+	u_big_int16_t *	outNamePtr			= outFilename->unicode;	
     // and of last possible output char.
-	u_int16_t *	outNameLastPtr		= &outFilename->unicode[kHFSPlusMaxFileNameChars - 1];	
-	u_int16_t *	outNameCombSeqPtr	= NULL;	// if non-NULL, start of output combining seq we are processing.
+	u_big_int16_t *	outNameLastPtr		= &outFilename->unicode[kHFSPlusMaxFileNameChars - 1];	
+	u_big_int16_t *	outNameCombSeqPtr	= NULL;	// if non-NULL, start of output combining seq we are processing.
 	u_int32_t	maxClassValueInSeq	= 0;
 	Boolean		didModifyName		= 0;
 
@@ -1226,7 +1226,7 @@ FixDecomps(	u_int16_t charCount, const u
 		u_int32_t	replDataIndex;
 		u_int32_t	currCharClass;
 
-		shiftUniChar = *inNamePtr + kShiftUniCharOffset;
+		shiftUniChar = SWAP_BE16(*inNamePtr) + kShiftUniCharOffset;
 		if ( shiftUniChar >= kShiftUniCharLimit )
 			goto CopyBaseChar;
 		rangeIndex = classAndReplIndex[shiftUniChar >> kLoFieldBitSize];
@@ -1252,7 +1252,7 @@ FixDecomps(	u_int16_t charCount, const u
 				// the next 3 cases can have a first char or replacement char with nonzero combining class
 				case kIfNextOneMatchesReplaceAllWithOne:
 				case kIfNextOneMatchesReplaceAllWithTwo:
-					if (inNamePtr + 1 <= inNameLastPtr && *(inNamePtr + 1) == *replDataPtr++) {
+					if (inNamePtr + 1 <= inNameLastPtr && SWAP_BE16(*(inNamePtr + 1)) == *replDataPtr++) {
 						inNamePtr += 2;
 						copyCount = (action == kIfNextOneMatchesReplaceAllWithOne)? 1: 2;
 					} else {
@@ -1262,8 +1262,8 @@ FixDecomps(	u_int16_t charCount, const u
 					break;
 				case kIfNextTwoMatchReplaceAllWithOne:
 					if ( inNamePtr + 2 <= inNameLastPtr && 
-                         *(inNamePtr + 1) == *replDataPtr++ && 
-                         *(inNamePtr + 2) == *replDataPtr++) 
+                         SWAP_BE16(*(inNamePtr + 1)) == *replDataPtr++ && 
+                         SWAP_BE16(*(inNamePtr + 2)) == *replDataPtr++) 
                     {
 						inNamePtr += 3;
 						copyCount = 1;
@@ -1293,29 +1293,29 @@ FixDecomps(	u_int16_t charCount, const u
 				// comments; see them for info.
 				if ( currCharClass == 0 ) {
 					outNameCombSeqPtr = NULL;
-					*outNamePtr++ = *replDataPtr++;
+					SET_SWAP_BE16(*outNamePtr++, *replDataPtr++);
 				} else if ( outNameCombSeqPtr == NULL ) {
 					outNameCombSeqPtr = outNamePtr;
 					maxClassValueInSeq = currCharClass;
-					*outNamePtr++ = *replDataPtr++;
+					SET_SWAP_BE16(*outNamePtr++, *replDataPtr++);
 				} else if ( currCharClass >= maxClassValueInSeq ) {
 					// Sequence is already in correct order with current char,
 					// just update maxClassValueInSeq
 					maxClassValueInSeq = currCharClass;
-					*outNamePtr++ = *replDataPtr++;
+					SET_SWAP_BE16(*outNamePtr++, *replDataPtr++);
 				} else if ( outNamePtr - outNameCombSeqPtr == 1) {
 					// Here we know we need to reorder.
 					// If the sequence is two chars, just interchange them
 					*outNamePtr++ = *outNameCombSeqPtr;
-					*outNameCombSeqPtr = *replDataPtr++;
+					SET_SWAP_BE16(*outNameCombSeqPtr, *replDataPtr++);
 				} else {
 					// General reordering case for three or more chars.
-					u_int16_t *	outNameCombCharPtr;
+					u_big_int16_t *	outNameCombCharPtr;
 					u_int32_t	combCharClass;
 					
 					outNameCombCharPtr = outNamePtr++;
 					while (outNameCombCharPtr > outNameCombSeqPtr) {
-						shiftUniChar = *(outNameCombCharPtr - 1) + kShiftUniCharOffset;
+						shiftUniChar = SWAP_BE16(*(outNameCombCharPtr - 1)) + kShiftUniCharOffset;
 						rangeIndex = classAndReplIndex[shiftUniChar >> kLoFieldBitSize];
 						shiftUniCharLo = shiftUniChar & kLoFieldMask;
 						combCharClass = combClassRanges[rangeIndex][shiftUniCharLo];
@@ -1324,7 +1324,7 @@ FixDecomps(	u_int16_t charCount, const u
 						*outNameCombCharPtr = *(outNameCombCharPtr - 1);
 						outNameCombCharPtr--;
 					}
-					*outNameCombCharPtr = *replDataPtr++;
+					SET_SWAP_BE16(*outNameCombCharPtr, *replDataPtr++);
 				}
 			}
 			didModifyName = 1;
@@ -1378,12 +1378,12 @@ FixDecomps(	u_int16_t charCount, const u
 			// combining marks is rare enough that it wouldn't be worth the overhead.
 			// At least we don't have to recheck shiftUniChar < kShiftUniCharLimit,
 			// rangeIndex != 0, etc.)
-			u_int16_t *	outNameCombCharPtr;
+			u_big_int16_t *	outNameCombCharPtr;
 			u_int32_t	combCharClass;
 
 			outNameCombCharPtr = outNamePtr++;
 			while (outNameCombCharPtr > outNameCombSeqPtr) {
-				shiftUniChar = *(outNameCombCharPtr - 1) + kShiftUniCharOffset;
+				shiftUniChar = SWAP_BE16(*(outNameCombCharPtr - 1)) + kShiftUniCharOffset;
 				rangeIndex = classAndReplIndex[shiftUniChar >> kLoFieldBitSize];
 				shiftUniCharLo = shiftUniChar & kLoFieldMask;
 				combCharClass = combClassRanges[rangeIndex][shiftUniCharLo];
@@ -1410,7 +1410,7 @@ FixDecomps(	u_int16_t charCount, const u
 	} /* end of while( inNamePtr <= inNameLastPtr ) */
 
 	if (didModifyName) {
-		outFilename->length = outNamePtr - outFilename->unicode;
+		SET_SWAP_BE16(outFilename->length, outNamePtr - outFilename->unicode);
 	}
 	return didModifyName;
     
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/HardLinkCheck.c diskdev_cmds/fsck_hfs.tproj/dfalib/HardLinkCheck.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/HardLinkCheck.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/HardLinkCheck.c	2003-09-01 16:03:36.000000000 +0200
@@ -40,17 +40,31 @@ struct HardLinkInfo {
 	struct IndirectLinkInfo *linkInfo;
 };
 
+#if defined(__LITTLE_ENDIAN__)
+#if 0
+#define _U(v)	{ .u16 = ((((v) >> 8) & 0xff) | (((v) & 0xff) << 8)) }
+#define _U2(v)	{ .u32 = ((((v) & 0xff000000) >> 24) | (((v) & 0xff0000) >> 8) | \
+						 (((v) & 0xff00) << 8) | (((v) & 0xff) << 24)) }
+#else
+#define _U(v)	((((v) >> 8) & 0xff) | (((v) & 0xff) << 8))
+#define _U2(v)	((((v) & 0xff000000) >> 24) | (((v) & 0xff0000) >> 8) | \
+				 (((v) & 0xff00) << 8) | (((v) & 0xff) << 24))
+#endif
+#elif defined(__BIG_ENDIAN__)
+#define _U(v)	(v)
+#define _U2(v)	(v)
+#endif
 
 HFSPlusCatalogKey gMetaDataDirKey = {
-	48,		/* key length */
-	2,		/* parent directory ID */
+	_U(48),		/* key length */
+	_U2(2),		/* parent directory ID */
 	{
-		21,	/* number of unicode characters */
+		_U(21),	/* number of unicode characters */
 		{
-			'\0','\0','\0','\0',
-			'H','F','S','+',' ',
-			'P','r','i','v','a','t','e',' ',
-			'D','a','t','a'
+			_U('\0'),_U('\0'),_U('\0'),_U('\0'),
+			_U('H'),_U('F'),_U('S'),_U('+'),_U(' '),
+			_U('P'),_U('r'),_U('i'),_U('v'),_U('a'),_U('t'),_U('e'),_U(' '),
+			_U('D'),_U('a'),_U('t'),_U('a')
 		}
 	}
 };
@@ -86,9 +100,9 @@ HardLinkCheckBegin(SGlobPtr gp, void** c
 	UInt32 folderID;
 	int entries, slots;
 
-	if (GetPrivateDir(gp, &rec) == 0 && rec.hfsPlusFolder.valence != 0) {
-		entries = rec.hfsPlusFolder.valence + 10;
-		folderID = rec.hfsPlusFolder.folderID;
+	if (GetPrivateDir(gp, &rec) == 0 && SWAP_BE32(rec.hfsPlusFolder.valence) != 0) {
+		entries = SWAP_BE32(rec.hfsPlusFolder.valence) + 10;
+		folderID = SWAP_BE32(rec.hfsPlusFolder.folderID);
 	} else {
 		entries = 100;
 		folderID = 0;
@@ -238,13 +252,13 @@ CheckHardLinks(void *cookie)
 	for (;;) {
 		result = BTIterateRecord(fcb, kBTreeNextRecord, &iterator,
 					&btrec, &reclen);
-		if (result || keyp->parentID != folderID)
+		if (result || SWAP_BE32(keyp->parentID) != folderID)
 			break;
-		if (rec.recordType != kHFSPlusFileRecord)
+		if (SWAP_BE16(rec.recordType) != kHFSPlusFileRecord)
 			continue;
 
 		(void) utf_encodestr(keyp->nodeName.unicode,
-					keyp->nodeName.length * 2,
+					SWAP_BE16(keyp->nodeName.length) * 2,
 					filename, &len);
 		filename[len] = '\0';
 		
@@ -259,7 +273,7 @@ CheckHardLinks(void *cookie)
 			continue;
 		
 		linkID = atol(&filename[prefixlen]);
-		linkCount = rec.hfsPlusFile.bsdInfo.special.linkCount;
+		linkCount = SWAP_BE32(rec.hfsPlusFile.bsdInfo.special.linkCount);
 		linkInfo = hash_search(linkID, info->linkSlots, info->slotsUsed, info->linkInfo);
 		if (linkInfo) {
 			if (linkCount != linkInfo->linkCount)
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/Makefile.lnx diskdev_cmds/fsck_hfs.tproj/dfalib/Makefile.lnx
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/Makefile.lnx	1970-01-01 01:00:00.000000000 +0100
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/Makefile.lnx	2003-05-05 13:41:20.000000000 +0200
@@ -0,0 +1,15 @@
+CFILES = BlockCache.c\
+         BTree.c BTreeAllocate.c BTreeMiscOps.c \
+         BTreeNodeOps.c BTreeScanner.c BTreeTreeOps.c\
+         CatalogCheck.c HardLinkCheck.c\
+         SBTree.c SControl.c SVerify1.c SVerify2.c\
+         SRepair.c SRebuildCatalogBTree.c\
+         SUtils.c SKeyCompare.c SDevice.c SExtents.c SAllocate.c\
+         SCatalog.c SStubs.c VolumeBitmapCheck.c
+OFILES = $(CFILES:.c=.o)
+
+libdfa.a: $(OFILES)
+	ar rc $@ $?
+
+clean:
+	$(RM) $(OFILES) libdfa.a
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/SAllocate.c diskdev_cmds/fsck_hfs.tproj/dfalib/SAllocate.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/SAllocate.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/SAllocate.c	2003-06-30 11:32:58.000000000 +0200
@@ -504,8 +504,8 @@ static OSErr BlockAllocateAny(
 	UInt32			*actualNumBlocks)
 {
 	OSErr			err;
-	register UInt32	block;			//	current block number
-	register UInt32	currentWord;	//	Pointer to current word within bitmap block
+	register UInt32	block = 0;		//	current block number
+	register UInt32	currentWord;		//	Pointer to current word within bitmap block
 	register UInt32	bitMask;		//	Word with given bits already set (ready to OR in)
 	register UInt32	wordsLeft;		//	Number of words left in this bitmap block
 	UInt32 *buffer;
@@ -712,8 +712,8 @@ static OSErr BlockMarkAllocated(
 		}
 #if DEBUG_BUILD
 		if ((*currentWord & bitMask) != 0) {
-			DebugStr("\pFATAL: blocks already allocated!");
-			err = fsDSIntErr;
+			DebugStr("FATAL: blocks already allocated!");
+			//err = fsDSIntErr;
 			goto Exit;
 		}
 #endif
@@ -749,8 +749,8 @@ static OSErr BlockMarkAllocated(
 		}
 #if DEBUG_BUILD
 		if (*currentWord != 0) {
-			DebugStr("\pFATAL: blocks already allocated!");
-			err = fsDSIntErr;
+			DebugStr("FATAL: blocks already allocated!");
+			//err = fsDSIntErr;
 			goto Exit;
 		}
 #endif
@@ -786,8 +786,8 @@ static OSErr BlockMarkAllocated(
 		}
 #if DEBUG_BUILD
 		if ((*currentWord & bitMask) != 0) {
-			DebugStr("\pFATAL: blocks already allocated!");
-			err = fsDSIntErr;
+			DebugStr("FATAL: blocks already allocated!");
+			//err = fsDSIntErr;
 			goto Exit;
 		}
 #endif
@@ -871,8 +871,8 @@ static OSErr BlockMarkFree(
 		}
 #if DEBUG_BUILD
 		if ((*currentWord & bitMask) != bitMask) {
-			DebugStr("\pFATAL: blocks not allocated!");
-			err = fsDSIntErr;
+			DebugStr("FATAL: blocks not allocated!");
+			//err = fsDSIntErr;
 			goto Exit;
 		}
 #endif
@@ -907,8 +907,8 @@ static OSErr BlockMarkFree(
 		}
 #if DEBUG_BUILD
 		if (*currentWord != kAllBitsSetInWord) {
-			DebugStr("\pFATAL: blocks not allocated!");
-			err = fsDSIntErr;
+			DebugStr("FATAL: blocks not allocated!");
+			//err = fsDSIntErr;
 			goto Exit;
 		}
 #endif
@@ -944,8 +944,8 @@ static OSErr BlockMarkFree(
 		}
 #if DEBUG_BUILD
 		if ((*currentWord & bitMask) != bitMask) {
-			DebugStr("\pFATAL: blocks not allocated!");
-			err = fsDSIntErr;
+			DebugStr("FATAL: blocks not allocated!");
+			//err = fsDSIntErr;
 			goto Exit;
 		}
 #endif
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/SBTree.c diskdev_cmds/fsck_hfs.tproj/dfalib/SBTree.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/SBTree.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/SBTree.c	2003-05-05 12:31:05.000000000 +0200
@@ -93,7 +93,7 @@ OSErr SearchBTreeRecord(SFCB *fcb, const
 			CopyMemory(&resultIterator->key, foundKey, CalcKeySize(btcb, &resultIterator->key));	//ее warning, this could overflow user's buffer!!!
 
 		if ( DEBUG_BUILD && !ValidHFSRecord(data, btcb, *dataSize) )
-			DebugStr("\pSearchBTreeRecord: bad record?");
+			DebugStr("SearchBTreeRecord: bad record?");
 	}
 
 ErrorExit:
@@ -190,7 +190,7 @@ OSErr GetBTreeRecord(SFCB *fcb, SInt16 s
 		CopyMemory(&iterator->key, key, CalcKeySize(btcb, &iterator->key));	//ее warning, this could overflow user's buffer!!!
 		
 		if ( DEBUG_BUILD && !ValidHFSRecord(data, btcb, *dataSize) )
-			DebugStr("\pGetBTreeRecord: bad record?");
+			DebugStr("GetBTreeRecord: bad record?");
 
 	}
 	
@@ -222,7 +222,7 @@ OSErr InsertBTreeRecord(SFCB *fcb, const
 	CopyMemory(key, &iterator.key, CalcKeySize(btcb, (BTreeKey *) key));	//ее should we range check against maxkeylen?
 
 	if ( DEBUG_BUILD && !ValidHFSRecord(data, btcb, dataSize) )
-		DebugStr("\pInsertBTreeRecord: bad record?");
+		DebugStr("InsertBTreeRecord: bad record?");
 
 	result = BTInsertRecord( fcb, &iterator, &btRecord, dataSize );
 
@@ -284,7 +284,7 @@ OSErr ReplaceBTreeRecord(SFCB *fcb, cons
 	CopyMemory(key, &iterator.key, CalcKeySize(btcb, (BTreeKey *) key));		//ее should we range check against maxkeylen?
 
 	if ( DEBUG_BUILD && !ValidHFSRecord(newData, btcb, dataSize) )
-		DebugStr("\pReplaceBTreeRecord: bad record?");
+		DebugStr("ReplaceBTreeRecord: bad record?");
 
 	result = BTReplaceRecord( fcb, &iterator, &btRecord, dataSize );
 
@@ -301,8 +301,9 @@ ErrorExit:
 OSStatus
 SetEndOfForkProc ( SFCB *filePtr, FSSize minEOF, FSSize maxEOF )
 {
+#if __APPLE__
 #pragma unused (maxEOF)
-
+#endif
 	OSStatus	result;
 	UInt32		actualSectorsAdded;
 	UInt64		bytesToAdd;
@@ -321,7 +322,7 @@ SetEndOfForkProc ( SFCB *filePtr, FSSize
 	else
 	{
 		if ( DEBUG_BUILD )
-			DebugStr("\pSetEndOfForkProc: minEOF is smaller than current size!");
+			DebugStr("SetEndOfForkProc: minEOF is smaller than current size!");
 		return -1;
 	}
 
@@ -347,7 +348,7 @@ SetEndOfForkProc ( SFCB *filePtr, FSSize
 	//	Make sure we got at least as much space as we needed
 	//
 	if (filePtr->fcbLogicalSize < minEOF) {
-		Panic("\pSetEndOfForkProc: disk too full to extend B-tree file");
+		Panic("SetEndOfForkProc: disk too full to extend B-tree file");
 		return dskFulErr;
 	}
 	
@@ -412,14 +413,14 @@ static OSErr CheckBTreeKey(const BTreeKe
 	UInt16	keyLen;
 	
 	if ( btcb->attributes & kBTBigKeysMask )
-		keyLen = key->length16;
+		keyLen = SWAP_BE16(key->length16);
 	else
 		keyLen = key->length8;
 
 	if ( (keyLen < 6) || (keyLen > btcb->maxKeyLength) )
 	{
 		if ( DEBUG_BUILD )
-			DebugStr("\pCheckBTreeKey: bad key length!");
+			DebugStr("CheckBTreeKey: bad key length!");
 		return fsBTInvalidKeyLengthErr;
 	}
 	
@@ -443,7 +444,7 @@ static Boolean ValidHFSRecord(const void
 	{
 		HFSPlusAttrRecord	*attributeRecord = (HFSPlusAttrRecord *) record;
 		
-		switch (attributeRecord->recordType) {
+		switch (SWAP_BE32(attributeRecord->recordType)) {
 			case kHFSPlusAttrInlineData:
 				break;
 			
@@ -458,18 +459,18 @@ static Boolean ValidHFSRecord(const void
 	{
 		CatalogRecord *catalogRecord = (CatalogRecord*) record;
 
-		switch(catalogRecord->recordType)
+		switch(SWAP_BE16(catalogRecord->recordType))
 		{
 			case kHFSFolderRecord:
 			{
 				if ( recordSize != sizeof(HFSCatalogFolder) )
 					return false;
-				if ( catalogRecord->hfsFolder.flags != 0 )
+				if ( SWAP_BE16(catalogRecord->hfsFolder.flags) != 0 )
 					return false;
-				if ( catalogRecord->hfsFolder.valence > 0x7FFF )
+				if ( SWAP_BE16(catalogRecord->hfsFolder.valence) > 0x7FFF )
 					return false;
 					
-				cNodeID = catalogRecord->hfsFolder.folderID;
+				cNodeID = SWAP_BE32(catalogRecord->hfsFolder.folderID);
 	
 				if ( (cNodeID == 0) || (cNodeID < 16 && cNodeID > 2) )
 					return false;
@@ -480,10 +481,10 @@ static Boolean ValidHFSRecord(const void
 			{
 				if ( recordSize != sizeof(HFSPlusCatalogFolder) )
 					return false;
-				if ( catalogRecord->hfsPlusFolder.flags != 0 )
+				if ( SWAP_BE16(catalogRecord->hfsPlusFolder.flags) != 0 )
 					return false;
 					
-				cNodeID = catalogRecord->hfsPlusFolder.folderID;
+				cNodeID = SWAP_BE32(catalogRecord->hfsPlusFolder.folderID);
 	
 				if ( (cNodeID == 0) || (cNodeID < 16 && cNodeID > 2) )
 					return false;
@@ -501,20 +502,20 @@ static Boolean ValidHFSRecord(const void
 				if ( (catalogRecord->hfsFile.flags & ~(0x83)) != 0 )
 					return false;
 					
-				cNodeID = catalogRecord->hfsFile.fileID;
+				cNodeID = SWAP_BE32(catalogRecord->hfsFile.fileID);
 				
 				if ( cNodeID < 16 )
 					return false;
 		
 				// make sure 0 ▓ LEOF ▓ PEOF for both forks
 				
-				if ( catalogRecord->hfsFile.dataLogicalSize < 0 )
+				if ( SWAP_BE32(catalogRecord->hfsFile.dataLogicalSize) < 0 )
 					return false;
-				if ( catalogRecord->hfsFile.dataPhysicalSize < catalogRecord->hfsFile.dataLogicalSize )
+				if ( SWAP_BE32(catalogRecord->hfsFile.dataPhysicalSize) < SWAP_BE32(catalogRecord->hfsFile.dataLogicalSize) )
 					return false;
-				if ( catalogRecord->hfsFile.rsrcLogicalSize < 0 )
+				if ( SWAP_BE32(catalogRecord->hfsFile.rsrcLogicalSize) < 0 )
 					return false;
-				if ( catalogRecord->hfsFile.rsrcPhysicalSize < catalogRecord->hfsFile.rsrcLogicalSize )
+				if ( SWAP_BE32(catalogRecord->hfsFile.rsrcPhysicalSize) < SWAP_BE32(catalogRecord->hfsFile.rsrcLogicalSize) )
 					return false;
 		
 				dataExtent = (HFSExtentDescriptor*) &catalogRecord->hfsFile.dataExtents;
@@ -522,9 +523,9 @@ static Boolean ValidHFSRecord(const void
 	
 				for (i = 0; i < kHFSExtentDensity; ++i)
 				{
-					if ( (dataExtent[i].blockCount > 0) && (dataExtent[i].startBlock == 0) )
+					if ( (SWAP_BE16(dataExtent[i].blockCount) > 0) && (SWAP_BE16(dataExtent[i].startBlock) == 0) )
 						return false;
-					if ( (rsrcExtent[i].blockCount > 0) && (rsrcExtent[i].startBlock == 0) )
+					if ( (SWAP_BE16(rsrcExtent[i].blockCount) > 0) && (SWAP_BE16(rsrcExtent[i].startBlock) == 0) )
 						return false;
 				}
 			}
@@ -538,10 +539,10 @@ static Boolean ValidHFSRecord(const void
 				
 				if ( recordSize != sizeof(HFSPlusCatalogFile) )
 					return false;								
-				if ( (catalogRecord->hfsPlusFile.flags & ~(0x83)) != 0 )
+				if ( (SWAP_BE16(catalogRecord->hfsPlusFile.flags) & ~(0x83)) != 0 )
 					return false;
 					
-				cNodeID = catalogRecord->hfsPlusFile.fileID;
+				cNodeID = SWAP_BE32(catalogRecord->hfsPlusFile.fileID);
 				
 				if ( cNodeID < 16 )
 					return false;
@@ -553,9 +554,9 @@ static Boolean ValidHFSRecord(const void
 	
 				for (i = 0; i < kHFSPlusExtentDensity; ++i)
 				{
-					if ( (dataExtent[i].blockCount > 0) && (dataExtent[i].startBlock == 0) )
+					if ( (SWAP_BE32(dataExtent[i].blockCount) > 0) && (SWAP_BE32(dataExtent[i].startBlock) == 0) )
 						return false;
-					if ( (rsrcExtent[i].blockCount > 0) && (rsrcExtent[i].startBlock == 0) )
+					if ( (SWAP_BE32(rsrcExtent[i].blockCount) > 0) && (SWAP_BE32(rsrcExtent[i].startBlock) == 0) )
 						return false;
 				}
 			}
@@ -567,7 +568,7 @@ static Boolean ValidHFSRecord(const void
 				if ( recordSize != sizeof(HFSCatalogThread) )
 					return false;
 	
-				cNodeID = catalogRecord->hfsThread.parentID;
+				cNodeID = SWAP_BE32(catalogRecord->hfsThread.parentID);
 				if ( (cNodeID == 0) || (cNodeID < 16 && cNodeID > 2) )
 					return false;
 							
@@ -583,12 +584,12 @@ static Boolean ValidHFSRecord(const void
 				if ( recordSize > sizeof(HFSPlusCatalogThread) || recordSize < (sizeof(HFSPlusCatalogThread) - sizeof(HFSUniStr255)))
 					return false;
 	
-				cNodeID = catalogRecord->hfsPlusThread.parentID;
+				cNodeID = SWAP_BE32(catalogRecord->hfsPlusThread.parentID);
 				if ( (cNodeID == 0) || (cNodeID < 16 && cNodeID > 2) )
 					return false;
 							
-				if ( (catalogRecord->hfsPlusThread.nodeName.length == 0) ||
-					 (catalogRecord->hfsPlusThread.nodeName.length > 255) )
+				if ( (SWAP_BE16(catalogRecord->hfsPlusThread.nodeName.length) == 0) ||
+					 (SWAP_BE16(catalogRecord->hfsPlusThread.nodeName.length) > 255) )
 					return false;
 			}
 			break;
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/SCatalog.c diskdev_cmds/fsck_hfs.tproj/dfalib/SCatalog.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/SCatalog.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/SCatalog.c	2003-05-05 12:31:17.000000000 +0200
@@ -60,17 +60,17 @@ OSErr LocateCatalogNode(SFCB *fcb, BTree
 	keyp = (CatalogKey*)&iterator->key;
 
 	/* if we got a thread record, then go look up real record */
-	switch (recp->recordType) {
+	switch (SWAP_BE16(recp->recordType)) {
 	case kHFSFileThreadRecord:
 	case kHFSFolderThreadRecord:
-		threadpid = recp->hfsThread.parentID;
+		threadpid = SWAP_BE32(recp->hfsThread.parentID);
 		namep = (CatalogName *) &recp->hfsThread.nodeName;
 		isHFSPlus = false;
 		break;
 
 	case kHFSPlusFileThreadRecord:
 	case kHFSPlusFolderThreadRecord:
-		threadpid = recp->hfsPlusThread.parentID;
+		threadpid = SWAP_BE32(recp->hfsPlusThread.parentID);
 		namep = (CatalogName *) &recp->hfsPlusThread.nodeName;
 		isHFSPlus = true;
 		break;
@@ -115,13 +115,13 @@ UpdateFolderCount(SVCB *vcb, HFSCatalogN
 		UInt32		timeStamp;
 
 		timeStamp = GetTimeUTC();
-		tempData.hfsPlusFolder.valence += valenceDelta;		// adjust valence
-		tempData.hfsPlusFolder.contentModDate = timeStamp;	// set date/time last modified
-		folderID = tempData.hfsPlusFolder.folderID;
+		SET_SWAP_BE32(tempData.hfsPlusFolder.valence, SWAP_BE32(tempData.hfsPlusFolder.valence) + valenceDelta);		// adjust valence
+		SET_SWAP_BE32(tempData.hfsPlusFolder.contentModDate, timeStamp);	// set date/time last modified
+		folderID = SWAP_BE32(tempData.hfsPlusFolder.folderID);
 	} else /* kHFSSigWord */ {
-		tempData.hfsFolder.valence += valenceDelta;				// adjust valence
-		tempData.hfsFolder.modifyDate = GetTimeLocal(true);		// set date/time last modified
-		folderID = tempData.hfsFolder.folderID;
+		SET_SWAP_BE16(tempData.hfsFolder.valence, SWAP_BE16(tempData.hfsFolder.valence) + valenceDelta);				// adjust valence
+		SET_SWAP_BE32(tempData.hfsFolder.modifyDate, GetTimeLocal(true));		// set date/time last modified
+		folderID = SWAP_BE32(tempData.hfsFolder.folderID);
 	}
 
 	result = BTReplaceRecord(vcb->vcbCatalogFile, &btIterator, &btRecord, reclen);
@@ -174,32 +174,32 @@ DeleteCatalogNode(SVCB *vcb, UInt32 pid,
 	ReturnIfError(result);
 
 	/* establish real parent cnid  and cnode type */
-	nodeParentID = isHFSPlus ? keyp->hfsPlus.parentID : keyp->hfs.parentID;
-	nodeType = rec.recordType;
+	nodeParentID = isHFSPlus ? SWAP_BE32(keyp->hfsPlus.parentID) : SWAP_BE32(keyp->hfs.parentID);
+	nodeType = SWAP_BE16(rec.recordType);
 	nodeID = 0;
 
 	switch (nodeType) {
 	case kHFSFolderRecord:
-		if (rec.hfsFolder.valence != 0)
+		if (SWAP_BE16(rec.hfsFolder.valence) != 0)
 			return cmNotEmpty;
 		
-		nodeID = rec.hfsFolder.folderID;
+		nodeID = SWAP_BE32(rec.hfsFolder.folderID);
 		break;
 
 	case kHFSPlusFolderRecord:
-		if (rec.hfsPlusFolder.valence != 0)
+		if (SWAP_BE32(rec.hfsPlusFolder.valence) != 0)
 			return cmNotEmpty;
 		
-		nodeID = rec.hfsPlusFolder.folderID;
+		nodeID = SWAP_BE32(rec.hfsPlusFolder.folderID);
 		break;
 
 	case kHFSFileRecord:
 		if (rec.hfsFile.flags & kHFSThreadExistsMask)
-			nodeID = rec.hfsFile.fileID;
+			nodeID = SWAP_BE32(rec.hfsFile.fileID);
 		break;
 
 	case kHFSPlusFileRecord:
-		nodeID = rec.hfsPlusFile.fileID;
+		nodeID = SWAP_BE32(rec.hfsPlusFile.fileID);
 		break;
 
 	default:
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/SControl.c diskdev_cmds/fsck_hfs.tproj/dfalib/SControl.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/SControl.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/SControl.c	2003-05-05 12:31:20.000000000 +0200
@@ -294,11 +294,13 @@ void ScavCtrl( SGlobPtr GPtr, UInt32 Sca
 	switch ( ScavOp )
 	{
 		case scavInitialize:								//	INITIAL VOLUME CHECK
-			if ( result = ScavSetUp( GPtr ) )			//	set up BEFORE CheckForStop
+			result = ScavSetUp( GPtr );					//	set up BEFORE CheckForStop
+			if ( result )
 				break;
 			if ( IsBlueBoxSharedDrive( GPtr->DrvPtr ) )
 				break;
-			if ( result = CheckForStop( GPtr ) )		//	in order to initialize wrCnt
+			result = CheckForStop( GPtr );				//	in order to initialize wrCnt
+			if ( result )
 				break;
 			
 			if (GPtr->chkLevel == kNeverCheck || GPtr->chkLevel == kDirtyCheck) {
@@ -349,20 +351,25 @@ void ScavCtrl( SGlobPtr GPtr, UInt32 Sca
 
 			if ( IsBlueBoxSharedDrive( GPtr->DrvPtr ) )
 				break;
-			if ( result = CheckForStop( GPtr ) )
+			result = CheckForStop( GPtr );
+			if ( result )
 				break;
 
 #if SHOW_ELAPSED_TIMES
 			gettimeofday( &myStartTime, &zone );
 #endif
 
-			if ( result = CreateExtentsBTreeControlBlock( GPtr ) )	//	Create the calculated BTree structures
+			result = CreateExtentsBTreeControlBlock( GPtr );		//	Create the calculated BTree structures
+			if ( result )
 				break;
-			if ( result = CreateCatalogBTreeControlBlock( GPtr ) )
+			result = CreateCatalogBTreeControlBlock( GPtr );
+			if ( result )
 				break;
-			if ( result = CreateAttributesBTreeControlBlock( GPtr ) )
+			result = CreateAttributesBTreeControlBlock( GPtr );
+			if ( result )
 				break;
-			if ( result = CreateExtendedAllocationsFCB( GPtr ) )
+			result = CreateExtendedAllocationsFCB( GPtr );
+			if ( result )
 				break;
 
 #if SHOW_ELAPSED_TIMES
@@ -377,7 +384,8 @@ void ScavCtrl( SGlobPtr GPtr, UInt32 Sca
 			CalculateItemCount( GPtr, &GPtr->itemsToProcess, &GPtr->onePercent );
 			GPtr->itemsProcessed += GPtr->onePercent;	// We do this 4 times as set up in CalculateItemCount() to smooth the scroll
 			
-			if ( result = VLockedChk( GPtr ) )
+			result = VLockedChk( GPtr );
+			if ( result )
 				break;
 
 			GPtr->itemsProcessed += GPtr->onePercent;	// We do this 4 times as set up in CalculateItemCount() to smooth the scroll
@@ -389,7 +397,8 @@ void ScavCtrl( SGlobPtr GPtr, UInt32 Sca
 			gettimeofday( &myStartTime, &zone );
 #endif
 				
-			if (result = ExtBTChk(GPtr))
+			result = ExtBTChk(GPtr);
+			if (result)
 				break;
 
 #if SHOW_ELAPSED_TIMES
@@ -400,14 +409,17 @@ void ScavCtrl( SGlobPtr GPtr, UInt32 Sca
 				myElapsedTime.tv_sec, myElapsedTime.tv_usec );
 #endif
 				
-			if (result = CheckForStop(GPtr))
+			result = CheckForStop(GPtr);
+			if (result)
 				break;
 			
 			GPtr->itemsProcessed += GPtr->onePercent;	// We do this 4 times as set up in CalculateItemCount() to smooth the scroll
 
-			if (result = ExtFlChk(GPtr))
+			result = ExtFlChk(GPtr);
+			if (result)
 				break;
-			if (result = CheckForStop(GPtr))
+			result = CheckForStop(GPtr);
+			if (result)
 				break;
 			
 			GPtr->itemsProcessed += GPtr->onePercent;	// We do this 4 times as set up in CalculateItemCount() to smooth the scroll
@@ -430,7 +442,8 @@ void ScavCtrl( SGlobPtr GPtr, UInt32 Sca
 				break;
 			}
 			
-			if (result = CheckCatalogBTree(GPtr))
+			result = CheckCatalogBTree(GPtr);
+			if (result)
 				break;
 
 #if SHOW_ELAPSED_TIMES
@@ -441,7 +454,8 @@ void ScavCtrl( SGlobPtr GPtr, UInt32 Sca
 				myElapsedTime.tv_sec, myElapsedTime.tv_usec );
 #endif
 
-			if (result = CheckForStop(GPtr))
+			result = CheckForStop(GPtr);
+			if (result)
 				break;
 			if ( ! IsWrapperVolume( GPtr->volumeType, GPtr->inputFlags ) )
 				WriteMsg( GPtr, M_CatHChk, kStatusMessage );
@@ -450,7 +464,8 @@ void ScavCtrl( SGlobPtr GPtr, UInt32 Sca
 			gettimeofday( &myStartTime, &zone );
 #endif
 				
-			if (result = CatHChk(GPtr))
+			result = CatHChk(GPtr);
+			if (result)
 				break;
 
 #if SHOW_ELAPSED_TIMES
@@ -461,12 +476,15 @@ void ScavCtrl( SGlobPtr GPtr, UInt32 Sca
 				myElapsedTime.tv_sec, myElapsedTime.tv_usec );
 #endif
 
-			if (result = CheckForStop(GPtr))
+			result = CheckForStop(GPtr);
+			if (result)
 				break;
 			
-			if (result = AttrBTChk(GPtr))
+			result = AttrBTChk(GPtr);
+			if (result)
 				break;
-			if (result = CheckForStop(GPtr))
+			result = CheckForStop(GPtr);
+			if (result)
 				break;
 
 			if ( ! IsWrapperVolume( GPtr->volumeType, GPtr->inputFlags ) )
@@ -476,7 +494,8 @@ void ScavCtrl( SGlobPtr GPtr, UInt32 Sca
 			gettimeofday( &myStartTime, &zone );
 #endif
 				
-			if (result = CheckVolumeBitMap(GPtr, false))
+			result = CheckVolumeBitMap(GPtr, false);
+			if (result)
 				break;
 
 #if SHOW_ELAPSED_TIMES
@@ -487,7 +506,8 @@ void ScavCtrl( SGlobPtr GPtr, UInt32 Sca
 				myElapsedTime.tv_sec, myElapsedTime.tv_usec );
 #endif 
 
-			if (result = CheckForStop(GPtr))
+			result = CheckForStop(GPtr);
+			if (result)
 				break;
 
 			if ( ! IsWrapperVolume( GPtr->volumeType, GPtr->inputFlags ) )
@@ -497,7 +517,8 @@ void ScavCtrl( SGlobPtr GPtr, UInt32 Sca
 			gettimeofday( &myStartTime, &zone );
 #endif
 				
-			if (result = VInfoChk(GPtr))
+			result = VInfoChk(GPtr);
+			if (result)
 				break;
 
 #if SHOW_ELAPSED_TIMES
@@ -543,7 +564,8 @@ void ScavCtrl( SGlobPtr GPtr, UInt32 Sca
 		case scavRepair:									//	REPAIR
 			if ( IsBlueBoxSharedDrive( GPtr->DrvPtr ) )
 				break;
-			if ( result = CheckForStop(GPtr) )
+			result = CheckForStop(GPtr);
+			if ( result )
 				break;
 			if ( GPtr->CBTStat & S_RebuildBTree )
 				WriteMsg( GPtr, M_RebuildingCatalogBTree, kTitleMessage );
@@ -696,7 +718,7 @@ static int ScavSetUp( SGlob *GPtr)
 {
 	OSErr  err;
 	SVCB * vcb;
-#if !BSD
+#if !__unix__
 	DrvQEl	*drvP;
 	short	ioRefNum;
 #endif
@@ -749,7 +771,7 @@ static int ScavSetUp( SGlob *GPtr)
 	//
 	//	Set up Real structures
 	//
-#if !BSD 
+#if !__unix__
 	err = FindDrive( &ioRefNum, &(GPtr->DrvPtr), GPtr->DrvNum );
 #endif	
 	if ( IsBlueBoxSharedDrive( GPtr->DrvPtr ) )
@@ -757,7 +779,7 @@ static int ScavSetUp( SGlob *GPtr)
 	
 	err = GetVolumeFeatures( GPtr );				//	Sets up GPtr->volumeFeatures and GPtr->realVCB
 
-#if !BSD
+#if !__unix__
 	if ( GPtr->DrvPtr == NULL )						//	<8> drive is no longer there!
 		return ( R_NoVol );
 	else
@@ -774,7 +796,7 @@ static int ScavSetUp( SGlob *GPtr)
 	//	Finish initializing the VCB
 
 	//	The calculated structures
-#if BSD
+#if __unix__
 	InitBlockCache(vcb);
 	vcb->vcbDriveNumber = GPtr->DrvNum;
 	vcb->vcbDriverReadRef = GPtr->DrvNum;
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/SDevice.c diskdev_cmds/fsck_hfs.tproj/dfalib/SDevice.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/SDevice.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/SDevice.c	2003-07-08 12:39:44.000000000 +0200
@@ -23,13 +23,17 @@
  */
 #include "SRuntime.h"
 
-#if BSD
+#if __unix__
 
 #include <unistd.h>
 #include <errno.h>
 #include <sys/ioctl.h>
 
+#if __APPLE__
 #include <IOKit/storage/IOMediaBSDClient.h>
+#else
+#include <sys/stat.h>
+#endif
 
 #else
 
@@ -42,7 +46,8 @@
 
 OSErr GetDeviceSize(int driveRefNum, UInt64 *numBlocks, UInt32 *blockSize)
 {
-#if BSD
+#if __unix__
+#if __APPLE__
 	UInt64 devBlockCount = 0;
 	int devBlockSize = 0;
 
@@ -65,6 +70,36 @@ OSErr GetDeviceSize(int driveRefNum, UIn
 	}
 	return (0);
 #else
+#ifndef BLKGETSIZE
+#define BLKGETSIZE		_IO(0x12,96)
+#endif
+#ifndef BLKGETSIZE64
+#define BLKGETSIZE64	_IOR(0x12,114,size_t)
+#endif
+
+	struct stat statb;
+	if (fstat(driveRefNum , &statb) < 0) {
+		return (-1);
+	}
+	if (S_ISREG(statb.st_mode)) {
+		*numBlocks = statb.st_size / 512;
+		*blockSize = 512;
+		return 0;
+	} else if (S_ISBLK(statb.st_mode)) {
+		unsigned long size;
+		u_int64_t size64;
+		if (!ioctl(driveRefNum, BLKGETSIZE64, &size64))
+			*numBlocks = size64 / 512;
+		else if (!ioctl(driveRefNum, BLKGETSIZE, &size))
+			*numBlocks = size;
+		else
+			return (-1);
+		*blockSize = 512;
+		return 0;
+	}
+	return (-1);
+#endif
+#else
 	/* Various Mac OS device constants */
 	enum
 	{
@@ -187,13 +222,13 @@ int io_count = 0;
 
 void printIOstats(void)
 {
-	printf("IO Summary:  %d I/O calls, for %qd bytes\n", io_count, io_bytes_read);
+	printf("IO Summary:  %d I/O calls, for %Ld bytes\n", io_count, io_bytes_read);
 }
 
 
 OSErr DeviceRead(int device, int drive, void* buffer, SInt64 offset, UInt32 reqBytes, UInt32 *actBytes)
 {
-#if BSD
+#if __unix__
 	off_t seek_off;
 	ssize_t	nbytes;
 	
@@ -248,7 +283,7 @@ OSErr DeviceRead(int device, int drive, 
 
 OSErr DeviceWrite(int device, int drive, void* buffer, SInt64 offset, UInt32 reqBytes, UInt32 *actBytes)
 {
-#if BSD
+#if __unix__
 	off_t seek_off;
 	ssize_t	nbytes;
 
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/SExtents.c diskdev_cmds/fsck_hfs.tproj/dfalib/SExtents.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/SExtents.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/SExtents.c	2003-05-05 12:32:10.000000000 +0200
@@ -251,8 +251,8 @@ OSErr FindExtentRecord(
 
 		key.keyLength	= kHFSExtentKeyMaximumLength;
 		key.forkType	= forkType;
-		key.fileID		= fileID;
-		key.startBlock	= startBlock;
+		SET_SWAP_BE32(key.fileID, fileID);
+		SET_SWAP_BE16(key.startBlock, startBlock);
 		
 		err = SearchBTreeRecord(vcb->vcbExtentsFile, &key, kNoHint, &extentKey, &extentData,
 								&foundSize, foundHint);
@@ -268,7 +268,7 @@ OSErr FindExtentRecord(
 
 			if (err == noErr) {
 				//	Found a previous record.  Does it belong to the same fork of the same file?
-				if (extentKey.fileID != fileID || extentKey.forkType != forkType)
+				if (SWAP_BE32(extentKey.fileID) != fileID || extentKey.forkType != forkType)
 					err = btNotFound;
 			}
 		}
@@ -277,24 +277,24 @@ OSErr FindExtentRecord(
 			UInt16	i;
 			
 			//	Copy the found key back for the caller
-			foundKey->keyLength 	= kHFSPlusExtentKeyMaximumLength;
+			SET_SWAP_BE16(foundKey->keyLength, kHFSPlusExtentKeyMaximumLength);
 			foundKey->forkType		= extentKey.forkType;
 			foundKey->pad			= 0;
-			foundKey->fileID		= extentKey.fileID;
-			foundKey->startBlock	= extentKey.startBlock;
+			foundKey->fileID = extentKey.fileID;
+			SET_SWAP_BE32(foundKey->startBlock, SWAP_BE16(extentKey.startBlock));
 			
 			//	Copy the found data back for the caller
-			foundData[0].startBlock = extentData[0].startBlock;
-			foundData[0].blockCount = extentData[0].blockCount;
-			foundData[1].startBlock = extentData[1].startBlock;
-			foundData[1].blockCount = extentData[1].blockCount;
-			foundData[2].startBlock = extentData[2].startBlock;
-			foundData[2].blockCount = extentData[2].blockCount;
+			SET_SWAP_BE32(foundData[0].startBlock, SWAP_BE16(extentData[0].startBlock));
+			SET_SWAP_BE32(foundData[0].blockCount, SWAP_BE16(extentData[0].blockCount));
+			SET_SWAP_BE32(foundData[1].startBlock, SWAP_BE16(extentData[1].startBlock));
+			SET_SWAP_BE32(foundData[1].blockCount, SWAP_BE16(extentData[1].blockCount));
+			SET_SWAP_BE32(foundData[2].startBlock, SWAP_BE16(extentData[2].startBlock));
+			SET_SWAP_BE32(foundData[2].blockCount, SWAP_BE16(extentData[2].blockCount));
 			
 			for (i = 3; i < kHFSPlusExtentDensity; ++i)
 			{
-				foundData[i].startBlock = 0;
-				foundData[i].blockCount = 0;
+				SET_SWAP_BE32(foundData[i].startBlock, 0);
+				SET_SWAP_BE32(foundData[i].blockCount, 0);
 			}
 		}
 	}
@@ -303,11 +303,11 @@ OSErr FindExtentRecord(
 		HFSPlusExtentKey		extentKey;
 		HFSPlusExtentRecord	extentData;
 
-		key.keyLength	= kHFSPlusExtentKeyMaximumLength;
+		SET_SWAP_BE16(key.keyLength, kHFSPlusExtentKeyMaximumLength);
 		key.forkType	= forkType;
 		key.pad			= 0;
-		key.fileID		= fileID;
-		key.startBlock	= startBlock;
+		SET_SWAP_BE32(key.fileID, fileID);
+		SET_SWAP_BE32(key.startBlock, startBlock);
 		
 		err = SearchBTreeRecord(vcb->vcbExtentsFile, &key, kNoHint, &extentKey, &extentData,
 								&foundSize, foundHint);
@@ -323,7 +323,7 @@ OSErr FindExtentRecord(
 
 			if (err == noErr) {
 				//	Found a previous record.  Does it belong to the same fork of the same file?
-				if (extentKey.fileID != fileID || extentKey.forkType != forkType)
+				if (SWAP_BE32(extentKey.fileID) != fileID || extentKey.forkType != forkType)
 					err = btNotFound;
 			}
 		}
@@ -358,7 +358,7 @@ static OSErr CreateExtentRecord(
 		hfsKey.keyLength  = kHFSExtentKeyMaximumLength;
 		hfsKey.forkType	  = key->forkType;
 		hfsKey.fileID	  = key->fileID;
-		hfsKey.startBlock = key->startBlock;
+		SET_SWAP_BE16(hfsKey.startBlock, SWAP_BE32(key->startBlock));
 		
 		err = ExtentsToExtDataRec(extents, data);
 		if (err == noErr)
@@ -387,19 +387,19 @@ OSErr DeleteExtentRecord(
 
 		key.keyLength	= kHFSExtentKeyMaximumLength;
 		key.forkType	= forkType;
-		key.fileID		= fileID;
-		key.startBlock	= startBlock;
+		SET_SWAP_BE32(key.fileID, fileID);
+		SET_SWAP_BE16(key.startBlock, startBlock);
 		
 		err = DeleteBTreeRecord( vcb->vcbExtentsFile, &key );
 	}
 	else {		//	HFS Plus volume
 		HFSPlusExtentKey	key;
 
-		key.keyLength	= kHFSPlusExtentKeyMaximumLength;
+		SET_SWAP_BE16(key.keyLength, kHFSPlusExtentKeyMaximumLength);
 		key.forkType	= forkType;
 		key.pad			= 0;
-		key.fileID		= fileID;
-		key.startBlock	= startBlock;
+		SET_SWAP_BE32(key.fileID, fileID);
+		SET_SWAP_BE32(key.startBlock, startBlock);
 		
 		err = DeleteBTreeRecord( vcb->vcbExtentsFile, &key );
 	}
@@ -460,8 +460,8 @@ OSErr MapFileBlockC (
 	if (err != noErr) {
 		err = SearchExtentFile(vcb, fcb, sectorOffset, &foundKey, foundData, &foundIndex, &hint, &nextFABN);
 		if (err == noErr) {
-			startBlock = foundData[foundIndex].startBlock;
-			firstFABN = nextFABN - foundData[foundIndex].blockCount;
+			startBlock = SWAP_BE32(foundData[foundIndex].startBlock);
+			firstFABN = nextFABN - SWAP_BE32(foundData[foundIndex].blockCount);
 		}
 	}
 	
@@ -547,14 +547,14 @@ static OSErr ReleaseExtents(
 		
 		// Loop over the extent record and release the blocks associated with each extent.
 		
-		numAllocationBlocks = extentRecord[extentIndex].blockCount;
+		numAllocationBlocks = SWAP_BE32(extentRecord[extentIndex].blockCount);
 		if ( numAllocationBlocks == 0 )
 		{
 			*releasedLastExtent = true;
 			break;
 		}
 
-		err = ReleaseBitmapBits( extentRecord[extentIndex].startBlock, numAllocationBlocks );
+		err = ReleaseBitmapBits( SWAP_BE32(extentRecord[extentIndex].startBlock), numAllocationBlocks );
 		if ( err != noErr )
 			break;
 					
@@ -689,20 +689,20 @@ OSErr DeallocateFile(SVCB *vcb, CatalogR
 
 	errDF = errRF = 0;
 
-	if (fileRec->recordType == kHFSFileRecord) {
+	if (SWAP_BE16(fileRec->recordType) == kHFSFileRecord) {
 		HFSPlusExtentRecord dataForkExtents;
 		HFSPlusExtentRecord rsrcForkExtents;
 		
 		for (i = 0; i < kHFSExtentDensity; ++i) {
-			dataForkExtents[i].startBlock =
-				(UInt32) (fileRec->hfsFile.dataExtents[i].startBlock);
-			dataForkExtents[i].blockCount =
-				(UInt32) (fileRec->hfsFile.dataExtents[i].blockCount);
-
-			rsrcForkExtents[i].startBlock =
-				(UInt32) (fileRec->hfsFile.rsrcExtents[i].startBlock);
-			rsrcForkExtents[i].blockCount =
-				(UInt32) (fileRec->hfsFile.rsrcExtents[i].blockCount);
+			SET_SWAP_BE32(dataForkExtents[i].startBlock,
+				(UInt32) (SWAP_BE16(fileRec->hfsFile.dataExtents[i].startBlock)));
+			SET_SWAP_BE32(dataForkExtents[i].blockCount,
+				(UInt32) (SWAP_BE16(fileRec->hfsFile.dataExtents[i].blockCount)));
+
+			SET_SWAP_BE32(rsrcForkExtents[i].startBlock,
+				(UInt32) (SWAP_BE16(fileRec->hfsFile.rsrcExtents[i].startBlock)));
+			SET_SWAP_BE32(rsrcForkExtents[i].blockCount,
+				(UInt32) (SWAP_BE16(fileRec->hfsFile.rsrcExtents[i].blockCount)));
 		}
 		ClearMemory(&dataForkExtents[i].startBlock,
 			sizeof(HFSPlusExtentRecord) - sizeof(HFSExtentRecord));
@@ -710,17 +710,17 @@ OSErr DeallocateFile(SVCB *vcb, CatalogR
 		ClearMemory(&rsrcForkExtents[i].startBlock,
 			sizeof(HFSPlusExtentRecord) - sizeof(HFSExtentRecord));
 		
-		errDF = DeallocateFork(vcb, fileRec->hfsFile.fileID, kDataForkType,
+		errDF = DeallocateFork(vcb, SWAP_BE32(fileRec->hfsFile.fileID), kDataForkType,
 				dataForkExtents, &recordDeleted );
 
-		errRF = DeallocateFork(vcb, fileRec->hfsFile.fileID, kResourceForkType,
+		errRF = DeallocateFork(vcb, SWAP_BE32(fileRec->hfsFile.fileID), kResourceForkType,
 			rsrcForkExtents, &recordDeleted );
 	}
-	else if (fileRec->recordType == kHFSPlusFileRecord) {
-		errDF = DeallocateFork(vcb, fileRec->hfsPlusFile.fileID, kDataForkType,
+	else if (SWAP_BE16(fileRec->recordType) == kHFSPlusFileRecord) {
+		errDF = DeallocateFork(vcb, SWAP_BE32(fileRec->hfsPlusFile.fileID), kDataForkType,
 			fileRec->hfsPlusFile.dataFork.extents, &recordDeleted );
 
-		errRF = DeallocateFork(vcb, fileRec->hfsPlusFile.fileID, kResourceForkType,
+		errRF = DeallocateFork(vcb, SWAP_BE32(fileRec->hfsPlusFile.fileID), kResourceForkType,
 			fileRec->hfsPlusFile.resourceFork.extents, &recordDeleted );
 	}
 
@@ -902,7 +902,7 @@ OSErr ExtendFileC (
 		//	Try to allocate the new space contiguous with the end of the previous
 		//	extent.  If this succeeds, the last extent grows and the file does not
 		//	become any more fragmented.
-		startBlock = foundData[foundIndex].startBlock + foundData[foundIndex].blockCount;
+		startBlock = SWAP_BE32(foundData[foundIndex].startBlock) + SWAP_BE32(foundData[foundIndex].blockCount);
 		err = BlockAllocate(vcb, startBlock, blocksToAdd, maxBlocksToAdd, wantContig, &actualStartBlock, &actualNumBlocks);
 		if (err == dskFulErr) {
 			if (flags & kEFContigMask)
@@ -920,7 +920,7 @@ OSErr ExtendFileC (
 			//	Add the new extent to the existing extent record, or create a new one.
 			if (actualStartBlock == startBlock) {
 				//	We grew the file's last extent, so just adjust the number of blocks.
-				foundData[foundIndex].blockCount += actualNumBlocks;
+				SET_SWAP_BE32(foundData[foundIndex].blockCount, SWAP_BE32(foundData[foundIndex].blockCount) + actualNumBlocks);
 				err = UpdateExtentRecord(vcb, fcb, &foundKey, foundData, hint);
 				if (err != noErr) break;
 			}
@@ -928,7 +928,7 @@ OSErr ExtendFileC (
 				UInt16	i;
 
 				//	Need to add a new extent.  See if there is room in the current record.
-				if (foundData[foundIndex].blockCount != 0)	//	Is current extent free to use?
+				if (SWAP_BE32(foundData[foundIndex].blockCount) != 0)	//	Is current extent free to use?
 					++foundIndex;							// 	No, so use the next one.
 				if (foundIndex == numExtentsPerRecord) {
 					//	This record is full.  Need to create a new one.
@@ -938,23 +938,23 @@ OSErr ExtendFileC (
 						break;
 					}
 					
-					foundKey.keyLength = kHFSPlusExtentKeyMaximumLength;
+					SET_SWAP_BE16(foundKey.keyLength, kHFSPlusExtentKeyMaximumLength);
 					if (fcb->fcbFlags & fcbResourceMask)
 						foundKey.forkType = kResourceForkType;
 					else
 						foundKey.forkType = kDataForkType;
 					foundKey.pad = 0;
-					foundKey.fileID = fcb->fcbFileID;
-					foundKey.startBlock = nextBlock;
+					SET_SWAP_BE32(foundKey.fileID, fcb->fcbFileID);
+					SET_SWAP_BE32(foundKey.startBlock, nextBlock);
 					
-					foundData[0].startBlock = actualStartBlock;
-					foundData[0].blockCount = actualNumBlocks;
+					SET_SWAP_BE32(foundData[0].startBlock, actualStartBlock);
+					SET_SWAP_BE32(foundData[0].blockCount, actualNumBlocks);
 					
 					// zero out remaining extents...
 					for (i = 1; i < kHFSPlusExtentDensity; ++i)
 					{
-						foundData[i].startBlock = 0;
-						foundData[i].blockCount = 0;
+						SET_SWAP_BE32(foundData[i].startBlock, 0);
+						SET_SWAP_BE32(foundData[i].blockCount, 0);
 					}
 
 					foundIndex = 0;
@@ -973,8 +973,8 @@ OSErr ExtendFileC (
 				}
 				else {
 					//	Add a new extent into this record and update.
-					foundData[foundIndex].startBlock = actualStartBlock;
-					foundData[foundIndex].blockCount = actualNumBlocks;
+					SET_SWAP_BE32(foundData[foundIndex].startBlock, actualStartBlock);
+					SET_SWAP_BE32(foundData[foundIndex].blockCount, actualNumBlocks);
 					err = UpdateExtentRecord(vcb, fcb, &foundKey, foundData, hint);
 					if (err != noErr) break;
 				}
@@ -1275,7 +1275,7 @@ static OSErr SearchExtentRecord(
 		
 		// Loop over the extent record and find the search FABN.
 		
-		numAllocationBlocks = extentData[extentIndex].blockCount;
+		numAllocationBlocks = SWAP_BE32(extentData[extentIndex].blockCount);
 		if ( numAllocationBlocks == 0 )
 		{
 			break;
@@ -1372,7 +1372,7 @@ static OSErr SearchExtentFile(
 	if( err == noErr ) {
 		// Found the extent. Set results accordingly
 		*extentBTreeHint = kNoHint;			// no hint, because not in the BTree
-		foundExtentKey->keyLength = 0;		// 0 = the FCB itself
+		SET_SWAP_BE16(foundExtentKey->keyLength, 0);		// 0 = the FCB itself
 		
 		goto Exit;
 	}
@@ -1383,7 +1383,7 @@ static OSErr SearchExtentFile(
 	//	to fill in the hint and key outputs, just like the "if" statement above.
 	if ( noMoreExtents ) {
 		*extentBTreeHint = kNoHint;			// no hint, because not in the BTree
-		foundExtentKey->keyLength = 0;		// 0 = the FCB itself
+		SET_SWAP_BE16(foundExtentKey->keyLength,  0);		// 0 = the FCB itself
 		err = fxRangeErr;		// There are no more extents, so must be beyond PEOF
 		goto Exit;
 	}
@@ -1400,7 +1400,7 @@ static OSErr SearchExtentFile(
 		//	in the extents file.  Return the FCB's extents and a range error.
 		//
 		*extentBTreeHint = kNoHint;
-		foundExtentKey->keyLength = 0;
+		SET_SWAP_BE16(foundExtentKey->keyLength, 0);
 		err = GetFCBExtentRecord(vcb, fcb, foundExtentData);
 		//	Note: foundExtentIndex and endingFABNPlusOne have already been set as a result of the very
 		//	first SearchExtentRecord call in this function (when searching in the FCB's extents, and
@@ -1415,7 +1415,7 @@ static OSErr SearchExtentFile(
 	//
 	if (err == noErr) {
 		//	Find appropriate index into extent record
-		err = SearchExtentRecord(vcb, filePositionBlock, foundExtentData, foundExtentKey->startBlock,
+		err = SearchExtentRecord(vcb, filePositionBlock, foundExtentData, SWAP_BE32(foundExtentKey->startBlock),
 								 foundExtentIndex, endingFABNPlusOne, &noMoreExtents);
 	}
 
@@ -1455,7 +1455,7 @@ static OSErr UpdateExtentRecord (
 	UInt32	foundHint;
 	UInt16	foundDataSize;
 	
-	if (extentFileKey->keyLength == 0) {	// keyLength == 0 means the FCB's extent record
+	if (SWAP_BE16(extentFileKey->keyLength) == 0) {	// keyLength == 0 means the FCB's extent record
 		err = SetFCBExtentRecord(vcb, fcb, extentData);
 		fcb->fcbFlags |= fcbModifiedMask;
 	}
@@ -1470,8 +1470,8 @@ static OSErr UpdateExtentRecord (
 
 			key.keyLength	= kHFSExtentKeyMaximumLength;
 			key.forkType	= extentFileKey->forkType;
-			key.fileID		= extentFileKey->fileID;
-			key.startBlock	= extentFileKey->startBlock;
+			key.fileID	= extentFileKey->fileID;
+			SET_SWAP_BE16(key.startBlock, SWAP_BE32(extentFileKey->startBlock));
 
 			err = SearchBTreeRecord(vcb->vcbExtentsFile, &key, extentBTreeHint,
 									&foundKey, &foundData, &foundDataSize, &foundHint);
@@ -1508,18 +1508,18 @@ void ExtDataRecToExtents(
 	UInt32	i;
 
 	// copy the first 3 extents
-	newExtents[0].startBlock = oldExtents[0].startBlock;
-	newExtents[0].blockCount = oldExtents[0].blockCount;
-	newExtents[1].startBlock = oldExtents[1].startBlock;
-	newExtents[1].blockCount = oldExtents[1].blockCount;
-	newExtents[2].startBlock = oldExtents[2].startBlock;
-	newExtents[2].blockCount = oldExtents[2].blockCount;
+	SET_SWAP_BE32(newExtents[0].startBlock, SWAP_BE16(oldExtents[0].startBlock));
+	SET_SWAP_BE32(newExtents[0].blockCount, SWAP_BE16(oldExtents[0].blockCount));
+	SET_SWAP_BE32(newExtents[1].startBlock, SWAP_BE16(oldExtents[1].startBlock));
+	SET_SWAP_BE32(newExtents[1].blockCount, SWAP_BE16(oldExtents[1].blockCount));
+	SET_SWAP_BE32(newExtents[2].startBlock, SWAP_BE16(oldExtents[2].startBlock));
+	SET_SWAP_BE32(newExtents[2].blockCount, SWAP_BE16(oldExtents[2].blockCount));
 
 	// zero out the remaining ones
 	for (i = 3; i < kHFSPlusExtentDensity; ++i)
 	{
-		newExtents[i].startBlock = 0;
-		newExtents[i].blockCount = 0;
+		SET_SWAP_BE32(newExtents[i].startBlock, 0);
+		SET_SWAP_BE32(newExtents[i].blockCount, 0);
 	}
 }
 
@@ -1534,17 +1534,17 @@ static OSErr ExtentsToExtDataRec(
 	err = noErr;
 
 	// copy the first 3 extents
-	newExtents[0].startBlock = oldExtents[0].startBlock;
-	newExtents[0].blockCount = oldExtents[0].blockCount;
-	newExtents[1].startBlock = oldExtents[1].startBlock;
-	newExtents[1].blockCount = oldExtents[1].blockCount;
-	newExtents[2].startBlock = oldExtents[2].startBlock;
-	newExtents[2].blockCount = oldExtents[2].blockCount;
+	SET_SWAP_BE16(newExtents[0].startBlock, SWAP_BE32(oldExtents[0].startBlock));
+	SET_SWAP_BE16(newExtents[0].blockCount, SWAP_BE32(oldExtents[0].blockCount));
+	SET_SWAP_BE16(newExtents[1].startBlock, SWAP_BE32(oldExtents[1].startBlock));
+	SET_SWAP_BE16(newExtents[1].blockCount, SWAP_BE32(oldExtents[1].blockCount));
+	SET_SWAP_BE16(newExtents[2].startBlock, SWAP_BE32(oldExtents[2].startBlock));
+	SET_SWAP_BE16(newExtents[2].blockCount, SWAP_BE32(oldExtents[2].blockCount));
 
 	#if DEBUG_BUILD
-		if (oldExtents[3].startBlock || oldExtents[3].blockCount) {
-			DebugStr("\pExtentRecord with > 3 extents is invalid for HFS");
-			err = fsDSIntErr;
+		if (SWAP_BE32(oldExtents[3].startBlock) || SWAP_BE32(oldExtents[3].blockCount)) {
+			DebugStr("ExtentRecord with > 3 extents is invalid for HFS");
+			//err = fsDSIntErr;
 		}
 	#endif
 	
@@ -1574,7 +1574,7 @@ static OSErr SetFCBExtentRecord(
 
 	#if DEBUG_BUILD
 		if (fcb->fcbVolume != vcb)
-			DebugStr("\pVCB does not match FCB");
+			DebugStr("VCB does not match FCB");
 	#endif
 
 	if (vcb->vcbSignature == kHFSPlusSigWord)
@@ -1630,7 +1630,7 @@ static OSErr MapFileBlockFromFCB(
 		
 		for (index=0; index<kHFSExtentDensity; index++) {
 
-			blockCount = extent->blockCount;
+			blockCount = SWAP_BE16(extent->blockCount);
 
 			if (blockCount == 0)
 				return fxRangeErr;				//	ran out of extents!
@@ -1638,7 +1638,7 @@ static OSErr MapFileBlockFromFCB(
 			//	Is it in this extent?
 			if (offsetBlocks < blockCount) {
 				*firstFABN	= currentFABN;
-				*firstBlock	= extent->startBlock;
+				*firstBlock	= SWAP_BE16(extent->startBlock);
 				currentFABN += blockCount;		//	faster to add these as UInt16 first, then extend to UInt32
 				*nextFABN	= currentFABN;
 				return noErr;					//	found the right extent
@@ -1660,7 +1660,7 @@ static OSErr MapFileBlockFromFCB(
 		
 		for (index=0; index<kHFSPlusExtentDensity; index++) {
 
-			blockCount = extent->blockCount;
+			blockCount = SWAP_BE32(extent->blockCount);
 
 			if (blockCount == 0)
 				return fxRangeErr;				//	ran out of extents!
@@ -1668,7 +1668,7 @@ static OSErr MapFileBlockFromFCB(
 			//	Is it in this extent?
 			if (offsetBlocks < blockCount) {
 				*firstFABN	= currentFABN;
-				*firstBlock	= extent->startBlock;
+				*firstBlock	= SWAP_BE32(extent->startBlock);
 				*nextFABN	= currentFABN + blockCount;
 				return noErr;					//	found the right extent
 			}
@@ -1775,7 +1775,7 @@ static Boolean ExtentsAreIntegral(
 	
 	for(extentIndex = 0; extentIndex < kHFSPlusExtentDensity; extentIndex++)
 	{		
-		blocks = extentRecord[extentIndex].blockCount;
+		blocks = SWAP_BE32(extentRecord[extentIndex].blockCount);
 		
 		if ( blocks == 0 )
 		{
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/SKeyCompare.c diskdev_cmds/fsck_hfs.tproj/dfalib/SKeyCompare.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/SKeyCompare.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/SKeyCompare.c	2003-05-05 12:32:27.000000000 +0200
@@ -209,8 +209,8 @@ CompareCatalogKeys(HFSCatalogKey *search
 	HFSCatalogNodeID	searchParentID, trialParentID;
 	SInt32	result;
 
-	searchParentID = searchKey->parentID;
-	trialParentID = trialKey->parentID;
+	searchParentID = SWAP_BE32(searchKey->parentID);
+	trialParentID = SWAP_BE32(trialKey->parentID);
 
 	if ( searchParentID > trialParentID )	/* parent dirID is unsigned */
 		result = 1;
@@ -239,8 +239,8 @@ CompareExtendedCatalogKeys(HFSPlusCatalo
 	SInt32			result;
 	HFSCatalogNodeID	searchParentID, trialParentID;
 
-	searchParentID = searchKey->parentID;
-	trialParentID = trialKey->parentID;
+	searchParentID = SWAP_BE32(searchKey->parentID);
+	trialParentID = SWAP_BE32(trialKey->parentID);
 	
 	if ( searchParentID > trialParentID ) 	// parent node IDs are unsigned
 	{
@@ -252,11 +252,11 @@ CompareExtendedCatalogKeys(HFSPlusCatalo
 	}
 	else // parent node ID's are equal, compare names
 	{
-		if ( searchKey->nodeName.length == 0 || trialKey->nodeName.length == 0 )
-			result = searchKey->nodeName.length - trialKey->nodeName.length;
+		if ( SWAP_BE16(searchKey->nodeName.length) == 0 || SWAP_BE16(trialKey->nodeName.length) == 0 )
+			result = SWAP_BE16(searchKey->nodeName.length) - SWAP_BE16(trialKey->nodeName.length);
 		else
-			result = FastUnicodeCompare(&searchKey->nodeName.unicode[0], searchKey->nodeName.length,
-										&trialKey->nodeName.unicode[0], trialKey->nodeName.length);
+			result = FastUnicodeCompare(searchKey->nodeName.unicode, SWAP_BE16(searchKey->nodeName.length),
+										trialKey->nodeName.unicode, SWAP_BE16(trialKey->nodeName.length));
 	}
 
 	return result;
@@ -276,14 +276,14 @@ SInt32 CompareExtentKeys( const HFSExten
 	
 	#if DEBUG_BUILD
 		if (searchKey->keyLength != kHFSExtentKeyMaximumLength)
-			DebugStr("\pHFS: search Key is wrong length");
+			DebugStr("HFS: search Key is wrong length");
 		if (trialKey->keyLength != kHFSExtentKeyMaximumLength)
-			DebugStr("\pHFS: trial Key is wrong length");
+			DebugStr("HFS: trial Key is wrong length");
 	#endif
 	
 	result = -1;		//	assume searchKey < trialKey
 	
-	if (searchKey->fileID == trialKey->fileID) {
+	if (SWAP_BE32(searchKey->fileID) == SWAP_BE32(trialKey->fileID)) {
 		//
 		//	FileNum's are equal; compare fork types
 		//
@@ -291,7 +291,7 @@ SInt32 CompareExtentKeys( const HFSExten
 			//
 			//	Fork types are equal; compare allocation block number
 			//
-			if (searchKey->startBlock == trialKey->startBlock) {
+			if (SWAP_BE16(searchKey->startBlock) == SWAP_BE16(trialKey->startBlock)) {
 				//
 				//	Everything is equal
 				//
@@ -301,7 +301,7 @@ SInt32 CompareExtentKeys( const HFSExten
 				//
 				//	Allocation block numbers differ; determine sign
 				//
-				if (searchKey->startBlock > trialKey->startBlock)
+				if (SWAP_BE16(searchKey->startBlock) > SWAP_BE16(trialKey->startBlock))
 					result = 1;
 			}
 		}
@@ -317,7 +317,7 @@ SInt32 CompareExtentKeys( const HFSExten
 		//
 		//	FileNums differ; determine sign
 		//
-		if (searchKey->fileID > trialKey->fileID)
+		if (SWAP_BE32(searchKey->fileID) > SWAP_BE32(trialKey->fileID))
 			result = 1;
 	}
 	
@@ -338,15 +338,15 @@ SInt32 CompareExtentKeysPlus( const HFSP
 	SInt32	result;		//	▒ 1
 	
 	#if DEBUG_BUILD
-		if (searchKey->keyLength != kHFSPlusExtentKeyMaximumLength)
-			DebugStr("\pHFS: search Key is wrong length");
-		if (trialKey->keyLength != kHFSPlusExtentKeyMaximumLength)
-			DebugStr("\pHFS: trial Key is wrong length");
+		if (SWAP_BE16(searchKey->keyLength) != kHFSPlusExtentKeyMaximumLength)
+			DebugStr("HFS: search Key is wrong length");
+		if (SWAP_BE16(trialKey->keyLength) != kHFSPlusExtentKeyMaximumLength)
+			DebugStr("HFS: trial Key is wrong length");
 	#endif
 	
 	result = -1;		//	assume searchKey < trialKey
 	
-	if (searchKey->fileID == trialKey->fileID) {
+	if (SWAP_BE32(searchKey->fileID) == SWAP_BE32(trialKey->fileID)) {
 		//
 		//	FileNum's are equal; compare fork types
 		//
@@ -354,7 +354,7 @@ SInt32 CompareExtentKeysPlus( const HFSP
 			//
 			//	Fork types are equal; compare allocation block number
 			//
-			if (searchKey->startBlock == trialKey->startBlock) {
+			if (SWAP_BE32(searchKey->startBlock) == SWAP_BE32(trialKey->startBlock)) {
 				//
 				//	Everything is equal
 				//
@@ -364,7 +364,7 @@ SInt32 CompareExtentKeysPlus( const HFSP
 				//
 				//	Allocation block numbers differ; determine sign
 				//
-				if (searchKey->startBlock > trialKey->startBlock)
+				if (SWAP_BE32(searchKey->startBlock) > SWAP_BE32(trialKey->startBlock))
 					result = 1;
 			}
 		}
@@ -380,7 +380,7 @@ SInt32 CompareExtentKeysPlus( const HFSP
 		//
 		//	FileNums differ; determine sign
 		//
-		if (searchKey->fileID > trialKey->fileID)
+		if (SWAP_BE32(searchKey->fileID) > SWAP_BE32(trialKey->fileID))
 			result = 1;
 	}
 	
@@ -404,13 +404,13 @@ SInt32 CompareAttributeKeys( const void 
 	/*
 	 * CNID's are equal; compare names
 	 */
-	if (searchKey->attributeName.length == 0 || trialKey->attributeName.length == 0)
-		return (searchKey->attributeName.length < trialKey->attributeName.length ? -1 : 1);
+	if (SWAP_BE16(searchKey->attributeName.length) == 0 || SWAP_BE16(trialKey->attributeName.length) == 0)
+		return (SWAP_BE16(searchKey->attributeName.length) < SWAP_BE16(trialKey->attributeName.length) ? -1 : 1);
 
-	temp = FastUnicodeCompare(&searchKey->attributeName.unicode[0],
-				searchKey->attributeName.length,
-				&trialKey->attributeName.unicode[0],
-				trialKey->attributeName.length);
+	temp = FastUnicodeCompare(searchKey->attributeName.unicode,
+				SWAP_BE16(searchKey->attributeName.length),
+				trialKey->attributeName.unicode,
+				SWAP_BE16(trialKey->attributeName.length));
 	if (temp != 0)
 		return (temp);
 
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/SRebuildCatalogBTree.c diskdev_cmds/fsck_hfs.tproj/dfalib/SRebuildCatalogBTree.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/SRebuildCatalogBTree.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/SRebuildCatalogBTree.c	2003-05-05 12:32:55.000000000 +0200
@@ -69,7 +69,7 @@ static void PrintLeafNodeRec( HFSPlusCat
 
 void SETOFFSET ( void *buffer, UInt16 btNodeSize, SInt16 recOffset, SInt16 vecOffset );
 #define SETOFFSET( buf,ndsiz,offset,rec )		\
-	( *(SInt16 *)((UInt8 *)(buf) + (ndsiz) + (-2 * (rec))) = (SWAP_BE16 (offset)) )
+	SET_SWAP_BE16(*(u_big_int16_t *)((UInt8 *)(buf) + (ndsiz) + (-2 * (rec))), offset)
 
 
 //_________________________________________________________________________________
@@ -161,20 +161,20 @@ OSErr	RebuildCatalogBTree( SGlobPtr theS
 		if ( noErr != myErr )
 			goto ExitThisRoutine;
 		myMDBPtr = (HFSPlusVolumeHeader	*) myBlockDescriptor.buffer;
-		myVCBPtr->vcbFreeBlocks = myMDBPtr->freeBlocks;
-		myVCBPtr->vcbFileCount = myMDBPtr->fileCount;
-		myVCBPtr->vcbFolderCount = myMDBPtr->folderCount;
+		myVCBPtr->vcbFreeBlocks = SWAP_BE32(myMDBPtr->freeBlocks);
+		myVCBPtr->vcbFileCount = SWAP_BE32(myMDBPtr->fileCount);
+		myVCBPtr->vcbFolderCount = SWAP_BE32(myMDBPtr->folderCount);
 		
 		//	check out creation and last mod dates
-		myVCBPtr->vcbCreateDate	= myMDBPtr->createDate;	
-		myVCBPtr->vcbModifyDate	= myMDBPtr->modifyDate;		
-		myVCBPtr->vcbCheckedDate = myMDBPtr->checkedDate;		
-		myVCBPtr->vcbBackupDate = myMDBPtr->backupDate;	
-		myVCBPtr->vcbCatalogFile->fcbClumpSize = myMDBPtr->catalogFile.clumpSize;
+		myVCBPtr->vcbCreateDate	= SWAP_BE32(myMDBPtr->createDate);	
+		myVCBPtr->vcbModifyDate	= SWAP_BE32(myMDBPtr->modifyDate);		
+		myVCBPtr->vcbCheckedDate = SWAP_BE32(myMDBPtr->checkedDate);		
+		myVCBPtr->vcbBackupDate = SWAP_BE32(myMDBPtr->backupDate);	
+		myVCBPtr->vcbCatalogFile->fcbClumpSize = SWAP_BE32(myMDBPtr->catalogFile.clumpSize);
 
 		//	verify volume attribute flags
-		if ( ((UInt16)myMDBPtr->attributes & VAtrb_Msk) == 0 )
-			myVCBPtr->vcbAttributes = (UInt16)myMDBPtr->attributes;
+		if ( ((UInt16)SWAP_BE32(myMDBPtr->attributes) & VAtrb_Msk) == 0 )
+			myVCBPtr->vcbAttributes = (UInt16)SWAP_BE32(myMDBPtr->attributes);
 		else 
 			myVCBPtr->vcbAttributes = VAtrb_DFlt;
 		CopyMemory( myMDBPtr->finderInfo, myVCBPtr->vcbFinderInfo, sizeof(myVCBPtr->vcbFinderInfo) );
@@ -187,22 +187,22 @@ OSErr	RebuildCatalogBTree( SGlobPtr theS
 		if ( noErr != myErr )
 			goto ExitThisRoutine;
 		myMDBPtr = (HFSMasterDirectoryBlock	*) myBlockDescriptor.buffer;
-		myVCBPtr->vcbFreeBlocks = myMDBPtr->drFreeBks;
-		myVCBPtr->vcbFileCount = myMDBPtr->drFilCnt;
-		myVCBPtr->vcbFolderCount = myMDBPtr->drDirCnt;
-		myVCBPtr->vcbCatalogFile->fcbClumpSize = myMDBPtr->drCTClpSiz;
+		myVCBPtr->vcbFreeBlocks = SWAP_BE16(myMDBPtr->drFreeBks);
+		myVCBPtr->vcbFileCount = SWAP_BE32(myMDBPtr->drFilCnt);
+		myVCBPtr->vcbFolderCount = SWAP_BE32(myMDBPtr->drDirCnt);
+		myVCBPtr->vcbCatalogFile->fcbClumpSize = SWAP_BE32(myMDBPtr->drCTClpSiz);
 
 		//	check out creation and last mod dates
-		myVCBPtr->vcbCreateDate	= myMDBPtr->drCrDate;		
-		myVCBPtr->vcbModifyDate	= myMDBPtr->drLsMod;			
+		myVCBPtr->vcbCreateDate	= SWAP_BE32(myMDBPtr->drCrDate);		
+		myVCBPtr->vcbModifyDate	= SWAP_BE32(myMDBPtr->drLsMod);			
 
 		//	verify volume attribute flags
-		if ( (myMDBPtr->drAtrb & VAtrb_Msk) == 0 )
-			myVCBPtr->vcbAttributes = myMDBPtr->drAtrb;
+		if ( (SWAP_BE16(myMDBPtr->drAtrb) & VAtrb_Msk) == 0 )
+			myVCBPtr->vcbAttributes = SWAP_BE16(myMDBPtr->drAtrb);
 		else 
 			myVCBPtr->vcbAttributes = VAtrb_DFlt;
-		myVCBPtr->vcbBackupDate = myMDBPtr->drVolBkUp;		
-		myVCBPtr->vcbVSeqNum = myMDBPtr->drVSeqNum;		
+		myVCBPtr->vcbBackupDate = SWAP_BE32(myMDBPtr->drVolBkUp);		
+		myVCBPtr->vcbVSeqNum = SWAP_BE16(myMDBPtr->drVSeqNum);		
 		CopyMemory( myMDBPtr->drFndrInfo, myVCBPtr->vcbFinderInfo, sizeof(myMDBPtr->drFndrInfo) );
 	}
 	(void) ReleaseVolumeBlock( myVCBPtr, &myBlockDescriptor, kReleaseBlock );
@@ -405,14 +405,14 @@ static OSErr CreateNewCatalogBTree( SGlo
 	myErr = GetBTreeHeader( theSGlobPtr, myFCBPtr, &myHeaderRec );
 	ReturnIfError( myErr );
 	
-	myBTreeCBPtr->treeDepth = myHeaderRec.treeDepth;
-	myBTreeCBPtr->rootNode = myHeaderRec.rootNode;
-	myBTreeCBPtr->leafRecords = myHeaderRec.leafRecords;
-	myBTreeCBPtr->firstLeafNode = myHeaderRec.firstLeafNode;
-	myBTreeCBPtr->lastLeafNode = myHeaderRec.lastLeafNode;
-	myBTreeCBPtr->totalNodes = myHeaderRec.totalNodes;
-	myBTreeCBPtr->freeNodes = myHeaderRec.freeNodes;
-	myBTreeCBPtr->maxKeyLength = myHeaderRec.maxKeyLength;
+	myBTreeCBPtr->treeDepth = SWAP_BE16(myHeaderRec.treeDepth);
+	myBTreeCBPtr->rootNode = SWAP_BE32(myHeaderRec.rootNode);
+	myBTreeCBPtr->leafRecords = SWAP_BE32(myHeaderRec.leafRecords);
+	myBTreeCBPtr->firstLeafNode = SWAP_BE32(myHeaderRec.firstLeafNode);
+	myBTreeCBPtr->lastLeafNode = SWAP_BE32(myHeaderRec.lastLeafNode);
+	myBTreeCBPtr->totalNodes = SWAP_BE32(myHeaderRec.totalNodes);
+	myBTreeCBPtr->freeNodes = SWAP_BE32(myHeaderRec.freeNodes);
+	myBTreeCBPtr->maxKeyLength = SWAP_BE16(myHeaderRec.maxKeyLength);
 
 	if ( myMapNodeCount > 0 )
 	{
@@ -465,29 +465,29 @@ static OSErr InitializeBTree(	BTreeContr
 	/* FILL IN THE NODE DESCRIPTOR:  */
 	myNodeDescPtr 		= (BTNodeDescriptor *) myBufferPtr;
 	myNodeDescPtr->kind 	= kBTHeaderNode;
-	myNodeDescPtr->numRecords = SWAP_BE16 (3);
+	SET_SWAP_BE16(myNodeDescPtr->numRecords, 3);
 	myOffset = sizeof( BTNodeDescriptor );
 
 	SETOFFSET( myBufferPtr, theBTreeCBPtr->nodeSize, myOffset, 1 );
 
 	/* FILL IN THE HEADER RECORD:  */
 	myHeaderRecPtr = (BTHeaderRec *)((UInt8 *)myBufferPtr + myOffset);
-	myHeaderRecPtr->treeDepth		= SWAP_BE16 (1);
-	myHeaderRecPtr->rootNode		= SWAP_BE32 (1);
-	myHeaderRecPtr->firstLeafNode	= SWAP_BE32 (1);
-	myHeaderRecPtr->lastLeafNode	= SWAP_BE32 (1);
-	myHeaderRecPtr->nodeSize		= SWAP_BE16 (theBTreeCBPtr->nodeSize);
-	myHeaderRecPtr->totalNodes		= SWAP_BE32 (theBTreeCBPtr->totalNodes);
-	myHeaderRecPtr->freeNodes		= SWAP_BE32 (SWAP_BE32 (myHeaderRecPtr->totalNodes) - 2);  /* header and leaf */
-	myHeaderRecPtr->clumpSize		= SWAP_BE32 (theBTreeCBPtr->fcbPtr->fcbClumpSize);
+	SET_SWAP_BE16(myHeaderRecPtr->treeDepth, 1);
+	SET_SWAP_BE32(myHeaderRecPtr->rootNode, 1);
+	SET_SWAP_BE32(myHeaderRecPtr->firstLeafNode, 1);
+	SET_SWAP_BE32(myHeaderRecPtr->lastLeafNode, 1);
+	SET_SWAP_BE16(myHeaderRecPtr->nodeSize, theBTreeCBPtr->nodeSize);
+	SET_SWAP_BE32(myHeaderRecPtr->totalNodes, theBTreeCBPtr->totalNodes);
+	SET_SWAP_BE32(myHeaderRecPtr->freeNodes, SWAP_BE32(myHeaderRecPtr->totalNodes) - 2);  /* header and leaf */
+	SET_SWAP_BE32(myHeaderRecPtr->clumpSize, theBTreeCBPtr->fcbPtr->fcbClumpSize);
 
 	if ( isHFSPlus ) 
 	{
-		myHeaderRecPtr->attributes	|= SWAP_BE32 (kBTVariableIndexKeysMask + kBTBigKeysMask);
-		myHeaderRecPtr->maxKeyLength = SWAP_BE16 (kHFSPlusCatalogKeyMaximumLength);
+		SET_SWAP_BE32(myHeaderRecPtr->attributes, SWAP_BE32(myHeaderRecPtr->attributes) | kBTVariableIndexKeysMask | kBTBigKeysMask);
+		SET_SWAP_BE16(myHeaderRecPtr->maxKeyLength, kHFSPlusCatalogKeyMaximumLength);
 	} 
 	else 
-		myHeaderRecPtr->maxKeyLength = SWAP_BE16 (kHFSCatalogKeyMaximumLength);
+		SET_SWAP_BE16(myHeaderRecPtr->maxKeyLength, kHFSCatalogKeyMaximumLength);
 
 	myOffset += sizeof( BTHeaderRec );
 	SETOFFSET( myBufferPtr, theBTreeCBPtr->nodeSize, myOffset, 2 );
@@ -506,14 +506,14 @@ static OSErr InitializeBTree(	BTreeContr
 	{
 		UInt32	nodeBitsInMapNode;
 		
-		myNodeDescPtr->fLink = SWAP_BE32 (SWAP_BE32 (myHeaderRecPtr->lastLeafNode) + 1);
+		SET_SWAP_BE32(myNodeDescPtr->fLink, SWAP_BE32(myHeaderRecPtr->lastLeafNode) + 1);
 		nodeBitsInMapNode = 8 * (theBTreeCBPtr->nodeSize
 								- sizeof(BTNodeDescriptor)
 								- (2 * sizeof(SInt16))
 								- 2 );
-		*theMapNodeCountPtr = (SWAP_BE32 (myHeaderRecPtr->totalNodes) - myNodeBitsInHeader +
+		*theMapNodeCountPtr = (SWAP_BE32(myHeaderRecPtr->totalNodes) - myNodeBitsInHeader +
 			(nodeBitsInMapNode - 1)) / nodeBitsInMapNode;
-		myHeaderRecPtr->freeNodes = SWAP_BE32 (SWAP_BE32 (myHeaderRecPtr->freeNodes) - *theMapNodeCountPtr);
+		SET_SWAP_BE32(myHeaderRecPtr->freeNodes, SWAP_BE32 (myHeaderRecPtr->freeNodes) - *theMapNodeCountPtr);
 	}
 
 	/* 
@@ -555,7 +555,7 @@ static OSErr InitializeBTree(	BTreeContr
 	myNodeDescPtr 			= (BTNodeDescriptor *) myBufferPtr;
 	myNodeDescPtr->kind 	= kBTLeafNode;
 	myNodeDescPtr->height 	= 1;
-	myNodeDescPtr->numRecords = 0;
+	SET_SWAP_BE16(myNodeDescPtr->numRecords, 0);
 	myOffset = sizeof( BTNodeDescriptor );
 
 	SETOFFSET( myBufferPtr, theBTreeCBPtr->nodeSize, myOffset, 1 );
@@ -608,7 +608,7 @@ static OSErr WriteMapNodes(	BTreeControl
 	
 		myNodeDescPtr = (BTNodeDescriptor *) myNode.buffer;
 		myNodeDescPtr->kind			= kBTMapNode;
-		myNodeDescPtr->numRecords	= SWAP_BE16 (1);
+		SET_SWAP_BE16(myNodeDescPtr->numRecords, 1);
 		
 		/* note: must be long word aligned (hence the extra -2) */
 		mapRecordBytes = theBTreeCBPtr->nodeSize - sizeof(BTNodeDescriptor) - 2 * sizeof(SInt16) - 2;	
@@ -617,9 +617,9 @@ static OSErr WriteMapNodes(	BTreeControl
 		SETOFFSET( myNodeDescPtr, theBTreeCBPtr->nodeSize, sizeof(BTNodeDescriptor) + mapRecordBytes, 2) ;
 
 		if ( (i + 1) < theNodeCount )
-			myNodeDescPtr->fLink = SWAP_BE32 (++theFirstMapNode);  /* point to next map node */
+			SET_SWAP_BE32(myNodeDescPtr->fLink, ++theFirstMapNode);  /* point to next map node */
 		else
-			myNodeDescPtr->fLink = 0;  /* this is the last map node */
+			SET_SWAP_BE32(myNodeDescPtr->fLink, 0);  /* this is the last map node */
 
 		myErr = UpdateNode( theBTreeCBPtr, &myNode );
 		M_ExitOnError( myErr );
@@ -664,32 +664,32 @@ static OSErr DeleteCatalogBTree( SGlobPt
 	{
 		for ( i = 0; i < kHFSPlusExtentDensity; ++i ) 
 		{
-			if ( theFCBPtr->fcbExtents32[ i ].blockCount == 0 )
+			if ( SWAP_BE32(theFCBPtr->fcbExtents32[ i ].blockCount) == 0 )
 			{
 				checkExtentsBTree = false;
 				break;
 			}
 			(void) BlockDeallocate( myVCBPtr, 
-									theFCBPtr->fcbExtents32[ i ].startBlock, 
-									theFCBPtr->fcbExtents32[ i ].blockCount );
-			theFCBPtr->fcbExtents32[ i ].startBlock = 0;
-			theFCBPtr->fcbExtents32[ i ].blockCount = 0;
+									SWAP_BE32(theFCBPtr->fcbExtents32[ i ].startBlock), 
+									SWAP_BE32(theFCBPtr->fcbExtents32[ i ].blockCount) );
+			SET_SWAP_BE32(theFCBPtr->fcbExtents32[ i ].startBlock, 0);
+			SET_SWAP_BE32(theFCBPtr->fcbExtents32[ i ].blockCount, 0);
 		}
 	}
 	else
 	{
 		for ( i = 0; i < kHFSExtentDensity; ++i ) 
 		{
-			if ( theFCBPtr->fcbExtents16[ i ].blockCount == 0 )
+			if ( SWAP_BE16(theFCBPtr->fcbExtents16[ i ].blockCount) == 0 )
 			{
 				checkExtentsBTree = false;
 				break;
 			}
 			(void) BlockDeallocate( myVCBPtr, 
-									theFCBPtr->fcbExtents16[ i ].startBlock, 
-									theFCBPtr->fcbExtents16[ i ].blockCount );
-			theFCBPtr->fcbExtents16[ i ].startBlock = 0;
-			theFCBPtr->fcbExtents16[ i ].blockCount = 0;
+									SWAP_BE16(theFCBPtr->fcbExtents16[ i ].startBlock), 
+									SWAP_BE16(theFCBPtr->fcbExtents16[ i ].blockCount) );
+			SET_SWAP_BE16(theFCBPtr->fcbExtents16[ i ].startBlock, 0);
+			SET_SWAP_BE16(theFCBPtr->fcbExtents16[ i ].blockCount, 0);
 		}
 	}
 	
@@ -764,35 +764,35 @@ static OSErr ReleaseExtentsInExtentsBTre
 		if ( isHFSPlus )
 		{
 			// we're done if this is a different File ID
-			if ( myKeyPtr->hfsPlus.fileID != theFCBPtr->fcbFileID ||
+			if ( SWAP_BE32(myKeyPtr->hfsPlus.fileID) != theFCBPtr->fcbFileID ||
 				 myKeyPtr->hfsPlus.forkType != kDataForkType )
 					break;
 
 			for ( i = 0; i < kHFSPlusExtentDensity; ++i ) 
 			{
-				if ( myExtentRecord.hfsPlus[ i ].blockCount == 0 )
+				if ( SWAP_BE32(myExtentRecord.hfsPlus[ i ].blockCount) == 0 )
 					break;
 
 				(void) BlockDeallocate( myVCBPtr, 
-										myExtentRecord.hfsPlus[ i ].startBlock,
-										myExtentRecord.hfsPlus[ i ].blockCount );
+										SWAP_BE32(myExtentRecord.hfsPlus[ i ].startBlock),
+										SWAP_BE32(myExtentRecord.hfsPlus[ i ].blockCount) );
 			}
 		}
 		else
 		{
 			// we're done if this is a different File ID
-			if ( myKeyPtr->hfs.fileID != theFCBPtr->fcbFileID ||
+			if ( SWAP_BE32(myKeyPtr->hfs.fileID) != theFCBPtr->fcbFileID ||
 				 myKeyPtr->hfs.forkType != kDataForkType )
 					break;
 
 			for ( i = 0; i < kHFSExtentDensity; ++i ) 
 			{
-				if ( myExtentRecord.hfs[ i ].blockCount == 0 )
+				if ( SWAP_BE16(myExtentRecord.hfs[ i ].blockCount) == 0 )
 					break;
 
 				(void) BlockDeallocate( myVCBPtr, 
-										myExtentRecord.hfs[ i ].startBlock,
-										myExtentRecord.hfs[ i ].blockCount );
+										SWAP_BE16(myExtentRecord.hfs[ i ].startBlock),
+										SWAP_BE16(myExtentRecord.hfs[ i ].blockCount) );
 			}
 		}
 
@@ -825,7 +825,7 @@ static OSErr ValidateRecordLength( 	SGlo
 	
 	if ( isHFSPlus )
 	{
-		switch ( theRecPtr->recordType ) 
+		switch ( SWAP_BE16(theRecPtr->recordType) ) 
 		{
 		case kHFSPlusFolderRecord:
 			if ( theRecSize != sizeof( HFSPlusCatalogFolder ) )
@@ -858,7 +858,7 @@ static OSErr ValidateRecordLength( 	SGlo
 	}
 	else
 	{
-		switch ( theRecPtr->recordType ) 
+		switch ( SWAP_BE16(theRecPtr->recordType) ) 
 		{
 		case kHFSFolderRecord:
 			if ( theRecSize != sizeof(HFSCatalogFolder) )
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/SRepair.c diskdev_cmds/fsck_hfs.tproj/dfalib/SRepair.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/SRepair.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/SRepair.c	2003-06-30 11:30:21.000000000 +0200
@@ -354,8 +354,8 @@ static	OSErr	FixBTreeHeaderReservedField
 	err = GetBTreeHeader(GPtr, ResolveFCB(refNum), &header);
 	ReturnIfError( err );
 	
-	if ( (header.clumpSize % GPtr->calculatedVCB->vcbBlockSize) != 0 )
-		header.clumpSize = GPtr->calculatedVCB->vcbBlockSize;
+	if ( (SWAP_BE32(header.clumpSize) % GPtr->calculatedVCB->vcbBlockSize) != 0 )
+		SET_SWAP_BE32(header.clumpSize, GPtr->calculatedVCB->vcbBlockSize);
 		
 	header.reserved1	= 0;
 	header.btreeType	= kHFSBTreeType;  //	control file
@@ -419,7 +419,7 @@ static	OSErr	UpdBTM( SGlobPtr GPtr, shor
 			//	Locate the map record
 			recSize = GetRecordSize( calculatedBTCB, (BTNodeDescriptor *)node.buffer, recIndx );
 			btmP = (Ptr)GetRecordAddress( calculatedBTCB, (BTNodeDescriptor *)node.buffer, recIndx );
-			fLink	= ((NodeDescPtr)node.buffer)->fLink;
+			fLink	= SWAP_BE32(((NodeDescPtr)node.buffer)->fLink);
 			size	= ( recSize  > mapSize ) ? mapSize : recSize;
 				
 			CopyMemory( sbtmP, btmP, size );						//	update it
@@ -602,7 +602,7 @@ static	int	DelFThd( SGlobPtr GPtr, UInt3
 	
 	if ( result )	return ( IntError( GPtr, result ) );
 	
-	if ( (record.recordType != kHFSFileThreadRecord) && (record.recordType != kHFSPlusFileThreadRecord) )	//	quit if not a file thread
+	if ( (SWAP_BE16(record.recordType) != kHFSFileThreadRecord) && (SWAP_BE16(record.recordType) != kHFSPlusFileThreadRecord) )	//	quit if not a file thread
 		return ( IntError( GPtr, R_IntErr ) );
 	
 	//	Zero the record on disk
@@ -667,7 +667,7 @@ static	OSErr	FixDirThread( SGlobPtr GPtr
 	
 	if ( result )
 		return( IntError( GPtr, result ) );
-	if ( (record.recordType != kHFSFolderThreadRecord) && (record.recordType != kHFSPlusFolderThreadRecord) )			//	quit if not a directory thread
+	if ( (SWAP_BE16(record.recordType) != kHFSFolderThreadRecord) && (SWAP_BE16(record.recordType) != kHFSPlusFolderThreadRecord) )			//	quit if not a directory thread
 		return ( IntError( GPtr, R_IntErr ) );
 		
 	curLeafNode = calculatedBTCB->freeNodes;
@@ -680,17 +680,17 @@ static	OSErr	FixDirThread( SGlobPtr GPtr
 		nodeDescP = node.buffer;
 
 		// loop on number of records in node
-		for ( index = 0 ; index < nodeDescP->numRecords ; index++ )
+		for ( index = 0 ; index < SWAP_BE16(nodeDescP->numRecords) ; index++ )
 		{
 			GetRecordByIndex( calculatedBTCB, (NodeDescPtr)nodeDescP, index, (BTreeKey **)&keyP, &dataPtr, &recSize );
 			
-			recordType	= ((CatalogRecord *)dataPtr)->recordType;
-			folderID	= recordType == kHFSPlusFolderRecord ? ((HFSPlusCatalogFolder *)dataPtr)->folderID : ((HFSCatalogFolder *)dataPtr)->folderID;
+			recordType	= SWAP_BE16(((CatalogRecord *)dataPtr)->recordType);
+			folderID	= recordType == kHFSPlusFolderRecord ? SWAP_BE32(((HFSPlusCatalogFolder *)dataPtr)->folderID) : SWAP_BE32(((HFSCatalogFolder *)dataPtr)->folderID);
 			
 			// did we locate a directory record whode dirID match the the thread's key's parent dir ID?
 			if ( (folderID == did) && ( recordType == kHFSPlusFolderRecord || recordType == kHFSFolderRecord ) )
 			{
-				newParDirID	= recordType == kHFSPlusFolderRecord ? keyP->hfsPlus.parentID : keyP->hfs.parentID;
+				newParDirID	= recordType == kHFSPlusFolderRecord ? SWAP_BE32(keyP->hfsPlus.parentID) : SWAP_BE32(keyP->hfs.parentID);
 				keyName		= recordType == kHFSPlusFolderRecord ? (CatalogName *)&keyP->hfsPlus.nodeName : (CatalogName *)&keyP->hfs.nodeName;
 				CopyCatalogName( keyName, &catalogName, isHFSPlus );
 				break;
@@ -702,7 +702,7 @@ static	OSErr	FixDirThread( SGlobPtr GPtr
 			break;
 		}
 
-		curLeafNode = nodeDescP->fLink;	 // sibling of this leaf node
+		curLeafNode = SWAP_BE32(nodeDescP->fLink);	 // sibling of this leaf node
 		
 		(void) ReleaseNode(calculatedBTCB, &node);
 	}
@@ -719,14 +719,14 @@ static	OSErr	FixDirThread( SGlobPtr GPtr
 		{
 			HFSPlusCatalogThread	*largeCatalogThreadP	= (HFSPlusCatalogThread *) &record;
 			
-			largeCatalogThreadP->parentID = newParDirID;
+			SET_SWAP_BE32(largeCatalogThreadP->parentID, newParDirID);
 			CopyCatalogName( &catalogName, (CatalogName *) &largeCatalogThreadP->nodeName, isHFSPlus );
 		}
 		else
 		{
 			HFSCatalogThread	*smallCatalogThreadP	= (HFSCatalogThread *) &record;
 			
-			smallCatalogThreadP->parentID = newParDirID;
+			SET_SWAP_BE32(smallCatalogThreadP->parentID, newParDirID);
 			CopyCatalogName( &catalogName, (CatalogName *)&smallCatalogThreadP->nodeName, isHFSPlus );
 		}
 		
@@ -798,17 +798,17 @@ static	OSErr	UpdVal( SGlobPtr GPtr, Repa
 			if ( result )
 				return ( IntError( GPtr, result ) );
 				
-			if ( record.recordType == kHFSPlusFolderRecord )
+			if ( SWAP_BE16(record.recordType) == kHFSPlusFolderRecord )
 			{
-				if ( (UInt32)p->incorrect != record.hfsPlusFolder.valence)
+				if ( (UInt32)p->incorrect != SWAP_BE32(record.hfsPlusFolder.valence))
 					return ( IntError( GPtr, R_IntErr ) );
-				record.hfsPlusFolder.valence = (UInt32)p->correct;
+				SET_SWAP_BE32(record.hfsPlusFolder.valence, (UInt32)p->correct);
 			}
 			else
 			{
-				if ( (UInt16)p->incorrect != record.hfsFolder.valence )
+				if ( (UInt16)p->incorrect != SWAP_BE16(record.hfsFolder.valence) )
 					return ( IntError( GPtr, R_IntErr ) );
-				record.hfsFolder.valence = (UInt16)p->correct;
+				SET_SWAP_BE16(record.hfsFolder.valence, (UInt16)p->correct);
 			}
 				
 			result = ReplaceBTreeRecord( GPtr->calculatedCatalogFCB, &key, hint,\
@@ -850,37 +850,37 @@ static	OSErr	FixFinderFlags( SGlobPtr GP
 	if ( result )
 		return ( IntError( GPtr, result ) );
 
-	if ( record.recordType == kHFSPlusFolderRecord )
+	if ( SWAP_BE16(record.recordType) == kHFSPlusFolderRecord )
 	{
 		HFSPlusCatalogFolder	*largeCatalogFolderP	= (HFSPlusCatalogFolder *) &record;	
-		if ( (UInt16) p->incorrect != largeCatalogFolderP->userInfo.frFlags )
+		if ( (UInt16) p->incorrect != SWAP_BE16(largeCatalogFolderP->userInfo.frFlags) )
 		{
 			//	Another repar order may have affected the flags
 			if ( p->correct < p->incorrect )
-				largeCatalogFolderP->userInfo.frFlags &= ~((UInt16)p->maskBit);
+				SET_SWAP_BE16(largeCatalogFolderP->userInfo.frFlags, SWAP_BE16(largeCatalogFolderP->userInfo.frFlags) & ~((UInt16)p->maskBit));
 			else
-				largeCatalogFolderP->userInfo.frFlags |= (UInt16)p->maskBit;
+				SET_SWAP_BE16(largeCatalogFolderP->userInfo.frFlags, SWAP_BE16(largeCatalogFolderP->userInfo.frFlags) | (UInt16)p->maskBit);
 		}
 		else
 		{
-			largeCatalogFolderP->userInfo.frFlags = (UInt16)p->correct;
+			SET_SWAP_BE16(largeCatalogFolderP->userInfo.frFlags, (UInt16)p->correct);
 		}
 	//	largeCatalogFolderP->contentModDate = timeStamp;
 	}
 	else
 	{
 		HFSCatalogFolder	*smallCatalogFolderP	= (HFSCatalogFolder *) &record;	
-		if ( p->incorrect != smallCatalogFolderP->userInfo.frFlags )		//	do we know what we're doing?
+		if ( p->incorrect != SWAP_BE16(smallCatalogFolderP->userInfo.frFlags) )		//	do we know what we're doing?
 		{
 			//	Another repar order may have affected the flags
 			if ( p->correct < p->incorrect )
-				smallCatalogFolderP->userInfo.frFlags &= ~((UInt16)p->maskBit);
+				SET_SWAP_BE16(smallCatalogFolderP->userInfo.frFlags, SWAP_BE16(smallCatalogFolderP->userInfo.frFlags) & ~((UInt16)p->maskBit));
 			else
-				smallCatalogFolderP->userInfo.frFlags |= (UInt16)p->maskBit;
+				SET_SWAP_BE16(smallCatalogFolderP->userInfo.frFlags, SWAP_BE16(smallCatalogFolderP->userInfo.frFlags) | (UInt16)p->maskBit);
 		}
 		else
 		{
-			smallCatalogFolderP->userInfo.frFlags = (UInt16)p->correct;
+			SET_SWAP_BE16(smallCatalogFolderP->userInfo.frFlags, (UInt16)p->correct);
 		}
 		
 	//	smallCatalogFolderP->modifyDate = timeStamp;						// also update the modify date! -DJB
@@ -917,11 +917,11 @@ FixLinkCount(SGlobPtr GPtr, RepairOrderP
 	ClearMemory(&btIterator, sizeof(btIterator));
 	btIterator.hint.nodeNum = p->hint;
 	keyp = (HFSPlusCatalogKey*)&btIterator.key;
-	keyp->parentID = p->parid;
+	SET_SWAP_BE32(keyp->parentID, p->parid);
 	/* name was stored in UTF-8 */
 	(void) utf_decodestr(&p->name[1], p->name[0], keyp->nodeName.unicode, &len);
-	keyp->nodeName.length = len / 2;
-	keyp->keyLength = kHFSPlusCatalogKeyMinimumLength + len;
+	SET_SWAP_BE16(keyp->nodeName.length, len / 2);
+	SET_SWAP_BE16(keyp->keyLength, kHFSPlusCatalogKeyMinimumLength + len);
 
 	btRecord.bufferAddress = &rec;
 	btRecord.itemCount = 1;
@@ -932,15 +932,15 @@ FixLinkCount(SGlobPtr GPtr, RepairOrderP
 	if (result)
 		return (IntError(GPtr, result));
 
-	if (rec.recordType != kHFSPlusFileRecord)
+	if (SWAP_BE16(rec.recordType) != kHFSPlusFileRecord)
 		return (noErr);
 
-	if ((UInt32)p->correct != rec.hfsPlusFile.bsdInfo.special.linkCount) {
+	if ((UInt32)p->correct != SWAP_BE32(rec.hfsPlusFile.bsdInfo.special.linkCount)) {
 		if (GPtr->logLevel >= kDebugLog)
-		    printf("\t%s: fixing link count from %d to %d\n",
-		        &p->name[1], rec.hfsPlusFile.bsdInfo.special.linkCount, (int)p->correct);
+		    printf("\t%s: fixing link count from %u to %u\n",
+		        &p->name[1], SWAP_BE32(rec.hfsPlusFile.bsdInfo.special.linkCount), (int)p->correct);
 
-		rec.hfsPlusFile.bsdInfo.special.linkCount = (UInt32)p->correct;
+		SET_SWAP_BE32(rec.hfsPlusFile.bsdInfo.special.linkCount, (UInt32)p->correct);
 		result = BTReplaceRecord(fcb, &btIterator, &btRecord, recSize);
 		if (result)
 			return (IntError(GPtr, result));
@@ -1017,7 +1017,7 @@ FixIllegalNames( SGlobPtr GPtr, RepairOr
     }
 
 	isDirectory = false;
-    switch( record.recordType )
+    switch( SWAP_BE16(record.recordType) )
     {
         case kHFSFolderRecord:
         case kHFSPlusFolderRecord:	
@@ -1086,35 +1086,35 @@ FixBSDInfo(SGlobPtr GPtr, RepairOrderPtr
 	if (result)
 		return (IntError(GPtr, result));
 
-	if (rec.recordType != kHFSPlusFileRecord &&
-	    rec.recordType != kHFSPlusFolderRecord)
+	if (SWAP_BE16(rec.recordType) != kHFSPlusFileRecord &&
+	    SWAP_BE16(rec.recordType) != kHFSPlusFolderRecord)
 		return (noErr);
 
 	utf_encodestr(((HFSUniStr255 *)&p->name)->unicode,
-		((HFSUniStr255 *)&p->name)->length << 1, filename, &namelen);
+		SWAP_BE16(((HFSUniStr255 *)&p->name)->length) << 1, filename, &namelen);
 	filename[namelen] = '\0';
 
 	if (p->type == E_InvalidPermissions &&
-	    ((UInt16)p->incorrect == rec.hfsPlusFile.bsdInfo.fileMode)) {
+	    ((UInt16)p->incorrect == SWAP_BE16(rec.hfsPlusFile.bsdInfo.fileMode))) {
 		if (GPtr->logLevel >= kDebugLog)
 		    printf("\t\"%s\": fixing mode from %07o to %07o\n",
 			   filename, (int)p->incorrect, (int)p->correct);
 
-		rec.hfsPlusFile.bsdInfo.fileMode = (UInt16)p->correct;
+		SET_SWAP_BE16(rec.hfsPlusFile.bsdInfo.fileMode, (UInt16)p->correct);
 		result = BTReplaceRecord(fcb, &btIterator, &btRecord, recSize);
 	}
 
 	if (p->type == E_InvalidUID) {
-		if ((UInt32)p->incorrect == rec.hfsPlusFile.bsdInfo.ownerID) {
+		if ((UInt32)p->incorrect == SWAP_BE32(rec.hfsPlusFile.bsdInfo.ownerID)) {
 			if (GPtr->logLevel >= kDebugLog) {
 				printf("\t\"%s\": replacing UID %d with %d\n",
 				filename, (int)p->incorrect, (int)p->correct);
 			}
-			rec.hfsPlusFile.bsdInfo.ownerID = (UInt32)p->correct;
+			SET_SWAP_BE32(rec.hfsPlusFile.bsdInfo.ownerID, (UInt32)p->correct);
 		}
 		/* Fix group ID if neccessary */
-		if ((UInt32)p->incorrect == rec.hfsPlusFile.bsdInfo.groupID)
-			rec.hfsPlusFile.bsdInfo.groupID = (UInt32)p->correct;
+		if ((UInt32)p->incorrect == SWAP_BE32(rec.hfsPlusFile.bsdInfo.groupID))
+			SET_SWAP_BE32(rec.hfsPlusFile.bsdInfo.groupID, (UInt32)p->correct);
 		result = BTReplaceRecord(fcb, &btIterator, &btRecord, recSize);
 	}
 
@@ -1143,7 +1143,7 @@ DeleteUnlinkedFile(SGlobPtr GPtr, Repair
 	if (p->name[0] > 0) {
 		/* name was stored in UTF-8 */
 		(void) utf_decodestr(&p->name[1], p->name[0], name.ustr.unicode, &len);
-		name.ustr.length = len / 2;
+		SET_SWAP_BE16(name.ustr.length, len / 2);
 		cNameP = &name;
 	} else {
 		cNameP = NULL;
@@ -1183,12 +1183,12 @@ FixFileSize(SGlobPtr GPtr, RepairOrderPt
 	ClearMemory(&btIterator, sizeof(btIterator));
 	btIterator.hint.nodeNum = p->hint;
 	keyp = (HFSPlusCatalogKey*)&btIterator.key;
-	keyp->parentID = p->parid;
+	SET_SWAP_BE32(keyp->parentID, p->parid);
 
 	/* name was stored in UTF-8 */
 	(void) utf_decodestr(&p->name[1], p->name[0], keyp->nodeName.unicode, &len);
-	keyp->nodeName.length = len / 2;
-	keyp->keyLength = kHFSPlusCatalogKeyMinimumLength + len;
+	SET_SWAP_BE16(keyp->nodeName.length, len / 2);
+	SET_SWAP_BE16(keyp->keyLength, kHFSPlusCatalogKeyMinimumLength + len);
 
 	btRecord.bufferAddress = &rec;
 	btRecord.itemCount = 1;
@@ -1199,49 +1199,49 @@ FixFileSize(SGlobPtr GPtr, RepairOrderPt
 	if (result)
 		return (IntError(GPtr, result));
 
-	if (rec.recordType != kHFSPlusFileRecord)
+	if (SWAP_BE16(rec.recordType) != kHFSPlusFileRecord)
 		return (noErr);
 
 	if (p->type == E_PEOF) {
 		bytes = p->correct * (UInt64)GPtr->calculatedVCB->vcbBlockSize;
 		if ((p->forkType == kRsrcFork) &&
-		    ((UInt32)p->incorrect == rec.hfsPlusFile.resourceFork.totalBlocks)) {
+		    ((UInt32)p->incorrect == SWAP_BE32(rec.hfsPlusFile.resourceFork.totalBlocks))) {
 
-			rec.hfsPlusFile.resourceFork.totalBlocks = (UInt32)p->correct;
+			SET_SWAP_BE32(rec.hfsPlusFile.resourceFork.totalBlocks, (UInt32)p->correct);
 			replace = true;
 			/*
 			 * Make sure our new block count is large
 			 * enough to cover the current LEOF.  If
 			 * its not we must truncate the fork.
 			 */
-			if (rec.hfsPlusFile.resourceFork.logicalSize > bytes) {
-				rec.hfsPlusFile.resourceFork.logicalSize = bytes;
+			if (SWAP_BE64(rec.hfsPlusFile.resourceFork.logicalSize) > bytes) {
+				SET_SWAP_BE64(rec.hfsPlusFile.resourceFork.logicalSize, bytes);
 			}
 		} else if ((p->forkType == kDataFork) &&
-		           ((UInt32)p->incorrect == rec.hfsPlusFile.dataFork.totalBlocks)) {
+		           ((UInt32)p->incorrect == SWAP_BE32(rec.hfsPlusFile.dataFork.totalBlocks))) {
 
-			rec.hfsPlusFile.dataFork.totalBlocks = (UInt32)p->correct;
+			SET_SWAP_BE32(rec.hfsPlusFile.dataFork.totalBlocks, (UInt32)p->correct);
 			replace = true;
 			/*
 			 * Make sure our new block count is large
 			 * enough to cover the current LEOF.  If
 			 * its not we must truncate the fork.
 			 */
-			if (rec.hfsPlusFile.dataFork.logicalSize > bytes) {
-				rec.hfsPlusFile.dataFork.logicalSize = bytes;
+			if (SWAP_BE64(rec.hfsPlusFile.dataFork.logicalSize) > bytes) {
+				SET_SWAP_BE64(rec.hfsPlusFile.dataFork.logicalSize, bytes);
 			}
 		}
 	} else /* E_LEOF */ {
 		if ((p->forkType == kRsrcFork) &&
-		    (p->incorrect == rec.hfsPlusFile.resourceFork.logicalSize)) {
+		    (p->incorrect == SWAP_BE64(rec.hfsPlusFile.resourceFork.logicalSize))) {
 
-			rec.hfsPlusFile.resourceFork.logicalSize = p->correct;
+			SET_SWAP_BE64(rec.hfsPlusFile.resourceFork.logicalSize, p->correct);
 			replace = true;
 
 		} else if ((p->forkType == kDataFork) &&
-		           (p->incorrect == rec.hfsPlusFile.dataFork.logicalSize)) {
+		           (p->incorrect == SWAP_BE64(rec.hfsPlusFile.dataFork.logicalSize))) {
 
-			rec.hfsPlusFile.dataFork.logicalSize = p->correct;
+			SET_SWAP_BE64(rec.hfsPlusFile.dataFork.logicalSize, p->correct);
 			replace = true;
 		}
 	}
@@ -1291,8 +1291,8 @@ static	OSErr	FixEmbededVolDescription( S
 	ReturnIfError( err );
 	mdb = (HFSMasterDirectoryBlock *) block.buffer;
 	
-	mdb->drAlBlSt			= desc->drAlBlSt;
-	mdb->drEmbedSigWord		= desc->drEmbedSigWord;
+	SET_SWAP_BE16(mdb->drAlBlSt, desc->drAlBlSt);
+	SET_SWAP_BE16(mdb->drEmbedSigWord, desc->drEmbedSigWord);
 	mdb->drEmbedExtent.startBlock	= desc->drEmbedExtent.startBlock;
 	mdb->drEmbedExtent.blockCount	= desc->drEmbedExtent.blockCount;
 	
@@ -1304,8 +1304,8 @@ static	OSErr	FixEmbededVolDescription( S
 	ReturnIfError( err );
 	mdb = (HFSMasterDirectoryBlock *) block.buffer;
 	
-	mdb->drAlBlSt			= desc->drAlBlSt;
-	mdb->drEmbedSigWord		= desc->drEmbedSigWord;
+	SET_SWAP_BE16(mdb->drAlBlSt, desc->drAlBlSt);
+	SET_SWAP_BE16(mdb->drEmbedSigWord, desc->drEmbedSigWord);
 	mdb->drEmbedExtent.startBlock	= desc->drEmbedExtent.startBlock;
 	mdb->drEmbedExtent.blockCount	= desc->drEmbedExtent.blockCount;
 	
@@ -1337,7 +1337,9 @@ Output:
 
 static	OSErr	FixWrapperExtents( SGlobPtr GPtr, RepairOrderPtr p )
 {
+#if __APPLE__
 #pragma unused (p)
+#endif
 
 	OSErr			err;
 	UInt64			totalSectors;
@@ -1355,8 +1357,8 @@ static	OSErr	FixWrapperExtents( SGlobPtr
 	mdb = (HFSMasterDirectoryBlock	*) block.buffer;
 
 	/* Fix the wrapper catalog's first (and only) extent */
-	mdb->drCTExtRec[0].startBlock = mdb->drXTExtRec[0].startBlock +
-	                                mdb->drXTExtRec[0].blockCount;
+	SET_SWAP_BE16(mdb->drCTExtRec[0].startBlock, SWAP_BE16(mdb->drXTExtRec[0].startBlock) +
+	                                SWAP_BE16(mdb->drXTExtRec[0].blockCount));
 	
 	err = ReleaseVolumeBlock(vcb, &block, kForceWriteBlock);
 	ReturnIfError( err );
@@ -1367,8 +1369,8 @@ static	OSErr	FixWrapperExtents( SGlobPtr
 	ReturnIfError( err );
 	mdb = (HFSMasterDirectoryBlock	*) block.buffer;
 	
-	mdb->drCTExtRec[0].startBlock = mdb->drXTExtRec[0].startBlock +
-	                                mdb->drXTExtRec[0].blockCount;
+	SET_SWAP_BE16(mdb->drCTExtRec[0].startBlock, SWAP_BE16(mdb->drXTExtRec[0].startBlock) +
+	                                SWAP_BE16(mdb->drXTExtRec[0].blockCount));
 	
 	err = ReleaseVolumeBlock(vcb, &block, kForceWriteBlock);
 	
@@ -1534,7 +1536,7 @@ static	OSErr	FixOrphanedFiles ( SGlobPtr
 		CopyMemory( &btcb->lastIterator, &savedIterator, sizeof(BTreeIterator) );
 	
 		selCode		= 1;														//	 kNextRecord			
-		recordType	= record.recordType;
+		recordType	= SWAP_BE16(record.recordType);
 		
 		switch( recordType )
 		{
@@ -1551,15 +1553,15 @@ static	OSErr	FixOrphanedFiles ( SGlobPtr
 				
 				(void) CheckForStop( GPtr );										//	rotate cursor
 
-				parentID	= isHFSPlus == true ? foundKey.hfsPlus.parentID : foundKey.hfs.parentID;
+				parentID	= isHFSPlus == true ? SWAP_BE32(foundKey.hfsPlus.parentID) : SWAP_BE32(foundKey.hfs.parentID);
 				threadHint	= hint;
 				
 				switch( recordType )
 				{
-					case kHFSFolderRecord:		cNodeID		= record.hfsFolder.folderID;		break;
-					case kHFSFileRecord:		cNodeID		= record.hfsFile.fileID;			break;
-					case kHFSPlusFolderRecord:	cNodeID		= record.hfsPlusFolder.folderID;	break;
-					case kHFSPlusFileRecord:	cNodeID		= record.hfsPlusFile.fileID;		break;
+					case kHFSFolderRecord:		cNodeID		= SWAP_BE32(record.hfsFolder.folderID);		break;
+					case kHFSFileRecord:		cNodeID		= SWAP_BE32(record.hfsFile.fileID);			break;
+					case kHFSPlusFolderRecord:	cNodeID		= SWAP_BE32(record.hfsPlusFolder.folderID);	break;
+					case kHFSPlusFileRecord:	cNodeID		= SWAP_BE32(record.hfsPlusFile.fileID);		break;
 				}
 
 				//-- Build the key for the file thread
@@ -1589,11 +1591,11 @@ static	OSErr	FixOrphanedFiles ( SGlobPtr
 							UInt16 recSize;
 							
 							ClearMemory( (Ptr)&threadData, sizeof(HFSPlusCatalogThread) );
-							threadData.recordType	= threadRecordType;
-							threadData.parentID		= parentID;
+							SET_SWAP_BE16(threadData.recordType, threadRecordType);
+							SET_SWAP_BE32(threadData.parentID, parentID);
 							CopyCatalogName( (CatalogName *)&foundKey.hfsPlus.nodeName,
 										(CatalogName *)&threadData.nodeName, isHFSPlus );
-							recSize = 10 + (foundKey.hfsPlus.nodeName.length * 2);
+							recSize = 10 + (SWAP_BE16(foundKey.hfsPlus.nodeName.length) * 2);
 							err = InsertBTreeRecord( GPtr->calculatedCatalogFCB, &key,
 										&threadData, recSize, &threadHint );
 
@@ -1603,8 +1605,8 @@ static	OSErr	FixOrphanedFiles ( SGlobPtr
 							HFSCatalogThread		threadData;
 							
 							ClearMemory( (Ptr)&threadData, sizeof(HFSCatalogThread) );
-							threadData.recordType	= threadRecordType;
-							threadData.parentID		= parentID;
+							SET_SWAP_BE16(threadData.recordType, threadRecordType);
+							SET_SWAP_BE32(threadData.parentID, parentID);
 							CopyCatalogName( (CatalogName *)&foundKey.hfs.nodeName, (CatalogName *)&threadData.nodeName, isHFSPlus );
 							err = InsertBTreeRecord( GPtr->calculatedCatalogFCB, &key, &threadData, sizeof(HFSCatalogThread), &threadHint );
 						}
@@ -1625,9 +1627,9 @@ static	OSErr	FixOrphanedFiles ( SGlobPtr
 				
 				//	Find the catalog record, if it does not exist, delete the existing thread.
 				if ( isHFSPlus )
-					BuildCatalogKey( record.hfsPlusThread.parentID, (const CatalogName *)&record.hfsPlusThread.nodeName, isHFSPlus, &key );
+					BuildCatalogKey( SWAP_BE32(record.hfsPlusThread.parentID), (const CatalogName *)&record.hfsPlusThread.nodeName, isHFSPlus, &key );
 				else
-					BuildCatalogKey( record.hfsThread.parentID, (const CatalogName *)&record.hfsThread.nodeName, isHFSPlus, &key );
+					BuildCatalogKey( SWAP_BE32(record.hfsThread.parentID), (const CatalogName *)&record.hfsThread.nodeName, isHFSPlus, &key );
 				
 				err = SearchBTreeRecord ( GPtr->calculatedCatalogFCB, &key, kNoHint, &tempKey, &record2, &recordSize, &hint2 );
 				if ( err != noErr )
@@ -1638,7 +1640,7 @@ static	OSErr	FixOrphanedFiles ( SGlobPtr
 				break;
 				
 			default:
-				M_DebugStr("\p Unknown record type");
+				M_DebugStr(" Unknown record type");
 				break;
 
 		}
@@ -1673,12 +1675,12 @@ static	OSErr	RepairReservedBTreeFields (
 	
 	do
 	{
-		switch( record.recordType )
+		switch( SWAP_BE16(record.recordType) )
 		{
 			case kHFSPlusFolderRecord:
-				if ( record.hfsPlusFolder.flags != 0 )
+				if ( SWAP_BE16(record.hfsPlusFolder.flags) != 0 )
 				{
-					record.hfsPlusFolder.flags = 0;
+					SET_SWAP_BE16(record.hfsPlusFolder.flags, 0);
 					err = ReplaceBTreeRecord( GPtr->calculatedCatalogFCB, &foundKey, hint, &record, recordSize, &hint );
 				}
 				break;
@@ -1687,17 +1689,17 @@ static	OSErr	RepairReservedBTreeFields (
 				//	Note: bit 7 (mask 0x80) of flags is unused in HFS or HFS Plus.  However, Inside Macintosh: Files
 				//	describes it as meaning the file record is in use.  Some non-Apple implementations end up setting
 				//	this bit, so we just ignore it.
-				if ( ( record.hfsPlusFile.flags  & (UInt16) ~(0X83) ) != 0 )
+				if ( ( SWAP_BE16(record.hfsPlusFile.flags)  & (UInt16) ~(0X83) ) != 0 )
 				{
-					record.hfsPlusFile.flags &= 0X83;
+					SET_SWAP_BE16(record.hfsPlusFile.flags, SWAP_BE16(record.hfsPlusFile.flags) & 0X83);
 					err = ReplaceBTreeRecord( GPtr->calculatedCatalogFCB, &foundKey, hint, &record, recordSize, &hint );
 				}
 				break;
 
 			case kHFSFolderRecord:
-				if ( record.hfsFolder.flags != 0 )
+				if ( SWAP_BE16(record.hfsFolder.flags) != 0 )
 				{
-					record.hfsFolder.flags = 0;
+					SET_SWAP_BE16(record.hfsFolder.flags, 0);
 					err = ReplaceBTreeRecord( GPtr->calculatedCatalogFCB, &foundKey, hint, &record, recordSize, &hint );
 				}
 				break;
@@ -1718,13 +1720,13 @@ static	OSErr	RepairReservedBTreeFields (
 				//	describes it as meaning the file record is in use.  Some non-Apple implementations end up setting
 				//	this bit, so we just ignore it.
 				if ( 	( ( record.hfsFile.flags  & (UInt8) ~(0X83) ) != 0 )
-					||	( record.hfsFile.dataStartBlock != 0 )	
-					||	( record.hfsFile.rsrcStartBlock != 0 )	
+					||	( SWAP_BE16(record.hfsFile.dataStartBlock) != 0 )	
+					||	( SWAP_BE16(record.hfsFile.rsrcStartBlock) != 0 )	
 					||	( record.hfsFile.reserved != 0 )			)
 				{
 					record.hfsFile.flags			&= 0X83;
-					record.hfsFile.dataStartBlock	= 0;
-					record.hfsFile.rsrcStartBlock	= 0;
+					SET_SWAP_BE16(record.hfsFile.dataStartBlock, 0);
+					SET_SWAP_BE16(record.hfsFile.rsrcStartBlock, 0);
 					record.hfsFile.reserved		= 0;
 					err = ReplaceBTreeRecord( GPtr->calculatedCatalogFCB, &foundKey, hint, &record, recordSize, &hint );
 				}
@@ -1789,7 +1791,7 @@ OSErr	ProcessFileExtents( SGlobPtr GPtr,
 				err = AllocExt( GPtr, extentStartBlock, extentBlockCount );
 				if ( err != noErr )
 				{
-					M_DebugStr("\p Problem Allocating Extents");
+					M_DebugStr(" Problem Allocating Extents");
 					break;
 				}
 			}
@@ -1929,10 +1931,10 @@ static	OSErr	FixBloatedThreadRecords( SG
 	{
 		if ( ++i > 10 ) { (void) CheckForStop( GPtr ); i = 0; }					//	Spin the cursor every 10 entries
 		
-		if (  (recordSize == sizeof(HFSPlusCatalogThread)) && ((record.recordType == kHFSPlusFolderThreadRecord) || (record.recordType == kHFSPlusFileThreadRecord)) )
+		if (  (recordSize == sizeof(HFSPlusCatalogThread)) && ((SWAP_BE16(record.recordType) == kHFSPlusFolderThreadRecord) || (SWAP_BE16(record.recordType) == kHFSPlusFileThreadRecord)) )
 		{
 			// HFS Plus has varaible sized threads so adjust to actual length
-			recordSize -= ( sizeof(record.hfsPlusThread.nodeName.unicode) - (record.hfsPlusThread.nodeName.length * sizeof(UniChar)) );
+			recordSize -= ( sizeof(record.hfsPlusThread.nodeName.unicode) - (SWAP_BE16(record.hfsPlusThread.nodeName.length) * sizeof(UniChar)) );
 
 			err = ReplaceBTreeRecord( GPtr->calculatedCatalogFCB, &foundKey, hint, &record, recordSize, &hint );
 			ReturnIfError( err );
@@ -1958,10 +1960,10 @@ FixMissingThreadRecords( SGlob *GPtr )
 	UInt16                dataSize;
 
 	for (mtp = GPtr->missingThreadList; mtp != NULL; mtp = mtp->link) {
-		if (mtp->threadID == 0 || mtp->thread.parentID == 0)
+		if (mtp->threadID == 0 || SWAP_BE32(mtp->thread.parentID) == 0)
 			continue;
 
-		dataSize = 10 + (mtp->thread.nodeName.length * 2);
+		dataSize = 10 + (SWAP_BE16(mtp->thread.nodeName.length) * 2);
 		btRecord.bufferAddress = (void *)&mtp->thread;
 		btRecord.itemSize = dataSize;
 		btRecord.itemCount = 1;
@@ -1983,18 +1985,18 @@ GetObjectID( CatalogRecord * theRecPtr )
 {
     HFSCatalogNodeID	myObjID;
     
-	switch ( theRecPtr->recordType ) {
+	switch ( SWAP_BE16(theRecPtr->recordType) ) {
 	case kHFSPlusFolderRecord:
-        myObjID = theRecPtr->hfsPlusFolder.folderID;
+        myObjID = SWAP_BE32(theRecPtr->hfsPlusFolder.folderID);
 		break;
 	case kHFSPlusFileRecord:
-        myObjID = theRecPtr->hfsPlusFile.fileID;
+        myObjID = SWAP_BE32(theRecPtr->hfsPlusFile.fileID);
 		break;
 	case kHFSFolderRecord:
-        myObjID = theRecPtr->hfsFolder.folderID;
+        myObjID = SWAP_BE32(theRecPtr->hfsFolder.folderID);
 		break;
 	case kHFSFileRecord:
-        myObjID = theRecPtr->hfsFile.fileID;
+        myObjID = SWAP_BE32(theRecPtr->hfsFile.fileID);
 		break;
 	default:
         myObjID = 0;
@@ -2021,17 +2023,17 @@ BuildThreadRec( CatalogKey * theKeyPtr, 
 
 		size = sizeof(HFSPlusCatalogThread);
 		if ( isDirectory )
-			rec->recordType = kHFSPlusFolderThreadRecord;
+			SET_SWAP_BE16(rec->recordType, kHFSPlusFolderThreadRecord);
 		else
-			rec->recordType = kHFSPlusFileThreadRecord;
+			SET_SWAP_BE16(rec->recordType, kHFSPlusFileThreadRecord);
 		rec->reserved = 0;
 		rec->parentID = key->parentID;			
 		bcopy(&key->nodeName, &rec->nodeName,
-			sizeof(UniChar) * (key->nodeName.length + 1));
+			sizeof(UniChar) * (SWAP_BE16(key->nodeName.length) + 1));
 
 		/* HFS Plus has varaible sized thread records */
 		size -= (sizeof(rec->nodeName.unicode) -
-			  (rec->nodeName.length * sizeof(UniChar)));
+			  (SWAP_BE16(rec->nodeName.length) * sizeof(UniChar)));
 	} 
 	else /* HFS standard */ {
 		HFSCatalogKey *key = (HFSCatalogKey *)theKeyPtr;
@@ -2040,9 +2042,9 @@ BuildThreadRec( CatalogKey * theKeyPtr, 
 		size = sizeof(HFSCatalogThread);
 		bzero(rec, size);
 		if ( isDirectory )
-			rec->recordType = kHFSFolderThreadRecord;
+			SET_SWAP_BE16(rec->recordType, kHFSFolderThreadRecord);
 		else
-			rec->recordType = kHFSFileThreadRecord;
+			SET_SWAP_BE16(rec->recordType, kHFSFileThreadRecord);
 		rec->parentID = key->parentID;
 		bcopy(key->nodeName, rec->nodeName, key->nodeName[0]+1);
 	}
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/SRuntime.h diskdev_cmds/fsck_hfs.tproj/dfalib/SRuntime.h
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/SRuntime.h	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/SRuntime.h	2003-04-25 13:30:00.000000000 +0200
@@ -26,7 +26,7 @@
 #ifndef __SRUNTIME__
 #define __SRUNTIME__
 
-#if BSD
+#if __unix__
 
 #include <sys/types.h>
 #include <stdlib.h>
@@ -35,6 +35,7 @@
 #include <stdarg.h>
 
 #include <hfs/hfs_format.h>
+#include "hfs_endian.h"
 
 #else
 
@@ -45,7 +46,7 @@
 
 #endif
 
-#if BSD
+#if __unix__
 /* Classic Mac OS Types */
 typedef int8_t		SInt8;
 typedef int16_t		SInt16;
@@ -383,7 +384,7 @@ extern OSStatus  SetFileBlockSize (SFCB 
 
 
 
-#if BSD
+#if __unix__
 
 #define AllocateMemory(size)		malloc((size_t)(size))
 #define	AllocateClearMemory(size)	calloc(1,(size_t)(size))
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/SStubs.c diskdev_cmds/fsck_hfs.tproj/dfalib/SStubs.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/SStubs.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/SStubs.c	2003-04-24 16:17:07.000000000 +0200
@@ -91,6 +91,7 @@ OSErr MemError()
 
 void DebugStr(ConstStr255Param debuggerMsg)
 {
+	puts(debuggerMsg);
 }
 
 
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/SUtils.c diskdev_cmds/fsck_hfs.tproj/dfalib/SUtils.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/SUtils.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/SUtils.c	2003-06-30 11:30:48.000000000 +0200
@@ -32,6 +32,7 @@
 */
 
 #include "Scavenger.h"
+#include "hfs_endian.h"
 
 		
 /*
@@ -40,7 +41,7 @@
  * Encode a UCS-2 (Unicode) string to UTF-8
  */
 int utf_encodestr(ucsp, ucslen, utf8p, utf8len)
-	const u_int16_t * ucsp;
+	const u_big_int16_t * ucsp;
 	size_t ucslen;
 	u_int8_t * utf8p;
 	size_t * utf8len;
@@ -53,7 +54,7 @@ int utf_encodestr(ucsp, ucslen, utf8p, u
 	charcnt = ucslen / 2;
 
 	while (charcnt-- > 0) {
-		ucs_ch = *ucsp++;
+		ucs_ch = SWAP_BE16(*ucsp++);
 
 		if (ucs_ch < 0x0080) {
 			if (ucs_ch == '\0')
@@ -85,10 +86,10 @@ int
 utf_decodestr(utf8p, utf8len, ucsp, ucslen)
 	const u_int8_t* utf8p;
 	size_t utf8len;
-	u_int16_t* ucsp;
+	u_big_int16_t* ucsp;
 	size_t *ucslen;
 {
-	u_int16_t* bufstart;
+	u_big_int16_t* bufstart;
 	u_int16_t ucs_ch;
 	u_int8_t byte;
 
@@ -97,7 +98,7 @@ utf_decodestr(utf8p, utf8len, ucsp, ucsl
 	while (utf8len-- > 0 && (byte = *utf8p++) != '\0') {
 		/* check for ascii */
 		if (byte < 0x80) {
-			*ucsp++ = byte;
+			SET_SWAP_BE16(*ucsp++, byte);
 			continue;
 		}
 
@@ -135,7 +136,7 @@ utf_decodestr(utf8p, utf8len, ucsp, ucsl
 
 		utf8len--;
 		ucs_ch += (byte & 0x3F);  
-		*ucsp++ = ucs_ch;
+		SET_SWAP_BE16(*ucsp++, ucs_ch);
 	}
 
 	*ucslen = (u_int8_t*)ucsp - (u_int8_t*)bufstart;
@@ -240,7 +241,7 @@ int AllocBTN( SGlobPtr GPtr, SInt16 file
 	BTreeControlBlock	*calculatedBTCB	= GetBTreeControlBlock( fileRefNum );
 
 	//	Allocate the node 
-	if ( calculatedBTCB->refCon == NULL )
+	if ( calculatedBTCB->refCon == 0 )
 		return( noErr );
 		
 	byteP = ( (BTreeExtensionsRec*)calculatedBTCB->refCon)->BTCBMPtr + (nodeNumber / 8 );	//	ptr to starting byte
@@ -274,12 +275,12 @@ OSErr	GetBTreeHeader( SGlobPtr GPtr, SFC
 
 	headerPtr = (char*)block.buffer + sizeof(BTNodeDescriptor);
 	CopyMemory(headerPtr, header, sizeof(BTHeaderRec));
-	
+
 	err = ReleaseFileBlock (fcb, &block, kReleaseBlock);
 	ReturnIfError(err);
 	
 	/* Validate Node Size */
-	switch (header->nodeSize) {
+	switch (SWAP_BE16(header->nodeSize)) {
 		case   512:
 		case  1024:
 		case  2048:
@@ -353,7 +354,7 @@ void	InvalidateCalculatedVolumeBitMap( S
 //				GPtr->realVCB			Real in-memory vcb
 //------------------------------------------------------------------------------
 
-#if !BSD	
+#if !__unix__
 OSErr GetVolumeFeatures( SGlobPtr GPtr )
 {
 	OSErr					err;
@@ -398,7 +399,7 @@ OSErr GetVolumeFeatures( SGlobPtr GPtr )
 Routine:	ClearMemory	-	clear a block of memory
 
 -------------------------------------------------------------------------------*/
-#if !BSD
+#if !__unix__
 void ClearMemory( void* start, UInt32 length )
 {
 	UInt32		zero = 0;
@@ -525,19 +526,19 @@ CopyCatalogName(const CatalogName *srcNa
 	if ( srcName == NULL )
 	{
 		if ( dstName != NULL )
-			dstName->ustr.length = 0;	// set length byte to zero (works for both unicode and pascal)		
+			SET_SWAP_BE16(dstName->ustr.length, 0);	// set length byte to zero (works for both unicode and pascal)		
 		return;
 	}
 	
 	if (isHFSPLus)
-		length = sizeof(UniChar) * (srcName->ustr.length + 1);
+		length = sizeof(UniChar) * (SWAP_BE16(srcName->ustr.length) + 1);
 	else
 		length = sizeof(UInt8) + srcName->pstr[0];
 
 	if ( length > 1 )
 		CopyMemory(srcName, dstName, length);
 	else
-		dstName->ustr.length = 0;	// set length byte to zero (works for both unicode and pascal)		
+		SET_SWAP_BE16(dstName->ustr.length, 0);	// set length byte to zero (works for both unicode and pascal)		
 }
 
 
@@ -545,7 +546,7 @@ UInt32
 CatalogNameLength(const CatalogName *name, Boolean isHFSPlus)
 {
 	if (isHFSPlus)
-		return name->ustr.length;
+		return SWAP_BE16(name->ustr.length);
 	else
 		return name->pstr[0];
 }
@@ -576,20 +577,20 @@ BuildCatalogKey(HFSCatalogNodeID parentI
 {
 	if ( isHFSPlus )
 	{
-		key->hfsPlus.keyLength		= kHFSPlusCatalogKeyMinimumLength;	// initial key length (4 + 2)
-		key->hfsPlus.parentID			= parentID;		// set parent ID
-		key->hfsPlus.nodeName.length	= 0;			// null CName length
+		SET_SWAP_BE16(key->hfsPlus.keyLength, kHFSPlusCatalogKeyMinimumLength);	// initial key length (4 + 2)
+		SET_SWAP_BE32(key->hfsPlus.parentID, parentID);		// set parent ID
+		SET_SWAP_BE16(key->hfsPlus.nodeName.length, 0);			// null CName length
 		if ( cName != NULL )
 		{
 			CopyCatalogName(cName, (CatalogName *) &key->hfsPlus.nodeName, isHFSPlus);
-			key->hfsPlus.keyLength += sizeof(UniChar) * cName->ustr.length;	// add CName size to key length
+			SET_SWAP_BE16(key->hfsPlus.keyLength, SWAP_BE16(key->hfsPlus.keyLength) + sizeof(UniChar) * SWAP_BE16(cName->ustr.length));	// add CName size to key length
 		}
 	}
 	else
 	{
 		key->hfs.keyLength	= kHFSCatalogKeyMinimumLength;	// initial key length (1 + 4 + 1)
 		key->hfs.reserved		= 0;				// clear unused byte
-		key->hfs.parentID		= parentID;			// set parent ID
+		SET_SWAP_BE32(key->hfs.parentID, parentID);			// set parent ID
 		key->hfs.nodeName[0]	= 0;				// null CName length
 		if ( cName != NULL )
 		{
@@ -650,9 +651,9 @@ OSErr	ValidVolumeHeader( HFSPlusVolumeHe
 {
 	OSErr	err;
 	
-	if ( volumeHeader->signature == kHFSPlusSigWord && volumeHeader->version == kHFSPlusVersion )
+	if ( SWAP_BE16(volumeHeader->signature) == kHFSPlusSigWord && SWAP_BE16(volumeHeader->version) == kHFSPlusVersion )
 	{
-		if ( (volumeHeader->blockSize != 0) && ((volumeHeader->blockSize & 0x01FF) == 0) )			//	non zero multiple of 512
+		if ( (SWAP_BE32(volumeHeader->blockSize) != 0) && ((SWAP_BE32(volumeHeader->blockSize) & 0x01FF) == 0) )			//	non zero multiple of 512
 			err = noErr;
 		else
 			err = badMDBErr;							//ее	I want badVolumeHeaderErr in Errors.i
@@ -701,7 +702,7 @@ void InitBTreeHeader (UInt32 fileSize, U
 	ndp = (BTNodeDescriptor*) buffer;	// point to node descriptor
 
 	ndp->kind = kBTHeaderNode;		// this node contains the B-tree header
-	ndp->numRecords = 3;			// there are 3 records (header, map, and user)
+	SET_SWAP_BE16(ndp->numRecords, 3);	// there are 3 records (header, map, and user)
 
 	if (nodeCount > nodeBitsInHeader)		// do we need additional map nodes?
 	{
@@ -710,11 +711,11 @@ void InitBTreeHeader (UInt32 fileSize, U
 		nodeBitsInMapNode = 8 * (nodeSize - sizeof(BTNodeDescriptor) - 2*sizeof(SInt16) - 2);	//ее why (-2) at end???
 
 		if (recordCount > 0)			// catalog B-tree?
-			ndp->fLink = 2;			// link points to initial map node
+			SET_SWAP_BE32(ndp->fLink, 2);			// link points to initial map node
 											//ее Assumes all records will fit in one node.  It would be better
 											//ее to put the map node(s) first, then the records.
 		else
-			ndp->fLink = 1;			// link points to initial map node
+			SET_SWAP_BE32(ndp->fLink, 1);			// link points to initial map node
 
 		*mapNodes = (nodeCount - nodeBitsInHeader + (nodeBitsInMapNode - 1)) / nodeBitsInMapNode;
 		usedNodes += *mapNodes;
@@ -727,19 +728,19 @@ void InitBTreeHeader (UInt32 fileSize, U
 	{
 		++usedNodes;								// one more node will be used
 
-		bth->treeDepth = 1;							// tree depth is one level (leaf)
-		bth->rootNode  = 1;							// root node is also leaf
-		bth->firstLeafNode = 1;						// first leaf node
-		bth->lastLeafNode = 1;						// last leaf node
+		SET_SWAP_BE16(bth->treeDepth, 1);							// tree depth is one level (leaf)
+		SET_SWAP_BE32(bth->rootNode, 1);							// root node is also leaf
+		SET_SWAP_BE32(bth->firstLeafNode, 1);						// first leaf node
+		SET_SWAP_BE32(bth->lastLeafNode, 1);						// last leaf node
 	}
 
-	bth->attributes	  = attributes;					// flags for 16-bit key lengths, and variable sized index keys
-	bth->leafRecords  = recordCount;				// total number of data records
-	bth->nodeSize	  = nodeSize;					// size of a node
-	bth->maxKeyLength = keySize;					// maximum length of a key
-	bth->totalNodes	  = nodeCount;					// total number of nodes
-	bth->freeNodes	  = nodeCount - usedNodes;		// number of free nodes
-	bth->clumpSize	  = clumpSize;					//
+	SET_SWAP_BE32(bth->attributes, attributes);					// flags for 16-bit key lengths, and variable sized index keys
+	SET_SWAP_BE32(bth->leafRecords, recordCount);				// total number of data records
+	SET_SWAP_BE16(bth->nodeSize, nodeSize);					// size of a node
+	SET_SWAP_BE16(bth->maxKeyLength, keySize);					// maximum length of a key
+	SET_SWAP_BE32(bth->totalNodes, nodeCount);					// total number of nodes
+	SET_SWAP_BE32(bth->freeNodes, nodeCount - usedNodes);		// number of free nodes
+	SET_SWAP_BE32(bth->clumpSize, clumpSize);					//
 //	bth->btreeType	  = 0;						// 0 = meta data B-tree
 
 
@@ -914,9 +915,9 @@ OSErr	FlushVolumeControlBlock( SVCB *vcb
 			if ( err == noErr )
 			{
 				mdb = (HFSMasterDirectoryBlock	*) mdb_block.buffer;
-				if ( mdb->drCrDate != vcb->vcbCreateDate )  // The creation date changed
+				if ( SWAP_BE32(mdb->drCrDate) != vcb->vcbCreateDate )  // The creation date changed
 				{
-					mdb->drCrDate = vcb->vcbCreateDate;
+					SET_SWAP_BE32(mdb->drCrDate, vcb->vcbCreateDate);
 					(void) ReleaseVolumeBlock(vcb, &mdb_block, kForceWriteBlock);
 				}
 				else
@@ -926,53 +927,53 @@ OSErr	FlushVolumeControlBlock( SVCB *vcb
 			}
 		}
 
-		volumeHeader->attributes		= vcb->vcbAttributes;
-		volumeHeader->lastMountedVersion = kFSCKMountVersion;
-		volumeHeader->createDate		= vcb->vcbCreateDate;  // NOTE: local time, not GMT!
-		volumeHeader->modifyDate		= vcb->vcbModifyDate;
-		volumeHeader->backupDate		= vcb->vcbBackupDate;
-		volumeHeader->checkedDate		= vcb->vcbCheckedDate;
-		volumeHeader->fileCount			= vcb->vcbFileCount;
-		volumeHeader->folderCount		= vcb->vcbFolderCount;
-		volumeHeader->blockSize			= vcb->vcbBlockSize;
-		volumeHeader->totalBlocks		= vcb->vcbTotalBlocks;
-		volumeHeader->freeBlocks		= vcb->vcbFreeBlocks;
-		volumeHeader->nextAllocation		= vcb->vcbNextAllocation;
-		volumeHeader->rsrcClumpSize		= vcb->vcbRsrcClumpSize;
-		volumeHeader->dataClumpSize		= vcb->vcbDataClumpSize;
-		volumeHeader->nextCatalogID		= vcb->vcbNextCatalogID;
-		volumeHeader->writeCount		= vcb->vcbWriteCount;
-		volumeHeader->encodingsBitmap		= vcb->vcbEncodingsBitmap;
+		SET_SWAP_BE32(volumeHeader->attributes, vcb->vcbAttributes);
+		SET_SWAP_BE32(volumeHeader->lastMountedVersion, kFSCKMountVersion);
+		SET_SWAP_BE32(volumeHeader->createDate, vcb->vcbCreateDate);  // NOTE: local time, not GMT!
+		SET_SWAP_BE32(volumeHeader->modifyDate, vcb->vcbModifyDate);
+		SET_SWAP_BE32(volumeHeader->backupDate, vcb->vcbBackupDate);
+		SET_SWAP_BE32(volumeHeader->checkedDate, vcb->vcbCheckedDate);
+		SET_SWAP_BE32(volumeHeader->fileCount, vcb->vcbFileCount);
+		SET_SWAP_BE32(volumeHeader->folderCount, vcb->vcbFolderCount);
+		SET_SWAP_BE32(volumeHeader->blockSize, vcb->vcbBlockSize);
+		SET_SWAP_BE32(volumeHeader->totalBlocks, vcb->vcbTotalBlocks);
+		SET_SWAP_BE32(volumeHeader->freeBlocks, vcb->vcbFreeBlocks);
+		SET_SWAP_BE32(volumeHeader->nextAllocation, vcb->vcbNextAllocation);
+		SET_SWAP_BE32(volumeHeader->rsrcClumpSize, vcb->vcbRsrcClumpSize);
+		SET_SWAP_BE32(volumeHeader->dataClumpSize, vcb->vcbDataClumpSize);
+		SET_SWAP_BE32(volumeHeader->nextCatalogID, vcb->vcbNextCatalogID);
+		SET_SWAP_BE32(volumeHeader->writeCount, vcb->vcbWriteCount);
+		SET_SWAP_BE64(volumeHeader->encodingsBitmap, vcb->vcbEncodingsBitmap);
 
 		//ее╩should we use the vcb or fcb clumpSize values ????? -djb
-		volumeHeader->allocationFile.clumpSize	= vcb->vcbAllocationFile->fcbClumpSize;
-		volumeHeader->extentsFile.clumpSize	= vcb->vcbExtentsFile->fcbClumpSize;
-		volumeHeader->catalogFile.clumpSize	= vcb->vcbCatalogFile->fcbClumpSize;
+		SET_SWAP_BE32(volumeHeader->allocationFile.clumpSize, vcb->vcbAllocationFile->fcbClumpSize);
+		SET_SWAP_BE32(volumeHeader->extentsFile.clumpSize, vcb->vcbExtentsFile->fcbClumpSize);
+		SET_SWAP_BE32(volumeHeader->catalogFile.clumpSize, vcb->vcbCatalogFile->fcbClumpSize);
 		
 		CopyMemory( vcb->vcbFinderInfo, volumeHeader->finderInfo, sizeof(volumeHeader->finderInfo) );
 	
 		fcb = vcb->vcbExtentsFile;
 		CopyMemory( fcb->fcbExtents32, volumeHeader->extentsFile.extents, sizeof(HFSPlusExtentRecord) );
-		volumeHeader->extentsFile.logicalSize = fcb->fcbLogicalSize;
-		volumeHeader->extentsFile.totalBlocks = fcb->fcbPhysicalSize / vcb->vcbBlockSize;
+		SET_SWAP_BE64(volumeHeader->extentsFile.logicalSize, fcb->fcbLogicalSize);
+		SET_SWAP_BE32(volumeHeader->extentsFile.totalBlocks, fcb->fcbPhysicalSize / vcb->vcbBlockSize);
 	
 		fcb = vcb->vcbCatalogFile;
 		CopyMemory( fcb->fcbExtents32, volumeHeader->catalogFile.extents, sizeof(HFSPlusExtentRecord) );
-		volumeHeader->catalogFile.logicalSize = fcb->fcbLogicalSize;
-		volumeHeader->catalogFile.totalBlocks = fcb->fcbPhysicalSize / vcb->vcbBlockSize;
+		SET_SWAP_BE64(volumeHeader->catalogFile.logicalSize, fcb->fcbLogicalSize);
+		SET_SWAP_BE32(volumeHeader->catalogFile.totalBlocks, fcb->fcbPhysicalSize / vcb->vcbBlockSize);
 
 		fcb = vcb->vcbAllocationFile;
 		CopyMemory( fcb->fcbExtents32, volumeHeader->allocationFile.extents, sizeof(HFSPlusExtentRecord) );
-		volumeHeader->allocationFile.logicalSize = fcb->fcbLogicalSize;
-		volumeHeader->allocationFile.totalBlocks = fcb->fcbPhysicalSize / vcb->vcbBlockSize;
+		SET_SWAP_BE64(volumeHeader->allocationFile.logicalSize, fcb->fcbLogicalSize);
+		SET_SWAP_BE32(volumeHeader->allocationFile.totalBlocks, fcb->fcbPhysicalSize / vcb->vcbBlockSize);
 		
 		if (vcb->vcbAttributesFile != NULL)	//	Only update fields if an attributes file existed and was open
 		{
 			fcb = vcb->vcbAttributesFile;
 			CopyMemory( fcb->fcbExtents32, volumeHeader->attributesFile.extents, sizeof(HFSPlusExtentRecord) );
-			volumeHeader->attributesFile.logicalSize = fcb->fcbLogicalSize;
-			volumeHeader->attributesFile.clumpSize = fcb->fcbClumpSize;
-			volumeHeader->attributesFile.totalBlocks = fcb->fcbPhysicalSize / vcb->vcbBlockSize;
+			SET_SWAP_BE64(volumeHeader->attributesFile.logicalSize, fcb->fcbLogicalSize);
+			SET_SWAP_BE32(volumeHeader->attributesFile.clumpSize, fcb->fcbClumpSize);
+			SET_SWAP_BE32(volumeHeader->attributesFile.totalBlocks, fcb->fcbPhysicalSize / vcb->vcbBlockSize);
 		}
 		
 		//--	Write the MDB out by releasing the block dirty
@@ -988,19 +989,19 @@ OSErr	FlushVolumeControlBlock( SVCB *vcb
 		ReturnIfError(err);
 		mdbP = (HFSMasterDirectoryBlock	*) block.buffer;
 
-		mdbP->drCrDate    = vcb->vcbCreateDate;
-		mdbP->drLsMod     = vcb->vcbModifyDate;
-		mdbP->drAtrb      = (UInt16)vcb->vcbAttributes;
-		mdbP->drClpSiz    = vcb->vcbDataClumpSize;
-		mdbP->drNxtCNID   = vcb->vcbNextCatalogID;
-		mdbP->drFreeBks   = vcb->vcbFreeBlocks;
-		mdbP->drXTClpSiz  = vcb->vcbExtentsFile->fcbClumpSize;
-		mdbP->drCTClpSiz  = vcb->vcbCatalogFile->fcbClumpSize;
-
-		mdbP->drNmFls     = vcb->vcbNmFls;
-		mdbP->drNmRtDirs  = vcb->vcbNmRtDirs;
-		mdbP->drFilCnt    = vcb->vcbFileCount;
-		mdbP->drDirCnt    = vcb->vcbFolderCount;
+		SET_SWAP_BE32(mdbP->drCrDate, vcb->vcbCreateDate);
+		SET_SWAP_BE32(mdbP->drLsMod, vcb->vcbModifyDate);
+		SET_SWAP_BE16(mdbP->drAtrb, (UInt16)vcb->vcbAttributes);
+		SET_SWAP_BE32(mdbP->drClpSiz, vcb->vcbDataClumpSize);
+		SET_SWAP_BE32(mdbP->drNxtCNID, vcb->vcbNextCatalogID);
+		SET_SWAP_BE16(mdbP->drFreeBks, vcb->vcbFreeBlocks);
+		SET_SWAP_BE32(mdbP->drXTClpSiz, vcb->vcbExtentsFile->fcbClumpSize);
+		SET_SWAP_BE32(mdbP->drCTClpSiz, vcb->vcbCatalogFile->fcbClumpSize);
+
+		SET_SWAP_BE16(mdbP->drNmFls, vcb->vcbNmFls);
+		SET_SWAP_BE16(mdbP->drNmRtDirs, vcb->vcbNmRtDirs);
+		SET_SWAP_BE32(mdbP->drFilCnt, vcb->vcbFileCount);
+		SET_SWAP_BE32(mdbP->drDirCnt, vcb->vcbFolderCount);
 
 		fcb = vcb->vcbExtentsFile;
 		CopyMemory( fcb->fcbExtents16, mdbP->drXTExtRec, sizeof( mdbP->drXTExtRec ) );
@@ -1058,15 +1059,15 @@ OSErr	FlushAlternateVolumeControlBlock( 
 		ReturnIfError( err );
 
 		mdb = (HFSMasterDirectoryBlock	*) block_MDB.buffer;
-		if ( mdb->drSigWord == kHFSSigWord )
+		if ( SWAP_BE16(mdb->drSigWord) == kHFSSigWord )
 		{
 			UInt64 		totalHFSPlusSectors;
 			
 			// this is a wrapped HFS+ volume. get the location of the 
 			// alternate volume header
-			totalHFSPlusSectors = (mdb->drAlBlkSiz / 512) * mdb->drEmbedExtent.blockCount;
-			alternateBlockLocation = mdb->drAlBlSt + ((mdb->drAlBlkSiz / 512) * 
-				mdb->drEmbedExtent.startBlock) + totalHFSPlusSectors - 2;
+			totalHFSPlusSectors = (SWAP_BE32(mdb->drAlBlkSiz) / 512) * SWAP_BE16(mdb->drEmbedExtent.blockCount);
+			alternateBlockLocation = SWAP_BE16(mdb->drAlBlSt) + ((SWAP_BE32(mdb->drAlBlkSiz) / 512) * 
+				SWAP_BE16(mdb->drEmbedExtent.startBlock)) + totalHFSPlusSectors - 2;
 		}
 
 		(void) ReleaseVolumeBlock(vcb, &block_MDB, kReleaseBlock);
@@ -1097,16 +1098,16 @@ ConvertToHFSPlusExtent( const HFSExtentR
 	
 	for (i = kHFSPlusExtentDensity-1; i > 2; --i)
 	{
-		newExtents[i].blockCount = 0;
-		newExtents[i].startBlock = 0;
+		SET_SWAP_BE32(newExtents[i].blockCount, 0);
+		SET_SWAP_BE32(newExtents[i].startBlock, 0);
 	}
 
-	newExtents[2].blockCount = oldExtents[2].blockCount;
-	newExtents[2].startBlock = oldExtents[2].startBlock;
-	newExtents[1].blockCount = oldExtents[1].blockCount;
-	newExtents[1].startBlock = oldExtents[1].startBlock;
-	newExtents[0].blockCount = oldExtents[0].blockCount;
-	newExtents[0].startBlock = oldExtents[0].startBlock;
+	SET_SWAP_BE32(newExtents[2].blockCount, SWAP_BE16(oldExtents[2].blockCount));
+	SET_SWAP_BE32(newExtents[2].startBlock, SWAP_BE16(oldExtents[2].startBlock));
+	SET_SWAP_BE32(newExtents[1].blockCount, SWAP_BE16(oldExtents[1].blockCount));
+	SET_SWAP_BE32(newExtents[1].startBlock, SWAP_BE16(oldExtents[1].startBlock));
+	SET_SWAP_BE32(newExtents[0].blockCount, SWAP_BE16(oldExtents[0].blockCount));
+	SET_SWAP_BE32(newExtents[0].startBlock, SWAP_BE16(oldExtents[0].startBlock));
 }
 
 
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/SVerify1.c diskdev_cmds/fsck_hfs.tproj/dfalib/SVerify1.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/SVerify1.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/SVerify1.c	2003-06-30 11:40:00.000000000 +0200
@@ -36,6 +36,7 @@
 //#include <Errors.h>
 
 #include "Scavenger.h"
+#include "hfs_endian.h"
 
 //	internal routine prototypes
 
@@ -89,18 +90,18 @@ CheckIfJournaled(SGlobPtr GPtr)
 
 	mdbp = (HFSMasterDirectoryBlock	*) block.buffer;
 
-	if (mdbp->drSigWord == kHFSPlusSigWord) {
+	if (SWAP_BE16(mdbp->drSigWord) == kHFSPlusSigWord) {
 		vhp = (HFSPlusVolumeHeader *) block.buffer;
 
-	} else if (mdbp->drSigWord == kHFSSigWord) {
+	} else if (SWAP_BE16(mdbp->drSigWord) == kHFSSigWord) {
 
-		if (mdbp->drEmbedSigWord == kHFSPlusSigWord) {
+		if (SWAP_BE16(mdbp->drEmbedSigWord) == kHFSPlusSigWord) {
 			UInt32 vhSector;
 			UInt32 blkSectors;
 			
-			blkSectors = mdbp->drAlBlkSiz / 512;
-			vhSector  = mdbp->drAlBlSt;
-			vhSector += blkSectors * mdbp->drEmbedExtent.startBlock;
+			blkSectors = SWAP_BE32(mdbp->drAlBlkSiz) / 512;
+			vhSector  = SWAP_BE16(mdbp->drAlBlSt);
+			vhSector += blkSectors * SWAP_BE16(mdbp->drEmbedExtent.startBlock);
 			vhSector += kIDSector;
 	
 			(void) ReleaseVolumeBlock(vcb, &block, kReleaseBlock);
@@ -114,13 +115,13 @@ CheckIfJournaled(SGlobPtr GPtr)
 	}
 
 	if ((vhp != NULL) && (ValidVolumeHeader(vhp) == noErr)) {
-		result = ((vhp->attributes & kHFSVolumeJournaledMask) != 0);
+		result = ((SWAP_BE32(vhp->attributes) & kHFSVolumeJournaledMask) != 0);
 
 		// even if journaling is enabled for this volume, we'll return
 		// false if it wasn't unmounted cleanly and it was previously
 		// mounted by someone that doesn't know about journaling.
-		if (   vhp->lastMountedVersion != kHFSJMountVersion
-			&& (vhp->attributes & kHFSVolumeUnmountedMask) == 0) {
+		if (SWAP_BE32(vhp->lastMountedVersion) != kHFSJMountVersion
+			&& (SWAP_BE32(vhp->attributes) & kHFSVolumeUnmountedMask) == 0) {
 			result = 0;
 		}
 	} else {
@@ -163,18 +164,18 @@ CheckForClean(SGlobPtr GPtr, Boolean mar
 
 	mdbp = (HFSMasterDirectoryBlock	*) block.buffer;
 
-	if (mdbp->drSigWord == kHFSPlusSigWord) {
+	if (SWAP_BE16(mdbp->drSigWord) == kHFSPlusSigWord) {
 		vhp = (HFSPlusVolumeHeader *) block.buffer;
 
-	} else if (mdbp->drSigWord == kHFSSigWord) {
+	} else if (SWAP_BE16(mdbp->drSigWord) == kHFSSigWord) {
 
-		if (mdbp->drEmbedSigWord == kHFSPlusSigWord) {
+		if (SWAP_BE16(mdbp->drEmbedSigWord) == kHFSPlusSigWord) {
 			UInt32 vhSector;
 			UInt32 blkSectors;
 			
-			blkSectors = mdbp->drAlBlkSiz / 512;
-			vhSector  = mdbp->drAlBlSt;
-			vhSector += blkSectors * mdbp->drEmbedExtent.startBlock;
+			blkSectors = SWAP_BE32(mdbp->drAlBlkSiz) / 512;
+			vhSector  = SWAP_BE16(mdbp->drAlBlSt);
+			vhSector += blkSectors * SWAP_BE16(mdbp->drEmbedExtent.startBlock);
 			vhSector += kIDSector;
 	
 			(void) ReleaseVolumeBlock(vcb, &block, kReleaseBlock);
@@ -185,18 +186,18 @@ CheckForClean(SGlobPtr GPtr, Boolean mar
 			mdbp = (HFSMasterDirectoryBlock	*) NULL;
 
 		} else /* plain old HFS */ {
-			result = (mdbp->drAtrb & kHFSVolumeUnmountedMask) != 0;
+			result = (SWAP_BE16(mdbp->drAtrb) & kHFSVolumeUnmountedMask) != 0;
 			if (markClean && (result == 0)) {
-				mdbp->drAtrb |= kHFSVolumeUnmountedMask;
+				SET_SWAP_BE16(mdbp->drAtrb, SWAP_BE16(mdbp->drAtrb) | kHFSVolumeUnmountedMask);
 				rbOptions = kForceWriteBlock;
 			}
 		}
 	}
 
 	if ((vhp != NULL) && (ValidVolumeHeader(vhp) == noErr)) {
-		result = (vhp->attributes & kHFSVolumeUnmountedMask) != 0;
+		result = (SWAP_BE32(vhp->attributes) & kHFSVolumeUnmountedMask) != 0;
 		if (markClean && (result == 0)) {
-			vhp->attributes |= kHFSVolumeUnmountedMask;
+			SET_SWAP_BE32(vhp->attributes, SWAP_BE32(vhp->attributes) | kHFSVolumeUnmountedMask);
 			rbOptions = kForceWriteBlock;
 		}
 	}
@@ -264,21 +265,21 @@ again:
 	ReturnIfError( err );
 
 	alternateMDB = (HFSMasterDirectoryBlock	*) block_MDB.buffer;
-	if ( alternateMDB->drSigWord == kHFSPlusSigWord )
+	if ( SWAP_BE16(alternateMDB->drSigWord) == kHFSPlusSigWord )
 	{
 		alternateVolumeHeader	= (HFSPlusVolumeHeader *)alternateMDB;
 		GPtr->volumeType		= kPureHFSPlusVolumeType;
 		GPtr->isHFSPlus			= true;
 		WriteMsg( GPtr, M_CheckingHFSPlusVolume, kStatusMessage );
 	}
-	else if ( alternateMDB->drSigWord == kHFSSigWord )
+	else if ( SWAP_BE16(alternateMDB->drSigWord) == kHFSSigWord )
 	{
 		//	Volume Type is constant, weather we are examining wrapper or HFS+ volume.
 		//	Detect if this is a wrapped HFS+ volume.
 		err = ScavengeVolumeType( GPtr, alternateMDB, &GPtr->volumeType );
 	
 		/* Wrappered HFS+ volume */
-		if ( ((GPtr->inputFlags & examineWrapperMask) == 0) && (alternateMDB->drEmbedSigWord == kHFSPlusSigWord) )
+		if ( ((GPtr->inputFlags & examineWrapperMask) == 0) && (SWAP_BE16(alternateMDB->drEmbedSigWord) == kHFSPlusSigWord) )
 		{
 			WriteMsg( GPtr, M_CheckingHFSPlusVolume, kStatusMessage );
 			GPtr->isHFSPlus	= true;
@@ -314,7 +315,7 @@ again:
 	//	If we're checking an HFS+ volume's wrapper, check for bad extents
 	//
 	
-	if ( ((GPtr->inputFlags & examineWrapperMask) != 0) && (alternateMDB->drEmbedSigWord == kHFSPlusSigWord) )
+	if ( ((GPtr->inputFlags & examineWrapperMask) != 0) && (SWAP_BE16(alternateMDB->drEmbedSigWord) == kHFSPlusSigWord) )
 	{
 		err = CheckWrapperExtents( GPtr, alternateMDB );
 		if (err != noErr)
@@ -337,7 +338,7 @@ again:
 		}
 		else
 		{
-			totalSectors	= (UInt64)alternateMDB->drEmbedExtent.blockCount * ( alternateMDB->drAlBlkSiz / Blk_Size );
+			totalSectors	= (UInt64)SWAP_BE16(alternateMDB->drEmbedExtent.blockCount) * ( SWAP_BE32(alternateMDB->drAlBlkSiz) / Blk_Size );
 
 			err = GetVolumeHeaderBlock(vcb, alternateMDB, &block_VH, &alternateBlockLocation, &hfsPlusIOPosOffset);
 			if (err)
@@ -360,13 +361,13 @@ again:
 		vcb->vcbEmbeddedOffset = hfsPlusIOPosOffset;
 
 		maxNumberOfAllocationBlocks	= 0xFFFFFFFF;
-		realAllocationBlockSize		= alternateVolumeHeader->blockSize;
-		realTotalBlocks				= alternateVolumeHeader->totalBlocks;
-		vcb->vcbNextCatalogID	= alternateVolumeHeader->nextCatalogID;
-		vcb->vcbCreateDate	= alternateVolumeHeader->createDate;
-		vcb->vcbAttributes = alternateVolumeHeader->attributes & kHFSCatalogNodeIDsReused;
+		realAllocationBlockSize		= SWAP_BE32(alternateVolumeHeader->blockSize);
+		realTotalBlocks				= SWAP_BE32(alternateVolumeHeader->totalBlocks);
+		vcb->vcbNextCatalogID	= SWAP_BE32(alternateVolumeHeader->nextCatalogID);
+		vcb->vcbCreateDate	= SWAP_BE32(alternateVolumeHeader->createDate);
+		vcb->vcbAttributes = SWAP_BE32(alternateVolumeHeader->attributes) & kHFSCatalogNodeIDsReused;
 		
-		if ( alternateVolumeHeader->attributesFile.totalBlocks == 0 )
+		if ( SWAP_BE32(alternateVolumeHeader->attributesFile.totalBlocks) == 0 )
 			vcb->vcbAttributesFile = NULL;	/* XXX memory leak ? */
 
 		//	Make sure the Extents B-Tree is set to use 16-bit key lengths.  We access it before completely setting
@@ -377,14 +378,14 @@ again:
 	else	//	It's an HFS disk
 	{
 		GPtr->numExtents			= kHFSExtentDensity;
-		vcb->vcbSignature	= alternateMDB->drSigWord;
+		vcb->vcbSignature	= SWAP_BE16(alternateMDB->drSigWord);
 		totalSectors				= alternateBlockLocation;
 		maxNumberOfAllocationBlocks	= 0xFFFF;
-		vcb->vcbNextCatalogID	= alternateMDB->drNxtCNID;			//	set up next file ID, CheckBTreeKey makse sure we are under this value
-		vcb->vcbCreateDate	= alternateMDB->drCrDate;
+		vcb->vcbNextCatalogID	= SWAP_BE32(alternateMDB->drNxtCNID);			//	set up next file ID, CheckBTreeKey makse sure we are under this value
+		vcb->vcbCreateDate	= SWAP_BE32(alternateMDB->drCrDate);
 
-		realAllocationBlockSize		= alternateMDB->drAlBlkSiz;
-		realTotalBlocks				= alternateMDB->drNmAlBlks;
+		realAllocationBlockSize		= SWAP_BE32(alternateMDB->drAlBlkSiz);
+		realTotalBlocks				= SWAP_BE16(alternateMDB->drNmAlBlks);
 	}
 	
 	
@@ -433,21 +434,21 @@ again:
 			goto ReleaseAndBail;
 		}
 
-		if ( alternateMDB->drVBMSt <= MDB_BlkN )
+		if ( SWAP_BE16(alternateMDB->drVBMSt) <= MDB_BlkN )
 		{
 			RcdError(GPtr,E_VBMSt);
 			err = E_VBMSt;								//	invalid VBM start block
 			goto ReleaseAndBail;
 		}	
-		vcb->vcbVBMSt = alternateMDB->drVBMSt;
+		vcb->vcbVBMSt = SWAP_BE16(alternateMDB->drVBMSt);
 		
-		if (alternateMDB->drAlBlSt < (alternateMDB->drVBMSt + bitMapSizeInSectors))
+		if (SWAP_BE16(alternateMDB->drAlBlSt) < (SWAP_BE16(alternateMDB->drVBMSt) + bitMapSizeInSectors))
 		{
 			RcdError(GPtr,E_ABlkSt);
 			err = E_ABlkSt;								//	invalid starting alloc block
 			goto ReleaseAndBail;
 		}
-		vcb->vcbAlBlSt = alternateMDB->drAlBlSt;
+		vcb->vcbAlBlSt = SWAP_BE16(alternateMDB->drAlBlSt);
 	}
 	
 
@@ -473,23 +474,23 @@ GetVolumeHeaderBlock(SVCB *vcb, HFSMaste
 	HFSPlusVolumeHeader *  altVH;
 	UInt32  totalHFSPlusSectors;
 	
-	totalHFSPlusSectors = (mdb->drAlBlkSiz / 512) * mdb->drEmbedExtent.blockCount;
-	*hfsPlusIOPosOffset = (mdb->drEmbedExtent.startBlock * mdb->drAlBlkSiz) + (mdb->drAlBlSt * 512);
+	totalHFSPlusSectors = (SWAP_BE32(mdb->drAlBlkSiz) / 512) * SWAP_BE16(mdb->drEmbedExtent.blockCount);
+	*hfsPlusIOPosOffset = (SWAP_BE16(mdb->drEmbedExtent.startBlock) * SWAP_BE32(mdb->drAlBlkSiz)) + (SWAP_BE16(mdb->drAlBlSt) * 512);
 	/* always 2nd to last sector */
-	*idSector = mdb->drAlBlSt + ((mdb->drAlBlkSiz / 512) * mdb->drEmbedExtent.startBlock) + totalHFSPlusSectors - 2;
+	*idSector = SWAP_BE16(mdb->drAlBlSt) + ((SWAP_BE32(mdb->drAlBlkSiz) / 512) * SWAP_BE16(mdb->drEmbedExtent.startBlock)) + totalHFSPlusSectors - 2;
 	
 	err = GetVolumeBlock(vcb, *idSector, kGetBlock, block);
 	altVH = (HFSPlusVolumeHeader*) block->buffer;
 
 	if ( err == noErr )
 		err = ValidVolumeHeader(altVH);
-	
+
 	/*
 	 * If the alternate VolumeHeader is bad, just use the real VolumeHeader
 	 */
 	if ( err != noErr ) {
 		/* VH is always 3rd sector of HFS+ partition */
-		*idSector = (mdb->drEmbedExtent.startBlock * mdb->drAlBlkSiz / 512) + mdb->drAlBlSt + 2;
+		*idSector = (SWAP_BE16(mdb->drEmbedExtent.startBlock) * SWAP_BE32(mdb->drAlBlkSiz) / 512) + SWAP_BE16(mdb->drAlBlSt) + 2;
 
 		err = GetVolumeBlock(vcb, *idSector, kGetBlock, block);
 		altVH = (HFSPlusVolumeHeader*) block->buffer;
@@ -516,7 +517,7 @@ OSErr	ScavengeVolumeType( SGlobPtr GPtr,
 	HFSPlusVolumeHeader 	*volumeHeader;
 	HFSExtentDescriptor		embededExtent;
 	SVCB				*calculatedVCB			= GPtr->calculatedVCB;
-	UInt16					embedSigWord			= mdb->drEmbedSigWord;
+	UInt16					embedSigWord			= SWAP_BE16(mdb->drEmbedSigWord);
 	BlockDescriptor block;
 
 	/*
@@ -527,8 +528,8 @@ OSErr	ScavengeVolumeType( SGlobPtr GPtr,
 	 * still be there, and we'll try to repair the embedded volume.
 	 */
 	if (embedSigWord == 0  &&
-		mdb->drEmbedExtent.blockCount == 0  &&
-		mdb->drEmbedExtent.startBlock == 0)
+		SWAP_BE16(mdb->drEmbedExtent.blockCount) == 0  &&
+		SWAP_BE16(mdb->drEmbedExtent.startBlock) == 0)
 	{
 		*volumeType = kHFSVolumeType;
 		return noErr;
@@ -542,8 +543,8 @@ OSErr	ScavengeVolumeType( SGlobPtr GPtr,
 	if ( embedSigWord == kHFSPlusSigWord )
 	{
 		/* 2nd to last sector */
-		vHSector = (UInt64)mdb->drAlBlSt +
-			((UInt64)(mdb->drAlBlkSiz / 512) * (UInt64)mdb->drEmbedExtent.startBlock) + 2;
+		vHSector = (UInt64)SWAP_BE16(mdb->drAlBlSt) +
+			((UInt64)(SWAP_BE32(mdb->drAlBlkSiz) / 512) * (UInt64)SWAP_BE16(mdb->drEmbedExtent.startBlock)) + 2;
 
 		err = GetVolumeBlock(calculatedVCB, vHSector, kGetBlock, &block);
 		volumeHeader = (HFSPlusVolumeHeader *) block.buffer;
@@ -556,7 +557,7 @@ OSErr	ScavengeVolumeType( SGlobPtr GPtr,
 	}
 	
 
-	sectorsPerBlock = mdb->drAlBlkSiz / 512;
+	sectorsPerBlock = SWAP_BE32(mdb->drAlBlkSiz) / 512;
 
 	//	Search the end of the disk to see if a Volume Header is present at all
 	if ( embedSigWord != kHFSPlusSigWord )
@@ -564,7 +565,7 @@ OSErr	ScavengeVolumeType( SGlobPtr GPtr,
 		err = GetDeviceSize( GPtr->calculatedVCB->vcbDriveNumber, &totalSectors, &sectorSize );
 		if ( err != noErr ) goto AssumeHFS;
 		
-		numSectorsToSearch = mdb->drAlBlkSiz / sectorSize;
+		numSectorsToSearch = SWAP_BE32(mdb->drAlBlkSiz) / sectorSize;
 		startSector = totalSectors - 4 - numSectorsToSearch;
 		
 		err = SeekVolumeHeader( GPtr, startSector, numSectorsToSearch, &altVHSector );
@@ -572,7 +573,7 @@ OSErr	ScavengeVolumeType( SGlobPtr GPtr,
 		
 		//	We found the Alt VH, so this must be a damaged embeded HFS+ volume
 		//	Now Scavenge for the VolumeHeader
-		startSector = mdb->drAlBlSt + (4 * sectorsPerBlock);		// Start looking at 4th HFS allocation block
+		startSector = SWAP_BE16(mdb->drAlBlSt) + (4 * sectorsPerBlock);		// Start looking at 4th HFS allocation block
 		numSectorsToSearch = 10 * sectorsPerBlock;			// search for VH in next 10 allocation blocks
 		
 		err = SeekVolumeHeader( GPtr, startSector, numSectorsToSearch, &vHSector );
@@ -581,30 +582,30 @@ OSErr	ScavengeVolumeType( SGlobPtr GPtr,
 		hfsPlusSectors	= altVHSector - vHSector + 1 + 2 + 1;	// numSectors + BB + end
 		
 		//	Fix the embeded extent
-		embededExtent.blockCount	= hfsPlusSectors / sectorsPerBlock;
-		embededExtent.startBlock	= (vHSector - 2 - mdb->drAlBlSt ) / sectorsPerBlock;
+		SET_SWAP_BE16(embededExtent.blockCount, hfsPlusSectors / sectorsPerBlock);
+		SET_SWAP_BE16(embededExtent.startBlock, (vHSector - 2 - SWAP_BE16(mdb->drAlBlSt) ) / sectorsPerBlock);
 		embedSigWord				= kHFSPlusSigWord;
 	}
 	else
 	{
-		embedSigWord				= mdb->drEmbedSigWord;
+		embedSigWord				= SWAP_BE16(mdb->drEmbedSigWord);
 		embededExtent.blockCount	= mdb->drEmbedExtent.blockCount;
 		embededExtent.startBlock	= mdb->drEmbedExtent.startBlock;
 	}
 		
 	if ( embedSigWord == kHFSPlusSigWord )
 	{
-		startSector = 2 + mdb->drAlBlSt +
-			((UInt64)embededExtent.startBlock * (mdb->drAlBlkSiz / 512));
+		startSector = 2 + SWAP_BE16(mdb->drAlBlSt) +
+			((UInt64)SWAP_BE16(embededExtent.startBlock) * (SWAP_BE32(mdb->drAlBlkSiz) / 512));
 			
-		err = SeekVolumeHeader( GPtr, startSector, mdb->drAlBlkSiz / 512, &vHSector );
+		err = SeekVolumeHeader( GPtr, startSector, SWAP_BE32(mdb->drAlBlkSiz) / 512, &vHSector );
 		if ( err != noErr ) goto AssumeHFS;
 	
 		//	Now replace the bad fields and mark the error
-		mdb->drEmbedExtent.blockCount	= hfsPlusSectors / sectorsPerBlock;
-		mdb->drEmbedExtent.startBlock	= (vHSector - 2 - mdb->drAlBlSt ) / sectorsPerBlock;
-		mdb->drEmbedSigWord				= kHFSPlusSigWord;
-		mdb->drAlBlSt					+= vHSector - startSector;								//	Fix the bad field
+		SET_SWAP_BE16(mdb->drEmbedExtent.blockCount, hfsPlusSectors / sectorsPerBlock);
+		SET_SWAP_BE16(mdb->drEmbedExtent.startBlock, (vHSector - 2 - SWAP_BE16(mdb->drAlBlSt) ) / sectorsPerBlock);
+		SET_SWAP_BE16(mdb->drEmbedSigWord, kHFSPlusSigWord);
+		SET_SWAP_BE16(mdb->drAlBlSt, SWAP_BE16(mdb->drAlBlSt) + vHSector - startSector);								//	Fix the bad field
 		GPtr->VIStat = GPtr->VIStat | S_MDB;													//	write out our MDB
 		return( E_InvalidMDBdrAlBlSt );
 	}
@@ -645,10 +646,10 @@ static OSErr CheckWrapperExtents( SGlobP
 	OSErr	err = noErr;
 	
 	//	See if Norton Disk Doctor 2.0 corrupted the catalog's first extent
-	if ( mdb->drCTExtRec[0].startBlock >= mdb->drEmbedExtent.startBlock)
+	if ( SWAP_BE16(mdb->drCTExtRec[0].startBlock) >= SWAP_BE16(mdb->drEmbedExtent.startBlock))
 	{
 		//	Fix the field in the in-memory copy, and record the error
-		mdb->drCTExtRec[0].startBlock = mdb->drXTExtRec[0].startBlock + mdb->drXTExtRec[0].blockCount;
+		SET_SWAP_BE16(mdb->drCTExtRec[0].startBlock, SWAP_BE16(mdb->drXTExtRec[0].startBlock) + SWAP_BE16(mdb->drXTExtRec[0].blockCount));
 		GPtr->VIStat = GPtr->VIStat | S_MDB;													//	write out our MDB
 		err = RcdInvalidWrapperExtents( GPtr, E_InvalidWrapperExtents );
 	}
@@ -701,7 +702,7 @@ OSErr	CreateExtentsBTreeControlBlock( SG
 		err = CheckFileExtents( GPtr, kHFSExtentsFileID, 0, (void *)GPtr->calculatedExtentsFCB->fcbExtents32, &numABlks );	//	check out extent info
 		if (err) goto exit;
 
-		if ( volumeHeader->extentsFile.totalBlocks != numABlks )				//	check out the PEOF
+		if ( SWAP_BE32(volumeHeader->extentsFile.totalBlocks) != numABlks )				//	check out the PEOF
 		{
 			RcdError( GPtr, E_ExtPEOF );
 			err = E_ExtPEOF;
@@ -709,9 +710,9 @@ OSErr	CreateExtentsBTreeControlBlock( SG
 		}
 		else
 		{
-			GPtr->calculatedExtentsFCB->fcbLogicalSize  = volumeHeader->extentsFile.logicalSize;					//	Set Extents tree's LEOF
-			GPtr->calculatedExtentsFCB->fcbPhysicalSize = (UInt64)volumeHeader->extentsFile.totalBlocks * 
-														  (UInt64)volumeHeader->blockSize;	//	Set Extents tree's PEOF
+			GPtr->calculatedExtentsFCB->fcbLogicalSize  = SWAP_BE64(volumeHeader->extentsFile.logicalSize);					//	Set Extents tree's LEOF
+			GPtr->calculatedExtentsFCB->fcbPhysicalSize = (UInt64)SWAP_BE32(volumeHeader->extentsFile.totalBlocks) * 
+														  (UInt64)SWAP_BE32(volumeHeader->blockSize);	//	Set Extents tree's PEOF
 		}
 
 		//
@@ -725,13 +726,13 @@ OSErr	CreateExtentsBTreeControlBlock( SG
 		btcb->maxKeyLength		= kHFSPlusExtentKeyMaximumLength;				//	max key length
 		btcb->keyCompareProc	= (void *)CompareExtentKeysPlus;
 		btcb->attributes		|=kBTBigKeysMask;								//	HFS+ Extent files have 16-bit key length
-		btcb->leafRecords		= header.leafRecords;
-		btcb->treeDepth			= header.treeDepth;
-		btcb->rootNode			= header.rootNode;
-		btcb->firstLeafNode		= header.firstLeafNode;
-		btcb->lastLeafNode		= header.lastLeafNode;
+		btcb->leafRecords		= SWAP_BE32(header.leafRecords);
+		btcb->treeDepth			= SWAP_BE16(header.treeDepth);
+		btcb->rootNode			= SWAP_BE32(header.rootNode);
+		btcb->firstLeafNode		= SWAP_BE32(header.firstLeafNode);
+		btcb->lastLeafNode		= SWAP_BE32(header.lastLeafNode);
 
-		btcb->nodeSize			= header.nodeSize;
+		btcb->nodeSize			= SWAP_BE16(header.nodeSize);
 		btcb->totalNodes		= ( GPtr->calculatedExtentsFCB->fcbPhysicalSize / btcb->nodeSize );
 		btcb->freeNodes			= btcb->totalNodes;								//	start with everything free
 
@@ -762,7 +763,7 @@ OSErr	CreateExtentsBTreeControlBlock( SG
 		err = CheckFileExtents( GPtr, kHFSExtentsFileID, 0, (void *)GPtr->calculatedExtentsFCB->fcbExtents16, &numABlks );	/* check out extent info */	
 		if (err) goto exit;
 	
-		if (alternateMDB->drXTFlSize != ((UInt64)numABlks * (UInt64)GPtr->calculatedVCB->vcbBlockSize))//	check out the PEOF
+		if (SWAP_BE32(alternateMDB->drXTFlSize) != ((UInt64)numABlks * (UInt64)GPtr->calculatedVCB->vcbBlockSize))//	check out the PEOF
 		{
 			RcdError(GPtr,E_ExtPEOF);
 			err = E_ExtPEOF;
@@ -770,7 +771,7 @@ OSErr	CreateExtentsBTreeControlBlock( SG
 		}
 		else
 		{
-			GPtr->calculatedExtentsFCB->fcbPhysicalSize = alternateMDB->drXTFlSize;		//	set up PEOF and EOF in FCB
+			GPtr->calculatedExtentsFCB->fcbPhysicalSize = SWAP_BE32(alternateMDB->drXTFlSize);		//	set up PEOF and EOF in FCB
 			GPtr->calculatedExtentsFCB->fcbLogicalSize = GPtr->calculatedExtentsFCB->fcbPhysicalSize;
 		}
 
@@ -784,13 +785,13 @@ OSErr	CreateExtentsBTreeControlBlock( SG
 
 		btcb->maxKeyLength	= kHFSExtentKeyMaximumLength;						//	max key length
 		btcb->keyCompareProc = (void *)CompareExtentKeys;
-		btcb->leafRecords	= header.leafRecords;
-		btcb->treeDepth		= header.treeDepth;
-		btcb->rootNode		= header.rootNode;
-		btcb->firstLeafNode	= header.firstLeafNode;
-		btcb->lastLeafNode	= header.lastLeafNode;
+		btcb->leafRecords	= SWAP_BE32(header.leafRecords);
+		btcb->treeDepth		= SWAP_BE16(header.treeDepth);
+		btcb->rootNode		= SWAP_BE32(header.rootNode);
+		btcb->firstLeafNode	= SWAP_BE32(header.firstLeafNode);
+		btcb->lastLeafNode	= SWAP_BE32(header.lastLeafNode);
 		
-		btcb->nodeSize		= header.nodeSize;
+		btcb->nodeSize		= SWAP_BE16(header.nodeSize);
 		btcb->totalNodes	= (GPtr->calculatedExtentsFCB->fcbPhysicalSize / btcb->nodeSize );
 		btcb->freeNodes		= btcb->totalNodes;									//	start with everything free
 
@@ -821,7 +822,7 @@ OSErr	CreateExtentsBTreeControlBlock( SG
 	}
 
 	((BTreeExtensionsRec*)btcb->refCon)->BTCBMSize = size;				//	remember how long it is
-	((BTreeExtensionsRec*)btcb->refCon)->realFreeNodeCount = header.freeNodes;//	keep track of real free nodes for progress
+	((BTreeExtensionsRec*)btcb->refCon)->realFreeNodeCount = SWAP_BE32(header.freeNodes);//	keep track of real free nodes for progress
 exit:
 	(void) ReleaseVolumeBlock(vcb, &block, kReleaseBlock);
 	
@@ -839,7 +840,7 @@ Function:	Minimal check verifies that th
 			to try different size values until one fits.
 			
 ------------------------------------------------------------------------------*/
-#define GetRecordOffset(btreePtr,node,index)		(*(short *) ((UInt8 *)(node) + (btreePtr)->nodeSize - ((index) << 1) - kOffsetSize))
+#define GetRecordOffset(btreePtr,node,index)		SWAP_BE16(*(u_big_int16_t *)((UInt8 *)(node) + (btreePtr)->nodeSize - ((index) << 1) - kOffsetSize))
 static	OSErr	CheckNodesFirstOffset( SGlobPtr GPtr, BTreeControlBlock *btcb )
 {
 	NodeRec		nodeRec;
@@ -953,7 +954,7 @@ OSErr ExtFlChk( SGlobPtr GPtr )
 	ReturnIfError( result );									//	error, could't get it
 	p = (void *) block.buffer;
 
-	attributes = GPtr->isHFSPlus == true ? ((HFSPlusVolumeHeader*)p)->attributes : ((HFSMasterDirectoryBlock*)p)->drAtrb;
+	attributes = GPtr->isHFSPlus == true ? SWAP_BE32(((HFSPlusVolumeHeader*)p)->attributes) : SWAP_BE16(((HFSMasterDirectoryBlock*)p)->drAtrb);
 
 	//ее Does HFS+ honnor the same mask?
 	if ( attributes & kHFSVolumeSparedBlocksMask )				//	if any badspots
@@ -1015,7 +1016,7 @@ OSErr	CreateCatalogBTreeControlBlock( SG
 		err = CheckFileExtents( GPtr, kHFSCatalogFileID, 0, (void *)GPtr->calculatedCatalogFCB->fcbExtents32, &numABlks );	
 		if (err) goto exit;
 
-		if ( volumeHeader->catalogFile.totalBlocks != numABlks )
+		if ( SWAP_BE32(volumeHeader->catalogFile.totalBlocks) != numABlks )
 		{
 			RcdError( GPtr, E_CatPEOF );
 			err = E_CatPEOF;
@@ -1023,9 +1024,9 @@ OSErr	CreateCatalogBTreeControlBlock( SG
 		}
 		else
 		{
-			GPtr->calculatedCatalogFCB->fcbLogicalSize  = volumeHeader->catalogFile.logicalSize;
-			GPtr->calculatedCatalogFCB->fcbPhysicalSize = (UInt64)volumeHeader->catalogFile.totalBlocks * 
-														  (UInt64)volumeHeader->blockSize;  
+			GPtr->calculatedCatalogFCB->fcbLogicalSize  = SWAP_BE64(volumeHeader->catalogFile.logicalSize);
+			GPtr->calculatedCatalogFCB->fcbPhysicalSize = (UInt64)SWAP_BE32(volumeHeader->catalogFile.totalBlocks) * 
+														  (UInt64)SWAP_BE32(volumeHeader->blockSize);  
 		}
 
 		//
@@ -1038,16 +1039,16 @@ OSErr	CreateCatalogBTreeControlBlock( SG
 
 		btcb->maxKeyLength		= kHFSPlusCatalogKeyMaximumLength;					//	max key length
 		btcb->keyCompareProc	= (void *)CompareExtendedCatalogKeys;
-		btcb->leafRecords		= header.leafRecords;
-		btcb->nodeSize			= header.nodeSize;
+		btcb->leafRecords		= SWAP_BE32(header.leafRecords);
+		btcb->nodeSize			= SWAP_BE16(header.nodeSize);
 		btcb->totalNodes		= ( GPtr->calculatedCatalogFCB->fcbPhysicalSize / btcb->nodeSize );
 		btcb->freeNodes			= btcb->totalNodes;									//	start with everything free
 		btcb->attributes		|=(kBTBigKeysMask + kBTVariableIndexKeysMask);		//	HFS+ Catalog files have large, variable-sized keys
 
-		btcb->treeDepth		= header.treeDepth;
-		btcb->rootNode		= header.rootNode;
-		btcb->firstLeafNode	= header.firstLeafNode;
-		btcb->lastLeafNode	= header.lastLeafNode;
+		btcb->treeDepth		= SWAP_BE16(header.treeDepth);
+		btcb->rootNode		= SWAP_BE32(header.rootNode);
+		btcb->firstLeafNode	= SWAP_BE32(header.firstLeafNode);
+		btcb->lastLeafNode	= SWAP_BE32(header.lastLeafNode);
 
 
 		//	Make sure the header nodes size field is correct by looking at the 1st record offset
@@ -1076,7 +1077,7 @@ OSErr	CreateCatalogBTreeControlBlock( SG
 		err = CheckFileExtents( GPtr, kHFSCatalogFileID, 0, (void *)GPtr->calculatedCatalogFCB->fcbExtents16, &numABlks );	/* check out extent info */	
 		if (err) goto exit;
 
-		if (alternateMDB->drCTFlSize != ((UInt64)numABlks * (UInt64)vcb->vcbBlockSize))	//	check out the PEOF
+		if (SWAP_BE32(alternateMDB->drCTFlSize) != ((UInt64)numABlks * (UInt64)vcb->vcbBlockSize))	//	check out the PEOF
 		{
 			RcdError( GPtr, E_CatPEOF );
 			err = E_CatPEOF;
@@ -1084,7 +1085,7 @@ OSErr	CreateCatalogBTreeControlBlock( SG
 		}
 		else
 		{
-			GPtr->calculatedCatalogFCB->fcbPhysicalSize	= alternateMDB->drCTFlSize;			//	set up PEOF and EOF in FCB
+			GPtr->calculatedCatalogFCB->fcbPhysicalSize	= SWAP_BE32(alternateMDB->drCTFlSize);			//	set up PEOF and EOF in FCB
 			GPtr->calculatedCatalogFCB->fcbLogicalSize	= GPtr->calculatedCatalogFCB->fcbPhysicalSize;
 		}
 
@@ -1098,15 +1099,15 @@ OSErr	CreateCatalogBTreeControlBlock( SG
 
 		btcb->maxKeyLength		= kHFSCatalogKeyMaximumLength;						//	max key length
 		btcb->keyCompareProc	= (void *) CompareCatalogKeys;
-		btcb->leafRecords		= header.leafRecords;
-		btcb->nodeSize			= header.nodeSize;
+		btcb->leafRecords		= SWAP_BE32(header.leafRecords);
+		btcb->nodeSize			= SWAP_BE16(header.nodeSize);
 		btcb->totalNodes		= (GPtr->calculatedCatalogFCB->fcbPhysicalSize / btcb->nodeSize );
 		btcb->freeNodes			= btcb->totalNodes;									//	start with everything free
 
-		btcb->treeDepth		= header.treeDepth;
-		btcb->rootNode		= header.rootNode;
-		btcb->firstLeafNode	= header.firstLeafNode;
-		btcb->lastLeafNode	= header.lastLeafNode;
+		btcb->treeDepth		= SWAP_BE16(header.treeDepth);
+		btcb->rootNode		= SWAP_BE32(header.rootNode);
+		btcb->firstLeafNode	= SWAP_BE32(header.firstLeafNode);
+		btcb->lastLeafNode	= SWAP_BE32(header.lastLeafNode);
 
 		//	Make sure the header nodes size field is correct by looking at the 1st record offset
 		err = CheckNodesFirstOffset( GPtr, btcb );
@@ -1139,7 +1140,7 @@ OSErr	CreateCatalogBTreeControlBlock( SG
 	}
 
 	((BTreeExtensionsRec*)btcb->refCon)->BTCBMSize			= size;						//	remember how long it is
-	((BTreeExtensionsRec*)btcb->refCon)->realFreeNodeCount	= header.freeNodes;		//	keep track of real free nodes for progress
+	((BTreeExtensionsRec*)btcb->refCon)->realFreeNodeCount	= SWAP_BE32(header.freeNodes);		//	keep track of real free nodes for progress
 
 exit:
 	(void) ReleaseVolumeBlock(vcb, &block, kReleaseBlock);
@@ -1193,7 +1194,7 @@ OSErr	CreateExtendedAllocationsFCB( SGlo
 
 		(void) SetFileBlockSize (fcb, vcb->vcbBlockSize);
 
-		if ( volumeHeader->allocationFile.totalBlocks != numABlks )
+		if ( SWAP_BE32(volumeHeader->allocationFile.totalBlocks) != numABlks )
 		{
 			RcdError( GPtr, E_CatPEOF );
 			err = E_CatPEOF;
@@ -1201,9 +1202,9 @@ OSErr	CreateExtendedAllocationsFCB( SGlo
 		}
 		else
 		{
-			fcb->fcbLogicalSize  = volumeHeader->allocationFile.logicalSize;
-			fcb->fcbPhysicalSize = (UInt64) volumeHeader->allocationFile.totalBlocks * 
-								   (UInt64) volumeHeader->blockSize; 
+			fcb->fcbLogicalSize  = SWAP_BE64(volumeHeader->allocationFile.logicalSize);
+			fcb->fcbPhysicalSize = (UInt64) SWAP_BE32(volumeHeader->allocationFile.totalBlocks) * 
+								   (UInt64) SWAP_BE32(volumeHeader->blockSize); 
 		}
 
 		/* while we're here, also get startup file extents... */
@@ -1213,9 +1214,9 @@ OSErr	CreateExtendedAllocationsFCB( SGlo
 		err = CheckFileExtents( GPtr, kHFSStartupFileID, 0, (void *)fcb->fcbExtents32, &numABlks );
 		if (err) goto exit;
 
-		fcb->fcbLogicalSize  = volumeHeader->startupFile.logicalSize;
-		fcb->fcbPhysicalSize = (UInt64) volumeHeader->startupFile.totalBlocks * 
-								(UInt64) volumeHeader->blockSize; 
+		fcb->fcbLogicalSize  = SWAP_BE64(volumeHeader->startupFile.logicalSize);
+		fcb->fcbPhysicalSize = (UInt64) SWAP_BE32(volumeHeader->startupFile.totalBlocks) * 
+								(UInt64) SWAP_BE32(volumeHeader->blockSize); 
 	}
 
 exit:
@@ -1308,7 +1309,7 @@ OSErr CatHChk( SGlobPtr GPtr )
 		dprP = &(*GPtr->DirPTPtr)[GPtr->DirLevel -1];
 		
 		validKeyFound = true;
-		record.recordType = 0;
+		SET_SWAP_BE16(record.recordType, 0);
 		
 		//	get the next record
 		result = GetBTreeRecord( GPtr->calculatedCatalogFCB, selCode, &foundKey, &record, &recSize, &hint );
@@ -1334,20 +1335,20 @@ OSErr CatHChk( SGlobPtr GPtr )
 		//
 		//	 if same ParID ...
 		//
-		parID = isHFSPlus == true ? foundKey.hfsPlus.parentID : foundKey.hfs.parentID;
+		parID = isHFSPlus == true ? SWAP_BE32(foundKey.hfsPlus.parentID) : SWAP_BE32(foundKey.hfs.parentID);
 		if ( (validKeyFound == true) && (parID == dprP->directoryID) )
 		{
 			dprP->offspringIndex++;								/* increment offspring index */
 
 			//	if new directory ...
 	
-			if ( record.recordType == kHFSPlusFolderRecord )
+			if ( SWAP_BE16(record.recordType) == kHFSPlusFolderRecord )
 			{
  				result = CheckForStop( GPtr ); ReturnIfError( result );				//	Permit the user to interrupt
 			
 				largeCatalogFolderP = (HFSPlusCatalogFolder *) &record;				
-				GPtr->TarID = largeCatalogFolderP->folderID;				//	target ID = directory ID 
-				GPtr->CNType = record.recordType;							//	target CNode type = directory ID 
+				GPtr->TarID = SWAP_BE32(largeCatalogFolderP->folderID);				//	target ID = directory ID 
+				GPtr->CNType = SWAP_BE16(record.recordType);							//	target CNode type = directory ID 
 				CopyCatalogName( (const CatalogName *) &foundKey.hfsPlus.nodeName, &GPtr->CName, isHFSPlus );
 
 				if ( dprP->directoryID > 1 )
@@ -1365,10 +1366,10 @@ OSErr CatHChk( SGlobPtr GPtr )
 				}
 
 				dprP = &(*GPtr->DirPTPtr)[GPtr->DirLevel -1];
-				dprP->directoryID		= largeCatalogFolderP->folderID;
+				dprP->directoryID		= SWAP_BE32(largeCatalogFolderP->folderID);
 				dprP->offspringIndex	= 1;
 				dprP->directoryHint		= hint;
-				dprP->parentDirID		= foundKey.hfsPlus.parentID;
+				dprP->parentDirID		= SWAP_BE32(foundKey.hfsPlus.parentID);
 				CopyCatalogName( (const CatalogName *) &foundKey.hfsPlus.nodeName, &dprP->directoryName, isHFSPlus );
 
 				for ( i = 1; i < GPtr->DirLevel; i++ )
@@ -1404,8 +1405,8 @@ OSErr CatHChk( SGlobPtr GPtr )
 					 */
 					for (mtp = GPtr->missingThreadList; mtp != NULL; mtp = mtp->link) {
 						if (mtp->threadID == dprP->directoryID) {
-							mtp->thread.recordType = kHFSPlusFolderThreadRecord;
-							mtp->thread.parentID = dprP->parentDirID;
+							SET_SWAP_BE16(mtp->thread.recordType, kHFSPlusFolderThreadRecord);
+							SET_SWAP_BE32(mtp->thread.parentID, dprP->parentDirID);
 							CopyCatalogName(&dprP->directoryName, (CatalogName *)&mtp->thread.nodeName, isHFSPlus);
 
 							/* Reposition to the first child of target directory */
@@ -1434,24 +1435,24 @@ OSErr CatHChk( SGlobPtr GPtr )
 			}
 
 			//	LargeCatalogFile
-			else if ( record.recordType == kHFSPlusFileRecord )
+			else if ( SWAP_BE16(record.recordType) == kHFSPlusFileRecord )
 			{
 				largeCatalogFileP = (HFSPlusCatalogFile *) &record;
-				GPtr->TarID = largeCatalogFileP->fileID;					//	target ID = file number 
-				GPtr->CNType = record.recordType;							//	target CNode type = thread 
+				GPtr->TarID = SWAP_BE32(largeCatalogFileP->fileID);					//	target ID = file number 
+				GPtr->CNType = SWAP_BE16(record.recordType);							//	target CNode type = thread 
 				CopyCatalogName( (const CatalogName *) &foundKey.hfsPlus.nodeName, &GPtr->CName, isHFSPlus );
 				filCnt++;
 				if (dprP->directoryID == kHFSRootFolderID)
 					rtfilCnt++;
 			}	
 
-			else if ( record.recordType == kHFSFolderRecord )
+			else if ( SWAP_BE16(record.recordType) == kHFSFolderRecord )
 			{
  				result = CheckForStop( GPtr ); ReturnIfError( result );				//	Permit the user to interrupt
 			
 				smallCatalogFolderP = (HFSCatalogFolder *) &record;				
-				GPtr->TarID = smallCatalogFolderP->folderID;				/* target ID = directory ID */
-				GPtr->CNType = record.recordType;							/* target CNode type = directory ID */
+				GPtr->TarID = SWAP_BE32(smallCatalogFolderP->folderID);				/* target ID = directory ID */
+				GPtr->CNType = SWAP_BE16(record.recordType);							/* target CNode type = directory ID */
 				CopyCatalogName( (const CatalogName *) &key.hfs.nodeName, &GPtr->CName, isHFSPlus );	/* target CName = directory name */
 
 				if (dprP->directoryID > 1)
@@ -1469,10 +1470,10 @@ OSErr CatHChk( SGlobPtr GPtr )
 				}
 
 				dprP = &(*GPtr->DirPTPtr)[GPtr->DirLevel -1];			
-				dprP->directoryID		= smallCatalogFolderP->folderID;
+				dprP->directoryID		= SWAP_BE32(smallCatalogFolderP->folderID);
 				dprP->offspringIndex	= 1;
 				dprP->directoryHint		= hint;
-				dprP->parentDirID		= foundKey.hfs.parentID;
+				dprP->parentDirID		= SWAP_BE32(foundKey.hfs.parentID);
 
 				CopyCatalogName( (const CatalogName *) &foundKey.hfs.nodeName, &dprP->directoryName, isHFSPlus );
 
@@ -1498,11 +1499,11 @@ OSErr CatHChk( SGlobPtr GPtr )
 			}
 
 			//	HFSCatalogFile...
-			else if ( record.recordType == kHFSFileRecord )
+			else if ( SWAP_BE16(record.recordType) == kHFSFileRecord )
 			{
 				smallCatalogFileP = (HFSCatalogFile *) &record;
-				GPtr->TarID = smallCatalogFileP->fileID;							/* target ID = file number */
-				GPtr->CNType = record.recordType;									/* target CNode type = thread */
+				GPtr->TarID = SWAP_BE32(smallCatalogFileP->fileID);							/* target ID = file number */
+				GPtr->CNType = SWAP_BE16(record.recordType);									/* target CNode type = thread */
 				CopyCatalogName( (const CatalogName *) &foundKey.hfs.nodeName, &GPtr->CName, isHFSPlus );	/* target CName = directory name */
 				filCnt++;
 				if (dprP->directoryID == kHFSRootFolderID)
@@ -1512,7 +1513,7 @@ OSErr CatHChk( SGlobPtr GPtr )
 			//	Unknown/Bad record type
 			else
 			{
-				M_DebugStr("\p Unknown-Bad record type");
+				M_DebugStr(" Unknown-Bad record type");
 				return( 123 );
 			}
 		} 
@@ -1520,18 +1521,18 @@ OSErr CatHChk( SGlobPtr GPtr )
 		//
 		//	 if not same ParID or no record
 		//
-		else if ( (record.recordType == kHFSFileThreadRecord) || (record.recordType == kHFSPlusFileThreadRecord) )			/* it's a file thread, skip past it */
+		else if ( (SWAP_BE16(record.recordType) == kHFSFileThreadRecord) || (SWAP_BE16(record.recordType) == kHFSPlusFileThreadRecord) )			/* it's a file thread, skip past it */
 		{
 			GPtr->TarID				= parID;						//	target ID = file number
-			GPtr->CNType			= record.recordType;			//	target CNode type = thread
-			GPtr->CName.ustr.length	= 0;							//	no target CName
+			GPtr->CNType			= SWAP_BE16(record.recordType);			//	target CNode type = thread
+			SET_SWAP_BE16(GPtr->CName.ustr.length, 0);							//	no target CName
 		}
 		
 		else
 		{
 resumeAtParent:
 			GPtr->TarID = dprP->directoryID;						/* target ID = current directory ID */
-			GPtr->CNType = record.recordType;						/* target CNode type = directory */
+			GPtr->CNType = SWAP_BE16(record.recordType);						/* target CNode type = directory */
 			CopyCatalogName( (const CatalogName *) &dprP->directoryName, &GPtr->CName, isHFSPlus );	// copy the string name
 
 			//	re-locate current directory
@@ -1547,10 +1548,11 @@ resumeAtParent:
 			GPtr->TarBlock = hint;									/* set target block */
 			
 
-			valence = isHFSPlus == true ? record2.hfsPlusFolder.valence : (UInt32)record2.hfsFolder.valence;
+			valence = isHFSPlus == true ? SWAP_BE32(record2.hfsPlusFolder.valence) : (UInt32)SWAP_BE16(record2.hfsFolder.valence);
 
 			if ( valence != dprP->offspringIndex -1 ) 				/* check its valence */
-				if ( result = RcdValErr( GPtr, E_DirVal, dprP->offspringIndex -1, valence, dprP->parentDirID ) )
+				result = RcdValErr( GPtr, E_DirVal, dprP->offspringIndex -1, valence, dprP->parentDirID );
+				if ( result )
 					return( result );
 
 			GPtr->DirLevel--;										/* move up a level */			
@@ -1559,7 +1561,7 @@ resumeAtParent:
 			{										
 				dprP = &(*GPtr->DirPTPtr)[GPtr->DirLevel -1];
 				GPtr->TarID	= dprP->directoryID;					/* target ID = current directory ID */
-				GPtr->CNType = record.recordType;					/* target CNode type = directory */
+				GPtr->CNType = SWAP_BE16(record.recordType);					/* target CNode type = directory */
 				CopyCatalogName( (const CatalogName *) &dprP->directoryName, &GPtr->CName, isHFSPlus );
 			}
 		}
@@ -1569,19 +1571,23 @@ resumeAtParent:
 	//	verify directory and file counts (all nonfatal, repairable errors)
 	//
 	if (!isHFSPlus && (rtdirCnt != calculatedVCB->vcbNmRtDirs)) /* check count of dirs in root */
-		if ( result = RcdValErr(GPtr,E_RtDirCnt,rtdirCnt,calculatedVCB->vcbNmRtDirs,0) )
+		result = RcdValErr(GPtr,E_RtDirCnt,rtdirCnt,calculatedVCB->vcbNmRtDirs,0);
+		if ( result )
 			return( result );
 
 	if (!isHFSPlus && (rtfilCnt != calculatedVCB->vcbNmFls)) /* check count of files in root */
-		if ( result = RcdValErr(GPtr,E_RtFilCnt,rtfilCnt,calculatedVCB->vcbNmFls,0) )
+		result = RcdValErr(GPtr,E_RtFilCnt,rtfilCnt,calculatedVCB->vcbNmFls,0);
+		if ( result )
 			return( result );
 
 	if (dirCnt != calculatedVCB->vcbFolderCount) /* check count of dirs in volume */
-		if ( result = RcdValErr(GPtr,E_DirCnt,dirCnt,calculatedVCB->vcbFolderCount,0) )
+		result = RcdValErr(GPtr,E_DirCnt,dirCnt,calculatedVCB->vcbFolderCount,0);
+		if ( result )
 			return( result );
 		
 	if (filCnt != calculatedVCB->vcbFileCount) /* check count of files in volume */
-		if ( result = RcdValErr(GPtr,E_FilCnt,filCnt,calculatedVCB->vcbFileCount,0) )
+		result = RcdValErr(GPtr,E_FilCnt,filCnt,calculatedVCB->vcbFileCount,0);
+		if ( result )
 			return( result );
 
 	return( noErr );
@@ -1635,7 +1641,7 @@ OSErr	CreateAttributesBTreeControlBlock(
 		err = CheckFileExtents( GPtr, kHFSAttributesFileID, 0, (void *)GPtr->calculatedAttributesFCB->fcbExtents32, &numABlks );	
 		if (err) goto exit;
 
-		if ( volumeHeader->attributesFile.totalBlocks != numABlks )					//	check out the PEOF
+		if ( SWAP_BE32(volumeHeader->attributesFile.totalBlocks) != numABlks )					//	check out the PEOF
 		{
 			RcdError( GPtr, E_CatPEOF );
 			err = E_CatPEOF;
@@ -1643,9 +1649,9 @@ OSErr	CreateAttributesBTreeControlBlock(
 		}
 		else
 		{
-			GPtr->calculatedAttributesFCB->fcbLogicalSize  = (UInt64) volumeHeader->attributesFile.logicalSize;						//	Set Attributes tree's LEOF
-			GPtr->calculatedAttributesFCB->fcbPhysicalSize = (UInt64) volumeHeader->attributesFile.totalBlocks * 
-											(UInt64) volumeHeader->blockSize;	//	Set Attributes tree's PEOF
+			GPtr->calculatedAttributesFCB->fcbLogicalSize  = (UInt64) SWAP_BE64(volumeHeader->attributesFile.logicalSize);						//	Set Attributes tree's LEOF
+			GPtr->calculatedAttributesFCB->fcbPhysicalSize = (UInt64) SWAP_BE32(volumeHeader->attributesFile.totalBlocks) * 
+											(UInt64) SWAP_BE32(volumeHeader->blockSize);	//	Set Attributes tree's PEOF
 		}
 
 		//
@@ -1677,16 +1683,16 @@ OSErr	CreateAttributesBTreeControlBlock(
 
 			btcb->maxKeyLength		= kAttributeKeyMaximumLength;					//	max key length
 			btcb->keyCompareProc	= (void *)CompareAttributeKeys;
-			btcb->leafRecords		= header.leafRecords;
-			btcb->nodeSize			= header.nodeSize;
+			btcb->leafRecords		= SWAP_BE32(header.leafRecords);
+			btcb->nodeSize			= SWAP_BE16(header.nodeSize);
 			btcb->totalNodes		= ( GPtr->calculatedAttributesFCB->fcbPhysicalSize / btcb->nodeSize );
 			btcb->freeNodes			= btcb->totalNodes;									//	start with everything free
 			btcb->attributes		|=(kBTBigKeysMask + kBTVariableIndexKeysMask);		//	HFS+ Attributes files have large, variable-sized keys
 
-			btcb->treeDepth		= header.treeDepth;
-			btcb->rootNode		= header.rootNode;
-			btcb->firstLeafNode	= header.firstLeafNode;
-			btcb->lastLeafNode	= header.lastLeafNode;
+			btcb->treeDepth		= SWAP_BE16(header.treeDepth);
+			btcb->rootNode		= SWAP_BE32(header.rootNode);
+			btcb->firstLeafNode	= SWAP_BE32(header.firstLeafNode);
+			btcb->lastLeafNode	= SWAP_BE32(header.lastLeafNode);
 
 			//
 			//	Make sure the header nodes size field is correct by looking at the 1st record offset
@@ -1744,7 +1750,7 @@ OSErr	CreateAttributesBTreeControlBlock(
 		}
 
 		((BTreeExtensionsRec*)btcb->refCon)->BTCBMSize			= size;						//	remember how long it is
-		((BTreeExtensionsRec*)btcb->refCon)->realFreeNodeCount	= header.freeNodes;		//	keep track of real free nodes for progress
+		((BTreeExtensionsRec*)btcb->refCon)->realFreeNodeCount	= SWAP_BE32(header.freeNodes);		//	keep track of real free nodes for progress
 	}
 
 exit:
@@ -1968,8 +1974,8 @@ static	OSErr	RcdMDBEmbededVolDescription
 	
 	p->type							=  type;							//	save error info
 	desc							=  (EmbededVolDescription *) &(p->name);
-	desc->drAlBlSt					=  mdb->drAlBlSt;
-	desc->drEmbedSigWord			=  mdb->drEmbedSigWord;
+	desc->drAlBlSt					=  SWAP_BE16(mdb->drAlBlSt);
+	desc->drEmbedSigWord			=  SWAP_BE16(mdb->drEmbedSigWord);
 	desc->drEmbedExtent.startBlock	=  mdb->drEmbedExtent.startBlock;
 	desc->drEmbedExtent.blockCount	=  mdb->drEmbedExtent.blockCount;
 	
@@ -2121,28 +2127,28 @@ OSErr VInfoChk( SGlobPtr GPtr )
 		maxClump = (vcb->vcbTotalBlocks / 4) * vcb->vcbBlockSize; /* max clump = 1/4 volume size */
 
 		//	check out creation and last mod dates
-		vcb->vcbCreateDate	= alternateVolumeHeader->createDate;	// use creation date in alt MDB
-		vcb->vcbModifyDate	= volumeHeader->modifyDate;		// don't change last mod date
-		vcb->vcbCheckedDate	= volumeHeader->checkedDate;		// don't change checked date
+		vcb->vcbCreateDate	= SWAP_BE32(alternateVolumeHeader->createDate);	// use creation date in alt MDB
+		vcb->vcbModifyDate	= SWAP_BE32(volumeHeader->modifyDate);		// don't change last mod date
+		vcb->vcbCheckedDate	= SWAP_BE32(volumeHeader->checkedDate);		// don't change checked date
 
 		//	verify volume attribute flags
-		if ( ((UInt16)volumeHeader->attributes & VAtrb_Msk) == 0 )
-			vcb->vcbAttributes = (UInt16)volumeHeader->attributes;
+		if ( ((UInt16)SWAP_BE32(volumeHeader->attributes) & VAtrb_Msk) == 0 )
+			vcb->vcbAttributes = (UInt16)SWAP_BE32(volumeHeader->attributes);
 		else 
 			vcb->vcbAttributes = VAtrb_DFlt;
 	
 		//	verify allocation map ptr
-		if ( volumeHeader->nextAllocation < vcb->vcbTotalBlocks )
-			vcb->vcbNextAllocation = volumeHeader->nextAllocation;
+		if ( SWAP_BE32(volumeHeader->nextAllocation) < vcb->vcbTotalBlocks )
+			vcb->vcbNextAllocation = SWAP_BE32(volumeHeader->nextAllocation);
 		else
 			vcb->vcbNextAllocation = 0;
 
 		
 		//	verify default clump sizes
-		if ( (volumeHeader->rsrcClumpSize > 0) && (volumeHeader->rsrcClumpSize <= kMaxClumpSize) && ((volumeHeader->rsrcClumpSize % vcb->vcbBlockSize) == 0) )
-			vcb->vcbRsrcClumpSize = volumeHeader->rsrcClumpSize;
-		else if ( (alternateVolumeHeader->rsrcClumpSize > 0) && (alternateVolumeHeader->rsrcClumpSize <= kMaxClumpSize) && ((alternateVolumeHeader->rsrcClumpSize % vcb->vcbBlockSize) == 0) )
-			vcb->vcbRsrcClumpSize = alternateVolumeHeader->rsrcClumpSize;
+		if ( (SWAP_BE32(volumeHeader->rsrcClumpSize) > 0) && (SWAP_BE32(volumeHeader->rsrcClumpSize) <= kMaxClumpSize) && ((SWAP_BE32(volumeHeader->rsrcClumpSize) % vcb->vcbBlockSize) == 0) )
+			vcb->vcbRsrcClumpSize = SWAP_BE32(volumeHeader->rsrcClumpSize);
+		else if ( (SWAP_BE32(alternateVolumeHeader->rsrcClumpSize) > 0) && (SWAP_BE32(alternateVolumeHeader->rsrcClumpSize) <= kMaxClumpSize) && ((SWAP_BE32(alternateVolumeHeader->rsrcClumpSize) % vcb->vcbBlockSize) == 0) )
+			vcb->vcbRsrcClumpSize = SWAP_BE32(alternateVolumeHeader->rsrcClumpSize);
 		else
 			vcb->vcbRsrcClumpSize = 4 * vcb->vcbBlockSize;
 	
@@ -2150,10 +2156,10 @@ OSErr VInfoChk( SGlobPtr GPtr )
 			vcb->vcbRsrcClumpSize = vcb->vcbBlockSize;	/* for very large volumes, just use 1 allocation block */
 
 
-		if ( (volumeHeader->dataClumpSize > 0) && (volumeHeader->dataClumpSize <= kMaxClumpSize) && ((volumeHeader->dataClumpSize % vcb->vcbBlockSize) == 0) )
-			vcb->vcbDataClumpSize = volumeHeader->dataClumpSize;
-		else if ( (alternateVolumeHeader->dataClumpSize > 0) && (alternateVolumeHeader->dataClumpSize <= kMaxClumpSize) && ((alternateVolumeHeader->dataClumpSize % vcb->vcbBlockSize) == 0) )
-			vcb->vcbDataClumpSize = alternateVolumeHeader->dataClumpSize;
+		if ( (SWAP_BE32(volumeHeader->dataClumpSize) > 0) && (SWAP_BE32(volumeHeader->dataClumpSize) <= kMaxClumpSize) && ((SWAP_BE32(volumeHeader->dataClumpSize) % vcb->vcbBlockSize) == 0) )
+			vcb->vcbDataClumpSize = SWAP_BE32(volumeHeader->dataClumpSize);
+		else if ( (SWAP_BE32(alternateVolumeHeader->dataClumpSize) > 0) && (SWAP_BE32(alternateVolumeHeader->dataClumpSize) <= kMaxClumpSize) && ((SWAP_BE32(alternateVolumeHeader->dataClumpSize) % vcb->vcbBlockSize) == 0) )
+			vcb->vcbDataClumpSize = SWAP_BE32(alternateVolumeHeader->dataClumpSize);
 		else
 			vcb->vcbDataClumpSize = 4 * vcb->vcbBlockSize;
 	
@@ -2162,43 +2168,43 @@ OSErr VInfoChk( SGlobPtr GPtr )
 
 
 		//	verify next CNode ID
-		if ( (volumeHeader->nextCatalogID > vcb->vcbNextCatalogID) && (volumeHeader->nextCatalogID <= (vcb->vcbNextCatalogID + 4096)) )
-			vcb->vcbNextCatalogID = volumeHeader->nextCatalogID;
+		if ( (SWAP_BE32(volumeHeader->nextCatalogID) > vcb->vcbNextCatalogID) && (SWAP_BE32(volumeHeader->nextCatalogID) <= (vcb->vcbNextCatalogID + 4096)) )
+			vcb->vcbNextCatalogID = SWAP_BE32(volumeHeader->nextCatalogID);
 			
 		//ееTBD location and unicode? volumename
 		//	verify the volume name
 		result = ChkCName( GPtr, (const CatalogName*) &foundKey.hfsPlus.nodeName, isHFSPlus );
 
 		//	verify last backup date and backup seqence number
-		vcb->vcbBackupDate = volumeHeader->backupDate;					/* don't change last backup date */
+		vcb->vcbBackupDate = SWAP_BE32(volumeHeader->backupDate);					/* don't change last backup date */
 		
 		//	verify write count
-		vcb->vcbWriteCount = volumeHeader->writeCount;	/* don't change write count */
+		vcb->vcbWriteCount = SWAP_BE32(volumeHeader->writeCount);	/* don't change write count */
 
 
 		//	check out extent file clump size
-		if ( ((volumeHeader->extentsFile.clumpSize % vcb->vcbBlockSize) == 0) && (volumeHeader->extentsFile.clumpSize <= maxClump) )
-			vcb->vcbExtentsFile->fcbClumpSize = volumeHeader->extentsFile.clumpSize;
-		else if ( ((alternateVolumeHeader->extentsFile.clumpSize % vcb->vcbBlockSize) == 0) && (alternateVolumeHeader->extentsFile.clumpSize <= maxClump) )
-			vcb->vcbExtentsFile->fcbClumpSize = alternateVolumeHeader->extentsFile.clumpSize;
+		if ( ((SWAP_BE32(volumeHeader->extentsFile.clumpSize) % vcb->vcbBlockSize) == 0) && (SWAP_BE32(volumeHeader->extentsFile.clumpSize) <= maxClump) )
+			vcb->vcbExtentsFile->fcbClumpSize = SWAP_BE32(volumeHeader->extentsFile.clumpSize);
+		else if ( ((SWAP_BE32(alternateVolumeHeader->extentsFile.clumpSize) % vcb->vcbBlockSize) == 0) && (SWAP_BE32(alternateVolumeHeader->extentsFile.clumpSize) <= maxClump) )
+			vcb->vcbExtentsFile->fcbClumpSize = SWAP_BE32(alternateVolumeHeader->extentsFile.clumpSize);
 		else		
-			vcb->vcbExtentsFile->fcbClumpSize = (alternateVolumeHeader->extentsFile.extents[0].blockCount * vcb->vcbBlockSize);
+			vcb->vcbExtentsFile->fcbClumpSize = (SWAP_BE32(alternateVolumeHeader->extentsFile.extents[0].blockCount) * vcb->vcbBlockSize);
 			
 		//	check out extent file clump size
-		if ( ((volumeHeader->catalogFile.clumpSize % vcb->vcbBlockSize) == 0) && (volumeHeader->catalogFile.clumpSize <= maxClump) )
-			vcb->vcbCatalogFile->fcbClumpSize = volumeHeader->catalogFile.clumpSize;
-		else if ( ((alternateVolumeHeader->catalogFile.clumpSize % vcb->vcbBlockSize) == 0) && (alternateVolumeHeader->catalogFile.clumpSize <= maxClump) )
-			vcb->vcbCatalogFile->fcbClumpSize = alternateVolumeHeader->catalogFile.clumpSize;
+		if ( ((SWAP_BE32(volumeHeader->catalogFile.clumpSize) % vcb->vcbBlockSize) == 0) && (SWAP_BE32(volumeHeader->catalogFile.clumpSize) <= maxClump) )
+			vcb->vcbCatalogFile->fcbClumpSize = SWAP_BE32(volumeHeader->catalogFile.clumpSize);
+		else if ( ((SWAP_BE32(alternateVolumeHeader->catalogFile.clumpSize) % vcb->vcbBlockSize) == 0) && (SWAP_BE32(alternateVolumeHeader->catalogFile.clumpSize) <= maxClump) )
+			vcb->vcbCatalogFile->fcbClumpSize = SWAP_BE32(alternateVolumeHeader->catalogFile.clumpSize);
 		else
-			vcb->vcbCatalogFile->fcbClumpSize = (alternateVolumeHeader->catalogFile.extents[0].blockCount * vcb->vcbBlockSize);
+			vcb->vcbCatalogFile->fcbClumpSize = (SWAP_BE32(alternateVolumeHeader->catalogFile.extents[0].blockCount) * vcb->vcbBlockSize);
 	
 		//	check out allocations file clump size
-		if ( ((volumeHeader->allocationFile.clumpSize % vcb->vcbBlockSize) == 0) && (volumeHeader->allocationFile.clumpSize <= maxClump) )
-			vcb->vcbAllocationFile->fcbClumpSize = volumeHeader->allocationFile.clumpSize;
-		else if ( ((alternateVolumeHeader->allocationFile.clumpSize % vcb->vcbBlockSize) == 0) && (alternateVolumeHeader->allocationFile.clumpSize <= maxClump) )
-			vcb->vcbAllocationFile->fcbClumpSize = alternateVolumeHeader->allocationFile.clumpSize;
+		if ( ((SWAP_BE32(volumeHeader->allocationFile.clumpSize) % vcb->vcbBlockSize) == 0) && (SWAP_BE32(volumeHeader->allocationFile.clumpSize) <= maxClump) )
+			vcb->vcbAllocationFile->fcbClumpSize = SWAP_BE32(volumeHeader->allocationFile.clumpSize);
+		else if ( ((SWAP_BE32(alternateVolumeHeader->allocationFile.clumpSize) % vcb->vcbBlockSize) == 0) && (SWAP_BE32(alternateVolumeHeader->allocationFile.clumpSize) <= maxClump) )
+			vcb->vcbAllocationFile->fcbClumpSize = SWAP_BE32(alternateVolumeHeader->allocationFile.clumpSize);
 		else
-			vcb->vcbAllocationFile->fcbClumpSize = (alternateVolumeHeader->allocationFile.extents[0].blockCount * vcb->vcbBlockSize);
+			vcb->vcbAllocationFile->fcbClumpSize = (SWAP_BE32(alternateVolumeHeader->allocationFile.extents[0].blockCount) * vcb->vcbBlockSize);
 	
 
 		CopyMemory( volumeHeader->finderInfo, vcb->vcbFinderInfo, sizeof(vcb->vcbFinderInfo) );
@@ -2239,26 +2245,26 @@ OSErr VInfoChk( SGlobPtr GPtr )
 		maxClump = (vcb->vcbTotalBlocks / 4) * vcb->vcbBlockSize; /* max clump = 1/4 volume size */
 
 		//	check out creation and last mod dates
-		vcb->vcbCreateDate	= alternateMDB->drCrDate;		/* use creation date in alt MDB */	
-		vcb->vcbModifyDate	= mdbP->drLsMod;			/* don't change last mod date */
+		vcb->vcbCreateDate	= SWAP_BE32(alternateMDB->drCrDate);		/* use creation date in alt MDB */	
+		vcb->vcbModifyDate	= SWAP_BE32(mdbP->drLsMod);			/* don't change last mod date */
 
 		//	verify volume attribute flags
-		if ( (mdbP->drAtrb & VAtrb_Msk) == 0 )
-			vcb->vcbAttributes = mdbP->drAtrb;
+		if ( (SWAP_BE16(mdbP->drAtrb) & VAtrb_Msk) == 0 )
+			vcb->vcbAttributes = SWAP_BE16(mdbP->drAtrb);
 		else 
 			vcb->vcbAttributes = VAtrb_DFlt;
 	
 		//	verify allocation map ptr
-		if ( mdbP->drAllocPtr < vcb->vcbTotalBlocks )
-			vcb->vcbNextAllocation = mdbP->drAllocPtr;
+		if ( SWAP_BE16(mdbP->drAllocPtr) < vcb->vcbTotalBlocks )
+			vcb->vcbNextAllocation = SWAP_BE16(mdbP->drAllocPtr);
 		else
 			vcb->vcbNextAllocation = 0;
 
 		//	verify default clump size
-		if ( (mdbP->drClpSiz > 0) && (mdbP->drClpSiz <= maxClump) && ((mdbP->drClpSiz % vcb->vcbBlockSize) == 0) )
-			vcb->vcbDataClumpSize = mdbP->drClpSiz;
-		else if ( (alternateMDB->drClpSiz > 0) && (alternateMDB->drClpSiz <= maxClump) && ((alternateMDB->drClpSiz % vcb->vcbBlockSize) == 0) )
-			vcb->vcbDataClumpSize = alternateMDB->drClpSiz;
+		if ( (SWAP_BE32(mdbP->drClpSiz) > 0) && (SWAP_BE32(mdbP->drClpSiz) <= maxClump) && ((SWAP_BE32(mdbP->drClpSiz) % vcb->vcbBlockSize) == 0) )
+			vcb->vcbDataClumpSize = SWAP_BE32(mdbP->drClpSiz);
+		else if ( (SWAP_BE32(alternateMDB->drClpSiz) > 0) && (SWAP_BE32(alternateMDB->drClpSiz) <= maxClump) && ((SWAP_BE32(alternateMDB->drClpSiz) % vcb->vcbBlockSize) == 0) )
+			vcb->vcbDataClumpSize = SWAP_BE32(alternateMDB->drClpSiz);
 		else
 			vcb->vcbDataClumpSize = 4 * vcb->vcbBlockSize;
 	
@@ -2266,8 +2272,8 @@ OSErr VInfoChk( SGlobPtr GPtr )
 			vcb->vcbDataClumpSize = vcb->vcbBlockSize;	/* for very large volumes, just use 1 allocation block */
 	
 		//	verify next CNode ID
-		if ( (mdbP->drNxtCNID > vcb->vcbNextCatalogID) && (mdbP->drNxtCNID <= (vcb->vcbNextCatalogID + 4096)) )
-			vcb->vcbNextCatalogID = mdbP->drNxtCNID;
+		if ( (SWAP_BE32(mdbP->drNxtCNID) > vcb->vcbNextCatalogID) && (SWAP_BE32(mdbP->drNxtCNID) <= (vcb->vcbNextCatalogID + 4096)) )
+			vcb->vcbNextCatalogID = SWAP_BE32(mdbP->drNxtCNID);
 			
 		//	verify the volume name
 		result = ChkCName( GPtr, (const CatalogName*) &vcb->vcbVN, isHFSPlus );
@@ -2276,26 +2282,26 @@ OSErr VInfoChk( SGlobPtr GPtr )
 				CopyMemory( mdbP->drVN, vcb->vcbVN, kHFSMaxVolumeNameChars + 1 ); /* ...we have a good one */		
 
 		//	verify last backup date and backup seqence number
-		vcb->vcbBackupDate = mdbP->drVolBkUp;		/* don't change last backup date */
-		vcb->vcbVSeqNum = mdbP->drVSeqNum;		/* don't change last backup sequence # */
+		vcb->vcbBackupDate = SWAP_BE32(mdbP->drVolBkUp);		/* don't change last backup date */
+		vcb->vcbVSeqNum = SWAP_BE16(mdbP->drVSeqNum);		/* don't change last backup sequence # */
 		
 		//	verify write count
-		vcb->vcbWriteCount = mdbP->drWrCnt;						/* don't change write count */
+		vcb->vcbWriteCount = SWAP_BE32(mdbP->drWrCnt);						/* don't change write count */
 
 		//	check out extent file and catalog clump sizes
-		if ( ((mdbP->drXTClpSiz % vcb->vcbBlockSize) == 0) && (mdbP->drXTClpSiz <= maxClump) )
-			vcb->vcbExtentsFile->fcbClumpSize = mdbP->drXTClpSiz;
-		else if ( ((alternateMDB->drXTClpSiz % vcb->vcbBlockSize) == 0) && (alternateMDB->drXTClpSiz <= maxClump) )
-			vcb->vcbExtentsFile->fcbClumpSize = alternateMDB->drXTClpSiz;
+		if ( ((SWAP_BE32(mdbP->drXTClpSiz) % vcb->vcbBlockSize) == 0) && (SWAP_BE32(mdbP->drXTClpSiz) <= maxClump) )
+			vcb->vcbExtentsFile->fcbClumpSize = SWAP_BE32(mdbP->drXTClpSiz);
+		else if ( ((SWAP_BE32(alternateMDB->drXTClpSiz) % vcb->vcbBlockSize) == 0) && (SWAP_BE32(alternateMDB->drXTClpSiz) <= maxClump) )
+			vcb->vcbExtentsFile->fcbClumpSize = SWAP_BE32(alternateMDB->drXTClpSiz);
 		else		
-			vcb->vcbExtentsFile->fcbClumpSize = (alternateMDB->drXTExtRec[0].blockCount * vcb->vcbBlockSize);
+			vcb->vcbExtentsFile->fcbClumpSize = (SWAP_BE16(alternateMDB->drXTExtRec[0].blockCount) * vcb->vcbBlockSize);
 			
-		if ( ((mdbP->drCTClpSiz % vcb->vcbBlockSize) == 0) && (mdbP->drCTClpSiz <= maxClump) )
-			vcb->vcbCatalogFile->fcbClumpSize = mdbP->drCTClpSiz;
-		else if ( ((alternateMDB->drCTClpSiz % vcb->vcbBlockSize) == 0) && (alternateMDB->drCTClpSiz <= maxClump) )
-			vcb->vcbCatalogFile->fcbClumpSize = alternateMDB->drCTClpSiz;
+		if ( ((SWAP_BE32(mdbP->drCTClpSiz) % vcb->vcbBlockSize) == 0) && (SWAP_BE32(mdbP->drCTClpSiz) <= maxClump) )
+			vcb->vcbCatalogFile->fcbClumpSize = SWAP_BE32(mdbP->drCTClpSiz);
+		else if ( ((SWAP_BE32(alternateMDB->drCTClpSiz) % vcb->vcbBlockSize) == 0) && (SWAP_BE32(alternateMDB->drCTClpSiz) <= maxClump) )
+			vcb->vcbCatalogFile->fcbClumpSize = SWAP_BE32(alternateMDB->drCTClpSiz);
 		else
-			vcb->vcbCatalogFile->fcbClumpSize = (alternateMDB->drCTExtRec[0].blockCount * vcb->vcbBlockSize);
+			vcb->vcbCatalogFile->fcbClumpSize = (SWAP_BE16(alternateMDB->drCTExtRec[0].blockCount) * vcb->vcbBlockSize);
 	
 		//	just copy Finder info for now
 		CopyMemory(mdbP->drFndrInfo, vcb->vcbFinderInfo, sizeof(mdbP->drFndrInfo));
@@ -2390,9 +2396,9 @@ OSErr	VLockedChk( SGlobPtr GPtr )
 	else
 		CopyCatalogName( (const CatalogName *)&foundKey.hfs.nodeName, &GPtr->CName, isHFSPlus );
 	
-	if ( (record.recordType == kHFSPlusFolderRecord) || (record.recordType == kHFSFolderRecord) )
+	if ( (SWAP_BE16(record.recordType) == kHFSPlusFolderRecord) || (SWAP_BE16(record.recordType) == kHFSFolderRecord) )
 	{
-		frFlags = record.recordType == kHFSPlusFolderRecord ? record.hfsPlusFolder.userInfo.frFlags : record.hfsFolder.userInfo.frFlags;
+		frFlags = SWAP_BE16(record.recordType) == kHFSPlusFolderRecord ? SWAP_BE16(record.hfsPlusFolder.userInfo.frFlags) : SWAP_BE16(record.hfsFolder.userInfo.frFlags);
 	
 		if ( frFlags & fNameLocked )												// name locked bit set?
 			RcdNameLockedErr( GPtr, E_LockedDirName, frFlags );
@@ -2494,13 +2500,13 @@ OSErr	CheckFileExtents( SGlobPtr GPtr, U
 			//	HFS+/HFS moving extent fields into local variables for evaluation
 			if ( isHFSPlus == true )
 			{
-				extentBlockCount = ((HFSPlusExtentDescriptor *)extents)[i].blockCount;
-				extentStartBlock = ((HFSPlusExtentDescriptor *)extents)[i].startBlock;
+				extentBlockCount = SWAP_BE32(((HFSPlusExtentDescriptor *)extents)[i].blockCount);
+				extentStartBlock = SWAP_BE32(((HFSPlusExtentDescriptor *)extents)[i].startBlock);
 			}
 			else
 			{
-				extentBlockCount = ((HFSExtentDescriptor *)extents)[i].blockCount;
-				extentStartBlock = ((HFSExtentDescriptor *)extents)[i].startBlock;
+				extentBlockCount = SWAP_BE16(((HFSExtentDescriptor *)extents)[i].blockCount);
+				extentStartBlock = SWAP_BE16(((HFSExtentDescriptor *)extents)[i].startBlock);
 			}
 	
 			if ( extentBlockCount == 0 )
@@ -2556,12 +2562,12 @@ OSErr	CheckFileExtents( SGlobPtr GPtr, U
 			//	Check same file and fork
 			if ( isHFSPlus )
 			{
-				if ( (extentKey.fileID != fileNumber) || (extentKey.forkType != forkType) )
+				if ( (SWAP_BE32(extentKey.fileID) != fileNumber) || (extentKey.forkType != forkType) )
 					break;
 			}
 			else
 			{
-				if ( (((HFSExtentKey *) &extentKey)->fileID != fileNumber) || (((HFSExtentKey *) &extentKey)->forkType != forkType) )
+				if ( (SWAP_BE32(((HFSExtentKey *) &extentKey)->fileID) != fileNumber) || (((HFSExtentKey *) &extentKey)->forkType != forkType) )
 					break;
 			}
 		}
@@ -2581,11 +2587,11 @@ void	BuildExtentKey( Boolean isHFSPlus, 
 	{
 		HFSPlusExtentKey *hfsPlusKey	= (HFSPlusExtentKey*) key;
 		
-		hfsPlusKey->keyLength	= kHFSPlusExtentKeyMaximumLength;
+		SET_SWAP_BE16(hfsPlusKey->keyLength, kHFSPlusExtentKeyMaximumLength);
 		hfsPlusKey->forkType	= forkType;
 		hfsPlusKey->pad			= 0;
-		hfsPlusKey->fileID		= fileNumber;
-		hfsPlusKey->startBlock	= blockNumber;
+		SET_SWAP_BE32(hfsPlusKey->fileID, fileNumber);
+		SET_SWAP_BE32(hfsPlusKey->startBlock, blockNumber);
 	}
 	else
 	{
@@ -2593,8 +2599,8 @@ void	BuildExtentKey( Boolean isHFSPlus, 
 
 		hfsKey->keyLength		= kHFSExtentKeyMaximumLength;
 		hfsKey->forkType		= forkType;
-		hfsKey->fileID			= fileNumber;
-		hfsKey->startBlock		= (UInt16) blockNumber;
+		SET_SWAP_BE32(hfsKey->fileID, fileNumber);
+		SET_SWAP_BE16(hfsKey->startBlock, (UInt16) blockNumber);
 	}
 }
 
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/SVerify2.c diskdev_cmds/fsck_hfs.tproj/dfalib/SVerify2.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/SVerify2.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/SVerify2.c	2003-05-05 12:35:57.000000000 +0200
@@ -68,13 +68,13 @@ OSErr ChkExtRec ( SGlobPtr GPtr, const v
 	{
 		if ( GPtr->isHFSPlus )
 		{
-			extentBlockCount = ((HFSPlusExtentDescriptor *)extents)[i].blockCount;
-			extentStartBlock = ((HFSPlusExtentDescriptor *)extents)[i].startBlock;
+			extentBlockCount = SWAP_BE32(((HFSPlusExtentDescriptor *)extents)[i].blockCount);
+			extentStartBlock = SWAP_BE32(((HFSPlusExtentDescriptor *)extents)[i].startBlock);
 		}
 		else
 		{
-			extentBlockCount = ((HFSExtentDescriptor *)extents)[i].blockCount;
-			extentStartBlock = ((HFSExtentDescriptor *)extents)[i].startBlock;
+			extentBlockCount = SWAP_BE16(((HFSExtentDescriptor *)extents)[i].blockCount);
+			extentStartBlock = SWAP_BE16(((HFSExtentDescriptor *)extents)[i].startBlock);
 		}
 		
 		if ( extentStartBlock >= maxNABlks )
@@ -177,7 +177,7 @@ BTCheck(SGlobPtr GPtr, short refNum, Che
 		result = E_BadHdrN;
 		goto exit;
 	}	
-	if ( nodeDescP->numRecords != Num_HRecs )
+	if ( SWAP_BE16(nodeDescP->numRecords) != Num_HRecs )
 	{
 		RcdError( GPtr, E_BadHdrN );
 		result = E_BadHdrN;
@@ -202,20 +202,20 @@ BTCheck(SGlobPtr GPtr, short refNum, Che
 		result = E_LenBTH;
 		goto exit;
 	}
-	if ( header->treeDepth > BTMaxDepth )
+	if ( SWAP_BE16(header->treeDepth) > BTMaxDepth )
 	{
 		RcdError( GPtr, E_BTDepth );
 		goto RebuildBTreeExit;
 	}
-	calculatedBTCB->treeDepth = header->treeDepth;
+	calculatedBTCB->treeDepth = SWAP_BE16(header->treeDepth);
 	
-	if ( header->rootNode >= calculatedBTCB->totalNodes ||
-		 (header->treeDepth != 0 && header->rootNode == kHeaderNodeNum) )
+	if ( SWAP_BE32(header->rootNode) >= calculatedBTCB->totalNodes ||
+		 (SWAP_BE16(header->treeDepth) != 0 && SWAP_BE32(header->rootNode) == kHeaderNodeNum) )
 	{
 		RcdError( GPtr, E_BTRoot );
 		goto RebuildBTreeExit;
 	}
-	calculatedBTCB->rootNode = header->rootNode;
+	calculatedBTCB->rootNode = SWAP_BE32(header->rootNode);
 
 	if ( (calculatedBTCB->treeDepth == 0) || (calculatedBTCB->rootNode == 0) )
 	{
@@ -313,7 +313,7 @@ BTCheck(SGlobPtr GPtr, short refNum, Che
 				goto exit;
 			}
 				
-			if ( nodeDescP->bLink != tprP->TPRLtSib )
+			if ( SWAP_BE32(nodeDescP->bLink) != tprP->TPRLtSib )
 			{
 				RcdError( GPtr, E_SibLk );
 				/* bad sibling link can be fixed if it is an index node */
@@ -327,7 +327,7 @@ BTCheck(SGlobPtr GPtr, short refNum, Che
 			}
 			else
 			{
-				if ( nodeDescP->fLink != tprP->TPRRtSib )
+				if ( SWAP_BE32(nodeDescP->fLink) != tprP->TPRRtSib )
 				{				
 					result = E_SibLk;
 					/* bad sibling link can be fixed if it is an index node */
@@ -362,14 +362,15 @@ BTCheck(SGlobPtr GPtr, short refNum, Che
 			}
 			if ( nodeDescP->kind == kBTIndexNode )
  			{
-				if ( result = CheckForStop( GPtr ) )
+				result = CheckForStop( GPtr );
+				if ( result )
 					goto exit;
 			}
 			
 			GPtr->itemsProcessed++;
 		}
 		
-		numRecs = nodeDescP->numRecords;
+		numRecs = SWAP_BE16(nodeDescP->numRecords);
 	
 		/* 
 		 * for an index node ...
@@ -397,7 +398,7 @@ BTCheck(SGlobPtr GPtr, short refNum, Che
 			GetRecordByIndex( (BTreeControlBlock *)calculatedBTCB, nodeDescP, 
 							  index, &keyPtr, &dataPtr, &recSize );
 			
-			nodeNum = *(UInt32*)dataPtr;
+			nodeNum = SWAP_BE32(*(u_big_int32_t *)dataPtr);
 			if ( (nodeNum == kHeaderNodeNum) || (nodeNum >= calculatedBTCB->totalNodes) )
 			{
 				RcdError( GPtr, E_IndxLk );
@@ -409,7 +410,7 @@ BTCheck(SGlobPtr GPtr, short refNum, Che
 			 * with the child's key later.
 			 */
 			keyLen = ( calculatedBTCB->attributes & kBTBigKeysMask )
-						? keyPtr->length16 + sizeof(UInt16)
+						? SWAP_BE16(keyPtr->length16) + sizeof(UInt16)
 						: keyPtr->length8 + sizeof(UInt8);
 			CopyMemory(keyPtr, parKey, keyLen);
 				
@@ -421,7 +422,7 @@ BTCheck(SGlobPtr GPtr, short refNum, Che
 			{
 				GetRecordByIndex( (BTreeControlBlock *)calculatedBTCB, nodeDescP, index-1, &keyPtr, &dataPtr, &recSize );
 
-				nodeNum = *(UInt32*)dataPtr;
+				nodeNum = SWAP_BE32(*(u_big_int32_t*)dataPtr);
 				if ( (nodeNum == kHeaderNodeNum) || (nodeNum >= calculatedBTCB->totalNodes) )
 				{
 					RcdError( GPtr, E_IndxLk );
@@ -439,7 +440,7 @@ BTCheck(SGlobPtr GPtr, short refNum, Che
 			if ( index < (numRecs -1) )
 			{
 				GetRecordByIndex( (BTreeControlBlock *)calculatedBTCB, nodeDescP, index+1, &keyPtr, &dataPtr, &recSize );
-				nodeNum = *(UInt32*)dataPtr;
+				nodeNum = SWAP_BE32(*(u_big_int32_t*)dataPtr);
 				if ( (nodeNum == kHeaderNodeNum) || (nodeNum >= calculatedBTCB->totalNodes) )
 				{
 					RcdError( GPtr, E_IndxLk );
@@ -463,10 +464,10 @@ BTCheck(SGlobPtr GPtr, short refNum, Che
 				calculatedBTCB->firstLeafNode = nodeNum;
 			if ( tprP->TPRRtSib == 0 )
 				calculatedBTCB->lastLeafNode = nodeNum;
-			leafRecords	+= nodeDescP->numRecords;
+			leafRecords	+= SWAP_BE16(nodeDescP->numRecords);
 
 			if (checkLeafRecord != NULL) {
-				for (i = 0; i < nodeDescP->numRecords; i++) {
+				for (i = 0; i < SWAP_BE16(nodeDescP->numRecords); i++) {
 					GetRecordByIndex(calculatedBTCB, nodeDescP, i, &keyPtr, &dataPtr, &recSize);
 					result = checkLeafRecord(keyPtr, dataPtr, recSize);
 					if (result) goto exit;
@@ -561,7 +562,7 @@ int BTMapChk( SGlobPtr GPtr, short fileR
 				result = E_BadMapN;
 				goto exit;
 			}	
-			if ( nodeDescP->numRecords != Num_MRecs )
+			if ( SWAP_BE16(nodeDescP->numRecords) != Num_MRecs )
 			{
 				RcdError( GPtr, E_BadMapN );
 				result = E_BadMapN;
@@ -576,7 +577,7 @@ int BTMapChk( SGlobPtr GPtr, short fileR
 		mapSize -= recSize;	/* Adjust remaining map size */
 
 		recIndx	= 0;	/* Map record is now record 0 */	
-		nodeNum	= nodeDescP->fLink;						
+		nodeNum	= SWAP_BE32(nodeDescP->fLink);						
 		if (nodeNum == 0)
 			break;
 	
@@ -636,23 +637,23 @@ OSErr	CmpBTH( SGlobPtr GPtr, SInt16 file
 	err = GetBTreeHeader(GPtr, fcb, &bTreeHeader );
 	ReturnIfError( err );
 
-	if (calculatedBTCB->leafRecords != bTreeHeader.leafRecords) {
+	if (calculatedBTCB->leafRecords != SWAP_BE32(bTreeHeader.leafRecords)) {
 		char goodStr[32], badStr[32];
 
 		*statP = *statP | S_BTH;
 		PrintError(GPtr, E_LeafCnt, 0);
 		sprintf(goodStr, "%ld", (long)calculatedBTCB->leafRecords);
-		sprintf(badStr, "%ld", (long)bTreeHeader.leafRecords);
+		sprintf(badStr, "%ld", (long)SWAP_BE32(bTreeHeader.leafRecords));
 		PrintError(GPtr, E_BadValue, 2, goodStr, badStr);
 	} else if (
-	    (calculatedBTCB->treeDepth	   != bTreeHeader.treeDepth)	 ||
-	    (calculatedBTCB->rootNode	   != bTreeHeader.rootNode)	 ||
-	    (calculatedBTCB->firstLeafNode != bTreeHeader.firstLeafNode) ||
-	    (calculatedBTCB->lastLeafNode  != bTreeHeader.lastLeafNode)  ||
-	    (calculatedBTCB->nodeSize	   != bTreeHeader.nodeSize)	 ||
-	    (calculatedBTCB->maxKeyLength  != bTreeHeader.maxKeyLength)  ||
-	    (calculatedBTCB->totalNodes    != bTreeHeader.totalNodes)	 ||
-	    (calculatedBTCB->freeNodes	   != bTreeHeader.freeNodes) ) {
+	    (calculatedBTCB->treeDepth	   != SWAP_BE16(bTreeHeader.treeDepth))	 ||
+	    (calculatedBTCB->rootNode	   != SWAP_BE32(bTreeHeader.rootNode))	 ||
+	    (calculatedBTCB->firstLeafNode != SWAP_BE32(bTreeHeader.firstLeafNode)) ||
+	    (calculatedBTCB->lastLeafNode  != SWAP_BE32(bTreeHeader.lastLeafNode))  ||
+	    (calculatedBTCB->nodeSize	   != SWAP_BE16(bTreeHeader.nodeSize))	 ||
+	    (calculatedBTCB->maxKeyLength  != SWAP_BE16(bTreeHeader.maxKeyLength))  ||
+	    (calculatedBTCB->totalNodes    != SWAP_BE32(bTreeHeader.totalNodes))	 ||
+	    (calculatedBTCB->freeNodes	   != SWAP_BE32(bTreeHeader.freeNodes)) ) {
 
 		*statP = *statP | S_BTH;
 		PrintError(GPtr, E_InvalidBTreeHeader, 0);
@@ -767,7 +768,7 @@ int CmpBTM( SGlobPtr GPtr, short fileRef
 		recIndx	= 0;			/* map record is now record 0 */			
 		mapSize	-= size;		/* adjust remaining map size */
 		sbtmP	= sbtmP + size;
-		nodeNum	= nodeDescP->fLink;	/* next node number */						
+		nodeNum	= SWAP_BE32(nodeDescP->fLink);	/* next node number */						
 		if (nodeNum == 0)
 			break;
 	
@@ -815,9 +816,9 @@ static int BTKeyChk( SGlobPtr GPtr, Node
 	KeyPtr				prevkeyP	= nil;
 
 
-	if ( nodeP->numRecords == 0 )
+	if ( SWAP_BE16(nodeP->numRecords) == 0 )
 	{
-		if ( (nodeP->fLink == 0) && (nodeP->bLink == 0) )
+		if ( (SWAP_BE32(nodeP->fLink) == 0) && (SWAP_BE32(nodeP->bLink) == 0) )
 		{
 			RcdError( GPtr, E_BadNode );
 			return( E_BadNode );
@@ -828,12 +829,12 @@ static int BTKeyChk( SGlobPtr GPtr, Node
 		/*
 		 * Loop on number of records in node
 		 */
-		for ( index = 0; index < nodeP->numRecords; index++)
+		for ( index = 0; index < SWAP_BE16(nodeP->numRecords); index++)
 		{
 			GetRecordByIndex( (BTreeControlBlock *)btcb, nodeP, (UInt16) index, &keyPtr, &dataPtr, &dataSize );
 	
 			if (btcb->attributes & kBTBigKeysMask)
-				keyLength = keyPtr->length16;
+				keyLength = SWAP_BE16(keyPtr->length16);
 			else
 				keyLength = keyPtr->length8;
 				
@@ -937,15 +938,15 @@ int CmpMDB( SGlobPtr GPtr,  HFSMasterDir
 	/* 
 	 * compare VCB info with MDB
 	 */
-	if ( mdbP->drSigWord	!= vcb->vcbSignature )		goto MDBDamaged;
-	if ( mdbP->drCrDate	!= vcb->vcbCreateDate )		goto MDBDamaged;
-	if ( mdbP->drLsMod	!= vcb->vcbModifyDate )		goto MDBDamaged;
-	if ( mdbP->drAtrb	!= (UInt16)vcb->vcbAttributes )	goto MDBDamaged;
-	if ( mdbP->drVBMSt	!= vcb->vcbVBMSt )			goto MDBDamaged;
-	if ( mdbP->drNmAlBlks	!= vcb->vcbTotalBlocks )		goto MDBDamaged;
-	if ( mdbP->drClpSiz	!= vcb->vcbDataClumpSize )		goto MDBDamaged;
-	if ( mdbP->drAlBlSt	!= vcb->vcbAlBlSt )			goto MDBDamaged;
-	if ( mdbP->drNxtCNID	!= vcb->vcbNextCatalogID )		goto MDBDamaged;
+	if ( SWAP_BE16(mdbP->drSigWord)	!= vcb->vcbSignature )		goto MDBDamaged;
+	if ( SWAP_BE32(mdbP->drCrDate)	!= vcb->vcbCreateDate )		goto MDBDamaged;
+	if ( SWAP_BE32(mdbP->drLsMod)	!= vcb->vcbModifyDate )		goto MDBDamaged;
+	if ( SWAP_BE16(mdbP->drAtrb)	!= (UInt16)vcb->vcbAttributes )	goto MDBDamaged;
+	if ( SWAP_BE16(mdbP->drVBMSt)	!= vcb->vcbVBMSt )			goto MDBDamaged;
+	if ( SWAP_BE16(mdbP->drNmAlBlks)	!= vcb->vcbTotalBlocks )		goto MDBDamaged;
+	if ( SWAP_BE32(mdbP->drClpSiz)	!= vcb->vcbDataClumpSize )		goto MDBDamaged;
+	if ( SWAP_BE16(mdbP->drAlBlSt)	!= vcb->vcbAlBlSt )			goto MDBDamaged;
+	if ( SWAP_BE32(mdbP->drNxtCNID)	!= vcb->vcbNextCatalogID )		goto MDBDamaged;
 	if ( CmpBlock( mdbP->drVN, vcb->vcbVN, mdbP->drVN[0]+1 ) )	goto MDBDamaged;
 	goto ContinueChecking;
 
@@ -957,14 +958,14 @@ MDBDamaged:
 	}
 	
 ContinueChecking:
-	if ((mdbP->drVolBkUp	!= vcb->vcbBackupDate)		||
-	    (mdbP->drVSeqNum	!= vcb->vcbVSeqNum)			||
-	    (mdbP->drWrCnt	!= vcb->vcbWriteCount)		||
-	    (mdbP->drXTClpSiz	!= vcb->vcbExtentsFile->fcbClumpSize)	||
-	    (mdbP->drCTClpSiz	!= vcb->vcbCatalogFile->fcbClumpSize)	||
-	    (mdbP->drNmRtDirs	!= vcb->vcbNmRtDirs)			||
-	    (mdbP->drFilCnt	!= vcb->vcbFileCount)			||
-	    (mdbP->drDirCnt	!= vcb->vcbFolderCount)		||
+	if ((SWAP_BE32(mdbP->drVolBkUp)	!= vcb->vcbBackupDate)		||
+	    (SWAP_BE16(mdbP->drVSeqNum)	!= vcb->vcbVSeqNum)			||
+	    (SWAP_BE32(mdbP->drWrCnt)	!= vcb->vcbWriteCount)		||
+	    (SWAP_BE32(mdbP->drXTClpSiz)	!= vcb->vcbExtentsFile->fcbClumpSize)	||
+	    (SWAP_BE32(mdbP->drCTClpSiz)	!= vcb->vcbCatalogFile->fcbClumpSize)	||
+	    (SWAP_BE16(mdbP->drNmRtDirs)	!= vcb->vcbNmRtDirs)			||
+	    (SWAP_BE32(mdbP->drFilCnt)	!= vcb->vcbFileCount)			||
+	    (SWAP_BE32(mdbP->drDirCnt)	!= vcb->vcbFolderCount)		||
 	    (CmpBlock(mdbP->drFndrInfo, vcb->vcbFinderInfo, 32 ))	//||
 	//  (mdbP->drEmbedSigWord		!= vcb->vcbEmbedSigWord)		||
 	//  (mdbP->drEmbedExtent.startBlock	!= vcb->vcbEmbedExtent.startBlock)	||
@@ -980,7 +981,7 @@ ContinueChecking:
 	 * compare extent file allocation info with MDB
 	 */
 	fcbP = vcb->vcbExtentsFile;	/* compare PEOF for extent file */
-	if ( mdbP->drXTFlSize != fcbP->fcbPhysicalSize )
+	if ( SWAP_BE32(mdbP->drXTFlSize) != fcbP->fcbPhysicalSize )
 	{
 		GPtr->VIStat = GPtr->VIStat | S_MDB;
 		WriteError ( GPtr, E_MDBDamaged, 3, 0 );
@@ -988,8 +989,8 @@ ContinueChecking:
 	}
 	for ( i = 0; i < GPtr->numExtents; i++ )
 	{
-		if ( (mdbP->drXTExtRec[i].startBlock != fcbP->fcbExtents16[i].startBlock) ||
-		     (mdbP->drXTExtRec[i].blockCount != fcbP->fcbExtents16[i].blockCount) )
+		if ( (SWAP_BE16(mdbP->drXTExtRec[i].startBlock) != SWAP_BE16(fcbP->fcbExtents16[i].startBlock)) ||
+		     (SWAP_BE16(mdbP->drXTExtRec[i].blockCount) != SWAP_BE16(fcbP->fcbExtents16[i].blockCount)) )
 		{
 			GPtr->VIStat = GPtr->VIStat | S_MDB;
 			WriteError ( GPtr, E_MDBDamaged, 4, 0 );
@@ -1001,7 +1002,7 @@ ContinueChecking:
 	 * compare catalog file allocation info with MDB
 	 */		
 	fcbP = vcb->vcbCatalogFile;	/* compare PEOF for catalog file */
-	if ( mdbP->drCTFlSize != fcbP->fcbPhysicalSize )
+	if ( SWAP_BE32(mdbP->drCTFlSize) != fcbP->fcbPhysicalSize )
 	{
 		GPtr->VIStat = GPtr->VIStat | S_MDB;
 		WriteError ( GPtr, E_MDBDamaged, 5, 0 );
@@ -1009,8 +1010,8 @@ ContinueChecking:
 	}
 	for ( i = 0; i < GPtr->numExtents; i++ )
 	{
-		if ( (mdbP->drCTExtRec[i].startBlock != fcbP->fcbExtents16[i].startBlock) ||
-		     (mdbP->drCTExtRec[i].blockCount != fcbP->fcbExtents16[i].blockCount) )
+		if ( (SWAP_BE16(mdbP->drCTExtRec[i].startBlock) != SWAP_BE16(fcbP->fcbExtents16[i].startBlock)) ||
+		     (SWAP_BE16(mdbP->drCTExtRec[i].blockCount) != SWAP_BE16(fcbP->fcbExtents16[i].blockCount)) )
 		{
 			GPtr->VIStat = GPtr->VIStat | S_MDB;
 			WriteError ( GPtr, E_MDBDamaged, 6, 0 );
@@ -1053,20 +1054,20 @@ OSErr CompareVolumeHeader( SGlobPtr GPtr
 
 	errID = 0;
 	goodValue = badValue = 0;
-	if (volumeHeader->fileCount != vcb->vcbFileCount) {
+	if (SWAP_BE32(volumeHeader->fileCount) != vcb->vcbFileCount) {
 		errID = E_FilCnt;
 		goodValue = vcb->vcbFileCount;
-		badValue = volumeHeader->fileCount;
+		badValue = SWAP_BE32(volumeHeader->fileCount);
 	}
-	if (volumeHeader->folderCount != vcb->vcbFolderCount) {
+	if (SWAP_BE32(volumeHeader->folderCount) != vcb->vcbFolderCount) {
 		errID = E_DirCnt;
 		goodValue = vcb->vcbFolderCount;
-		badValue = volumeHeader->folderCount;
+		badValue = SWAP_BE32(volumeHeader->folderCount);
 	}
-	if (volumeHeader->freeBlocks != vcb->vcbFreeBlocks) {
+	if (SWAP_BE32(volumeHeader->freeBlocks) != vcb->vcbFreeBlocks) {
 		errID = E_FreeBlocks;
 		goodValue = vcb->vcbFreeBlocks;
-		badValue = volumeHeader->freeBlocks;
+		badValue = SWAP_BE32(volumeHeader->freeBlocks);
 	}
 
 	if (errID) {
@@ -1080,25 +1081,25 @@ OSErr CompareVolumeHeader( SGlobPtr GPtr
 	}
 
 	if ( kHFSPlusSigWord				!= vcb->vcbSignature )	goto VolumeHeaderDamaged;
-	if ( volumeHeader->encodingsBitmap		!= vcb->vcbEncodingsBitmap )	goto VolumeHeaderDamaged;
+	if ( SWAP_BE64(volumeHeader->encodingsBitmap)		!= vcb->vcbEncodingsBitmap )	goto VolumeHeaderDamaged;
 	if ( (UInt16) (hfsPlusIOPosOffset/512)		!= vcb->vcbAlBlSt )		goto VolumeHeaderDamaged;
-	if ( volumeHeader->createDate			!= vcb->vcbCreateDate )	goto VolumeHeaderDamaged;
-	if ( volumeHeader->modifyDate			!= vcb->vcbModifyDate )	goto VolumeHeaderDamaged;
-	if ( volumeHeader->backupDate			!= vcb->vcbBackupDate )	goto VolumeHeaderDamaged;
-	if ( volumeHeader->checkedDate			!= vcb->vcbCheckedDate )	goto VolumeHeaderDamaged;
-	if ( volumeHeader->rsrcClumpSize		!= vcb->vcbRsrcClumpSize )	goto VolumeHeaderDamaged;
-	if ( volumeHeader->dataClumpSize		!= vcb->vcbDataClumpSize )	goto VolumeHeaderDamaged;
-	if ( volumeHeader->nextCatalogID		!= vcb->vcbNextCatalogID &&
-	     (volumeHeader->attributes & kHFSCatalogNodeIDsReused) == 0)  goto VolumeHeaderDamaged;
-	if ( volumeHeader->writeCount			!= vcb->vcbWriteCount )	goto VolumeHeaderDamaged;
-	if ( volumeHeader->nextAllocation		!= vcb->vcbNextAllocation )	goto VolumeHeaderDamaged;
-	if ( volumeHeader->totalBlocks			!= vcb->vcbTotalBlocks )	goto VolumeHeaderDamaged;
-	if ( volumeHeader->blockSize			!= vcb->vcbBlockSize )	goto VolumeHeaderDamaged;
-	if ( volumeHeader->attributes			!= vcb->vcbAttributes )	goto VolumeHeaderDamaged;
-
-	if ( volumeHeader->extentsFile.clumpSize	!= vcb->vcbExtentsFile->fcbClumpSize )	goto VolumeHeaderDamaged;
-	if ( volumeHeader->catalogFile.clumpSize	!= vcb->vcbCatalogFile->fcbClumpSize )	goto VolumeHeaderDamaged;
-	if ( volumeHeader->allocationFile.clumpSize	!= vcb->vcbAllocationFile->fcbClumpSize )	goto VolumeHeaderDamaged;
+	if ( SWAP_BE32(volumeHeader->createDate)			!= vcb->vcbCreateDate )	goto VolumeHeaderDamaged;
+	if ( SWAP_BE32(volumeHeader->modifyDate)			!= vcb->vcbModifyDate )	goto VolumeHeaderDamaged;
+	if ( SWAP_BE32(volumeHeader->backupDate)			!= vcb->vcbBackupDate )	goto VolumeHeaderDamaged;
+	if ( SWAP_BE32(volumeHeader->checkedDate)			!= vcb->vcbCheckedDate )	goto VolumeHeaderDamaged;
+	if ( SWAP_BE32(volumeHeader->rsrcClumpSize)		!= vcb->vcbRsrcClumpSize )	goto VolumeHeaderDamaged;
+	if ( SWAP_BE32(volumeHeader->dataClumpSize)		!= vcb->vcbDataClumpSize )	goto VolumeHeaderDamaged;
+	if ( SWAP_BE32(volumeHeader->nextCatalogID)		!= vcb->vcbNextCatalogID &&
+	     (SWAP_BE32(volumeHeader->attributes) & kHFSCatalogNodeIDsReused) == 0)  goto VolumeHeaderDamaged;
+	if ( SWAP_BE32(volumeHeader->writeCount)			!= vcb->vcbWriteCount )	goto VolumeHeaderDamaged;
+	if ( SWAP_BE32(volumeHeader->nextAllocation)		!= vcb->vcbNextAllocation )	goto VolumeHeaderDamaged;
+	if ( SWAP_BE32(volumeHeader->totalBlocks)			!= vcb->vcbTotalBlocks )	goto VolumeHeaderDamaged;
+	if ( SWAP_BE32(volumeHeader->blockSize)			!= vcb->vcbBlockSize )	goto VolumeHeaderDamaged;
+	if ( SWAP_BE32(volumeHeader->attributes)			!= vcb->vcbAttributes )	goto VolumeHeaderDamaged;
+
+	if ( SWAP_BE32(volumeHeader->extentsFile.clumpSize)	!= vcb->vcbExtentsFile->fcbClumpSize )	goto VolumeHeaderDamaged;
+	if ( SWAP_BE32(volumeHeader->catalogFile.clumpSize)	!= vcb->vcbCatalogFile->fcbClumpSize )	goto VolumeHeaderDamaged;
+	if ( SWAP_BE32(volumeHeader->allocationFile.clumpSize)	!= vcb->vcbAllocationFile->fcbClumpSize )	goto VolumeHeaderDamaged;
 
 	if ( CmpBlock( volumeHeader->finderInfo, vcb->vcbFinderInfo, sizeof(vcb->vcbFinderInfo) ) )	goto VolumeHeaderDamaged;
 	goto ContinueChecking;
@@ -1116,7 +1117,7 @@ ContinueChecking:
 	 * compare extent file allocation info with VolumeHeader
 	 */		
 	fcbP = vcb->vcbExtentsFile;
-	if ( (UInt64)volumeHeader->extentsFile.totalBlocks * (UInt64)vcb->vcbBlockSize != fcbP->fcbPhysicalSize )
+	if ( (UInt64)SWAP_BE32(volumeHeader->extentsFile.totalBlocks) * (UInt64)vcb->vcbBlockSize != fcbP->fcbPhysicalSize )
 	{
 		GPtr->VIStat = GPtr->VIStat | S_MDB;
 		WriteError ( GPtr, E_VolumeHeaderDamaged, 3, 0 );
@@ -1124,8 +1125,8 @@ ContinueChecking:
 	}
 	for ( i=0; i < GPtr->numExtents; i++ )
 	{
-		if ( (volumeHeader->extentsFile.extents[i].startBlock != fcbP->fcbExtents32[i].startBlock) ||
-		     (volumeHeader->extentsFile.extents[i].blockCount != fcbP->fcbExtents32[i].blockCount) )
+		if ( (SWAP_BE32(volumeHeader->extentsFile.extents[i].startBlock) != SWAP_BE32(fcbP->fcbExtents32[i].startBlock)) ||
+		     (SWAP_BE32(volumeHeader->extentsFile.extents[i].blockCount) != SWAP_BE32(fcbP->fcbExtents32[i].blockCount)) )
 		{
 			GPtr->VIStat = GPtr->VIStat | S_MDB;
 			WriteError ( GPtr, E_VolumeHeaderDamaged, 4, 0 );
@@ -1137,7 +1138,7 @@ ContinueChecking:
 	 * compare catalog file allocation info with MDB
 	 */	
 	fcbP = vcb->vcbCatalogFile;	/* compare PEOF for catalog file */
-	if ( (UInt64)volumeHeader->catalogFile.totalBlocks * (UInt64)vcb->vcbBlockSize != fcbP->fcbPhysicalSize )
+	if ( (UInt64)SWAP_BE32(volumeHeader->catalogFile.totalBlocks) * (UInt64)vcb->vcbBlockSize != fcbP->fcbPhysicalSize )
 	{
 		GPtr->VIStat = GPtr->VIStat | S_MDB;
 		WriteError ( GPtr, E_VolumeHeaderDamaged, 5, 0 );
@@ -1145,8 +1146,8 @@ ContinueChecking:
 	}
 	for ( i=0; i < GPtr->numExtents; i++ )
 	{
-		if ( (volumeHeader->catalogFile.extents[i].startBlock != fcbP->fcbExtents32[i].startBlock) ||
-		     (volumeHeader->catalogFile.extents[i].blockCount != fcbP->fcbExtents32[i].blockCount) )
+		if ( (SWAP_BE32(volumeHeader->catalogFile.extents[i].startBlock) != SWAP_BE32(fcbP->fcbExtents32[i].startBlock)) ||
+		     (SWAP_BE32(volumeHeader->catalogFile.extents[i].blockCount) != SWAP_BE32(fcbP->fcbExtents32[i].blockCount)) )
 		{
 			GPtr->VIStat = GPtr->VIStat | S_MDB;
 			WriteError ( GPtr, E_VolumeHeaderDamaged, 6, 0 );
@@ -1159,7 +1160,7 @@ ContinueChecking:
 	 * compare bitmap file allocation info with MDB
 	 */		
 	fcbP = vcb->vcbAllocationFile;
-	if ( (UInt64)volumeHeader->allocationFile.totalBlocks * (UInt64)vcb->vcbBlockSize != fcbP->fcbPhysicalSize )
+	if ( (UInt64)SWAP_BE32(volumeHeader->allocationFile.totalBlocks) * (UInt64)vcb->vcbBlockSize != fcbP->fcbPhysicalSize )
 	{
 		GPtr->VIStat = GPtr->VIStat | S_MDB;
 		WriteError ( GPtr, E_VolumeHeaderDamaged, 7, 0 );
@@ -1167,8 +1168,8 @@ ContinueChecking:
 	}
 	for ( i=0; i < GPtr->numExtents; i++ )
 	{
-		if ( (volumeHeader->allocationFile.extents[i].startBlock != fcbP->fcbExtents32[i].startBlock) ||
-		     (volumeHeader->allocationFile.extents[i].blockCount != fcbP->fcbExtents32[i].blockCount) )
+		if ( (SWAP_BE32(volumeHeader->allocationFile.extents[i].startBlock) != SWAP_BE32(fcbP->fcbExtents32[i].startBlock)) ||
+		     (SWAP_BE32(volumeHeader->allocationFile.extents[i].blockCount) != SWAP_BE32(fcbP->fcbExtents32[i].blockCount)) )
 		{
 			GPtr->VIStat = GPtr->VIStat | S_MDB;				/* didn't match, mark MDB damaged */
 			WriteError ( GPtr, E_VolumeHeaderDamaged, 8, 0 );
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/Scavenger.h diskdev_cmds/fsck_hfs.tproj/dfalib/Scavenger.h
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/Scavenger.h	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/Scavenger.h	2003-05-05 12:37:43.000000000 +0200
@@ -33,6 +33,7 @@
 #include "BTreePrivate.h"
 #include "CheckHFS.h"
 #include "BTreeScanner.h"
+#include "hfs_endian.h"
 
 #ifdef __cplusplus
 extern	"C" {
@@ -422,7 +423,7 @@ typedef union CatalogKey				CatalogKey;
 /* Universal catalog data record */
 
 union CatalogRecord {
-	SInt16 							recordType;
+	u_big_int16_t 					recordType;
 	HFSCatalogFolder 				hfsFolder;
 	HFSCatalogFile 					hfsFile;
 	HFSCatalogThread 				hfsThread;
@@ -1275,8 +1276,8 @@ Ptr	GetFCBSPtr( void );
 /* 
  * UTF-8 conversion routines
  */
-extern int utf_decodestr(const u_int8_t *, size_t, u_int16_t *, size_t *);
-extern int utf_encodestr(const u_int16_t *, size_t, u_int8_t *, size_t *);
+extern int utf_decodestr(const u_int8_t *, size_t, u_big_int16_t *, size_t *);
+extern int utf_encodestr(const u_big_int16_t *, size_t, u_int8_t *, size_t *);
 
 /* 
  * HardLink checking routines
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/VolumeBitmapCheck.c diskdev_cmds/fsck_hfs.tproj/dfalib/VolumeBitmapCheck.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/VolumeBitmapCheck.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/VolumeBitmapCheck.c	2003-09-01 16:18:37.000000000 +0200
@@ -64,8 +64,8 @@ bitstr_t* gFullSegmentList;
 UInt32    gBitsMarked;
 UInt32    gTotalBits;
 UInt32    gTotalSegments;
-UInt32*   gFullBitmapSegment;   /* points to a FULL bitmap segment*/
-UInt32*   gEmptyBitmapSegment;  /* points to an EMPTY bitmap segment*/
+u_big_int32_t* gFullBitmapSegment;   /* points to a FULL bitmap segment*/
+u_big_int32_t* gEmptyBitmapSegment;  /* points to an EMPTY bitmap segment*/
 
 /*
  * Bitmap Segment (BMS) Tree node
@@ -76,7 +76,7 @@ typedef struct BMS_Node {
 	struct BMS_Node *left;
 	struct BMS_Node *right;
 	UInt32 segment;
-	UInt32 bitmap[kWordsPerSegment];
+	u_big_int32_t bitmap[kWordsPerSegment];
 } BMS_Node;
 
 BMS_Node *gBMS_Root;           /* root of BMS tree */
@@ -108,10 +108,10 @@ BitMapCheckBegin(SGlobPtr g)
 	if (gBitMapInited)
 		return (0);
 
-	gFullBitmapSegment = (UInt32 *)malloc(kBytesPerSegment);
+	gFullBitmapSegment = (u_big_int32_t *)malloc(kBytesPerSegment);
 	memset((void *)gFullBitmapSegment, 0xff, kBytesPerSegment);
 
-	gEmptyBitmapSegment = (UInt32 *)malloc(kBytesPerSegment);
+	gEmptyBitmapSegment = (u_big_int32_t *)malloc(kBytesPerSegment);
 	memset((void *)gEmptyBitmapSegment, 0x00, kBytesPerSegment);
 
 	gTotalBits = g->calculatedVCB->vcbTotalBlocks;
@@ -186,7 +186,7 @@ BitMapCheckEnd(void)
 
 
 static int
-GetSegmentBitmap(UInt32 startBit, UInt32 **buffer, int bitOperation)
+GetSegmentBitmap(UInt32 startBit, u_big_int32_t **buffer, int bitOperation)
 {
 	UInt32 segment;
 	BMS_Node *segNode = NULL;
@@ -304,8 +304,8 @@ CaptureBitmapBits(UInt32 startBit, UInt3
 	UInt32  bitMask;
 	UInt32  firstBit;
 	UInt32  numBits;
-	UInt32  *buffer;
-	UInt32  *currentWord;
+	u_big_int32_t *buffer;
+	u_big_int32_t *currentWord;
 
 	overlap = false;
 	if (bitCount == 0)
@@ -348,13 +348,13 @@ CaptureBitmapBits(UInt32 startBit, UInt3
 			bitMask &= ~(kAllBitsSetInWord >> (firstBit + numBits)); // turn off bits after last
 		}
 
-		if (*currentWord & bitMask) {
+		if (SWAP_BE32(*currentWord) & bitMask) {
 			overlap = true;
 
 		//	printf("(1) overlapping file blocks! word: 0x%08x, mask: 0x%08x\n", *currentWord, bitMask);
 		}
 		
-		*currentWord |= bitMask;  /* set the bits in the bitmap */
+		SET_SWAP_BE32(*currentWord, SWAP_BE32(*currentWord) | bitMask);  /* set the bits in the bitmap */
 		
 		bitCount -= numBits;
 		++currentWord;
@@ -380,13 +380,13 @@ CaptureBitmapBits(UInt32 startBit, UInt3
 			wordsLeft = kWordsPerSegment;
 		}
 		
-		if (*currentWord & bitMask) {
+		if (SWAP_BE32(*currentWord) & bitMask) {
 			overlap = true;
 
 		//	printf("(2) overlapping file blocks! word: 0x%08x, mask: 0x%08x\n", *currentWord, bitMask);
 		}
 		
-		*currentWord |= bitMask;  /* set the bits in the bitmap */
+		SET_SWAP_BE32(*currentWord, SWAP_BE32(*currentWord) | bitMask);  /* set the bits in the bitmap */
 
 		bitCount -= kBitsPerWord;
 		++currentWord;
@@ -410,13 +410,13 @@ CaptureBitmapBits(UInt32 startBit, UInt3
 			wordsLeft = kWordsPerSegment;
 		}
 		
-		if (*currentWord & bitMask) {
+		if (SWAP_BE32(*currentWord) & bitMask) {
 			overlap = true;
 
 		//	printf("(3) overlapping file blocks! word: 0x%08x, mask: 0x%08x\n", *currentWord, bitMask);
 		}
 		
-		*currentWord |= bitMask;  /* set the bits in the bitmap */
+		SET_SWAP_BE32(*currentWord, SWAP_BE32(*currentWord) | bitMask);  /* set the bits in the bitmap */
 
 		TestSegmentBitmap(startBit);
 	}
@@ -437,8 +437,8 @@ ReleaseBitmapBits(UInt32 startBit, UInt3
 	UInt32  bitMask;
 	UInt32  firstBit;
 	UInt32  numBits;
-	UInt32  *buffer;
-	UInt32  *currentWord;
+	u_big_int32_t *buffer;
+	u_big_int32_t *currentWord;
 
 	overlap = false;
 	if (bitCount == 0)
@@ -481,13 +481,13 @@ ReleaseBitmapBits(UInt32 startBit, UInt3
 			bitMask &= ~(kAllBitsSetInWord >> (firstBit + numBits)); // turn off bits after last
 		}
 
-		if ((*currentWord & bitMask) != bitMask) {
+		if ((SWAP_BE32(*currentWord) & bitMask) != bitMask) {
 			overlap = true;
 
 		//	printf("(1) overlapping file blocks! word: 0x%08x, mask: 0x%08x\n", *currentWord, bitMask);
 		}
 		
-		*currentWord &= ~bitMask;  /* clear the bits in the bitmap */
+		SET_SWAP_BE32(*currentWord, SWAP_BE32(*currentWord) & ~bitMask);  /* clear the bits in the bitmap */
 		
 		bitCount -= numBits;
 		++currentWord;
@@ -513,13 +513,13 @@ ReleaseBitmapBits(UInt32 startBit, UInt3
 			wordsLeft = kWordsPerSegment;
 		}
 		
-		if ((*currentWord & bitMask) != bitMask) {
+		if ((SWAP_BE32(*currentWord) & bitMask) != bitMask) {
 			overlap = true;
 
 		//	printf("(2) overlapping file blocks! word: 0x%08x, mask: 0x%08x\n", *currentWord, bitMask);
 		}
 		
-		*currentWord &= ~bitMask;  /* clear the bits in the bitmap */
+		SET_SWAP_BE32(*currentWord, SWAP_BE32(*currentWord) & ~bitMask);  /* clear the bits in the bitmap */
 
 		bitCount -= kBitsPerWord;
 		++currentWord;
@@ -543,13 +543,13 @@ ReleaseBitmapBits(UInt32 startBit, UInt3
 			wordsLeft = kWordsPerSegment;
 		}
 		
-		if ((*currentWord & bitMask) != bitMask) {
+		if ((SWAP_BE32(*currentWord) & bitMask) != bitMask) {
 			overlap = true;
 
 		//	printf("(3) overlapping file blocks! word: 0x%08x, mask: 0x%08x\n", *currentWord, bitMask);
 		}
 		
-		*currentWord &= ~bitMask;  /* set the bits in the bitmap */
+		SET_SWAP_BE32(*currentWord, SWAP_BE32(*currentWord) & ~bitMask);  /* set the bits in the bitmap */
 
 		TestSegmentBitmap(startBit);
 	}
@@ -567,7 +567,7 @@ int
 CheckVolumeBitMap(SGlobPtr g, Boolean repair)
 {
 	UInt8 *vbmBlockP;
-	UInt32 *buffer;
+	u_big_int32_t *buffer;
 	UInt32 bit;
 	UInt32 bitsWithinFileBlkMask;
 	UInt32 fileBlk;
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/hfs_endian.c diskdev_cmds/fsck_hfs.tproj/dfalib/hfs_endian.c
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/hfs_endian.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/hfs_endian.c	2003-04-28 12:50:13.000000000 +0200
@@ -37,130 +37,3 @@
 
 #undef ENDIAN_DEBUG
 
-static void hfs_swap_HFSPlusForkData (HFSPlusForkData *src);
-
-/*
- * hfs_swap_HFSMasterDirectoryBlock
- *
- *  Specially modified to swap parts of the finder info
- */
-void
-hfs_swap_HFSMasterDirectoryBlock (
-    void *buf
-)
-{
-    HFSMasterDirectoryBlock *src = (HFSMasterDirectoryBlock *)buf;
-
-    src->drSigWord		= SWAP_BE16 (src->drSigWord);
-    src->drCrDate		= SWAP_BE32 (src->drCrDate);
-    src->drLsMod		= SWAP_BE32 (src->drLsMod);
-    src->drAtrb			= SWAP_BE16 (src->drAtrb);
-    src->drNmFls		= SWAP_BE16 (src->drNmFls);
-    src->drVBMSt		= SWAP_BE16 (src->drVBMSt);
-    src->drAllocPtr		= SWAP_BE16 (src->drAllocPtr);
-    src->drNmAlBlks		= SWAP_BE16 (src->drNmAlBlks);
-    src->drAlBlkSiz		= SWAP_BE32 (src->drAlBlkSiz);
-    src->drClpSiz		= SWAP_BE32 (src->drClpSiz);
-    src->drAlBlSt		= SWAP_BE16 (src->drAlBlSt);
-    src->drNxtCNID		= SWAP_BE32 (src->drNxtCNID);
-    src->drFreeBks		= SWAP_BE16 (src->drFreeBks);
-
-    /* Don't swap drVN */
-
-    src->drVolBkUp		= SWAP_BE32 (src->drVolBkUp);
-    src->drVSeqNum		= SWAP_BE16 (src->drVSeqNum);
-    src->drWrCnt		= SWAP_BE32 (src->drWrCnt);
-    src->drXTClpSiz		= SWAP_BE32 (src->drXTClpSiz);
-    src->drCTClpSiz		= SWAP_BE32 (src->drCTClpSiz);
-    src->drNmRtDirs		= SWAP_BE16 (src->drNmRtDirs);
-    src->drFilCnt		= SWAP_BE32 (src->drFilCnt);
-    src->drDirCnt		= SWAP_BE32 (src->drDirCnt);
-
-    /* Swap just the 'blessed folder' in drFndrInfo */
-    src->drFndrInfo[0]	= SWAP_BE32 (src->drFndrInfo[0]);
-
-    src->drEmbedSigWord	= SWAP_BE16 (src->drEmbedSigWord);
-	src->drEmbedExtent.startBlock = SWAP_BE16 (src->drEmbedExtent.startBlock);
-	src->drEmbedExtent.blockCount = SWAP_BE16 (src->drEmbedExtent.blockCount);
-
-    src->drXTFlSize		= SWAP_BE32 (src->drXTFlSize);
-	src->drXTExtRec[0].startBlock = SWAP_BE16 (src->drXTExtRec[0].startBlock);
-	src->drXTExtRec[0].blockCount = SWAP_BE16 (src->drXTExtRec[0].blockCount);
-	src->drXTExtRec[1].startBlock = SWAP_BE16 (src->drXTExtRec[1].startBlock);
-	src->drXTExtRec[1].blockCount = SWAP_BE16 (src->drXTExtRec[1].blockCount);
-	src->drXTExtRec[2].startBlock = SWAP_BE16 (src->drXTExtRec[2].startBlock);
-	src->drXTExtRec[2].blockCount = SWAP_BE16 (src->drXTExtRec[2].blockCount);
-
-    src->drCTFlSize		= SWAP_BE32 (src->drCTFlSize);
-	src->drCTExtRec[0].startBlock = SWAP_BE16 (src->drCTExtRec[0].startBlock);
-	src->drCTExtRec[0].blockCount = SWAP_BE16 (src->drCTExtRec[0].blockCount);
-	src->drCTExtRec[1].startBlock = SWAP_BE16 (src->drCTExtRec[1].startBlock);
-	src->drCTExtRec[1].blockCount = SWAP_BE16 (src->drCTExtRec[1].blockCount);
-	src->drCTExtRec[2].startBlock = SWAP_BE16 (src->drCTExtRec[2].startBlock);
-	src->drCTExtRec[2].blockCount = SWAP_BE16 (src->drCTExtRec[2].blockCount);
-}
-
-/*
- * hfs_swap_HFSPlusVolumeHeader
- */
-void
-hfs_swap_HFSPlusVolumeHeader (
-    void *buf
-)
-{
-    HFSPlusVolumeHeader *src = (HFSPlusVolumeHeader *)buf;
-
-    src->signature			= SWAP_BE16 (src->signature);
-    src->version			= SWAP_BE16 (src->version);
-    src->attributes			= SWAP_BE32 (src->attributes);
-    src->lastMountedVersion	= SWAP_BE32 (src->lastMountedVersion);
-
-    /* Don't swap reserved */
-
-    src->createDate			= SWAP_BE32 (src->createDate);
-    src->modifyDate			= SWAP_BE32 (src->modifyDate);
-    src->backupDate			= SWAP_BE32 (src->backupDate);
-    src->checkedDate		= SWAP_BE32 (src->checkedDate);
-    src->fileCount			= SWAP_BE32 (src->fileCount);
-    src->folderCount		= SWAP_BE32 (src->folderCount);
-    src->blockSize			= SWAP_BE32 (src->blockSize);
-    src->totalBlocks		= SWAP_BE32 (src->totalBlocks);
-    src->freeBlocks			= SWAP_BE32 (src->freeBlocks);
-    src->nextAllocation		= SWAP_BE32 (src->nextAllocation);
-    src->rsrcClumpSize		= SWAP_BE32 (src->rsrcClumpSize);
-    src->dataClumpSize		= SWAP_BE32 (src->dataClumpSize);
-    src->nextCatalogID		= SWAP_BE32 (src->nextCatalogID);
-    src->writeCount			= SWAP_BE32 (src->writeCount);
-    src->encodingsBitmap	= SWAP_BE64 (src->encodingsBitmap);
-
-    /* Don't swap finderInfo */
-
-    hfs_swap_HFSPlusForkData (&src->allocationFile);
-    hfs_swap_HFSPlusForkData (&src->extentsFile);
-    hfs_swap_HFSPlusForkData (&src->catalogFile);
-    hfs_swap_HFSPlusForkData (&src->attributesFile);
-    hfs_swap_HFSPlusForkData (&src->startupFile);
-}
-
-/*
- * hfs_swap_HFSPlusForkData
- *
- *  There's still a few spots where we still need to swap the fork data.
- */
-void
-hfs_swap_HFSPlusForkData (
-    HFSPlusForkData *src
-)
-{
-    unsigned int i;
-
-	src->logicalSize		= SWAP_BE64 (src->logicalSize);
-
-	src->clumpSize			= SWAP_BE32 (src->clumpSize);
-	src->totalBlocks		= SWAP_BE32 (src->totalBlocks);
-
-    for (i = 0; i < kHFSPlusExtentDensity; i++) {
-        src->extents[i].startBlock	= SWAP_BE32 (src->extents[i].startBlock);
-        src->extents[i].blockCount	= SWAP_BE32 (src->extents[i].blockCount);
-    }
-}
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/dfalib/hfs_endian.h diskdev_cmds/fsck_hfs.tproj/dfalib/hfs_endian.h
--- diskdev_cmds.org/fsck_hfs.tproj/dfalib/hfs_endian.h	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/dfalib/hfs_endian.h	2003-07-04 15:26:59.000000000 +0200
@@ -31,45 +31,42 @@
 #include <hfs/hfs_format.h>
 #include <architecture/byte_order.h>
 
-/*********************/
-/* BIG ENDIAN Macros */
-/*********************/
-#if BYTE_ORDER == BIG_ENDIAN
-
-    /* HFS is always big endian, make swaps into no-ops */
-    #define SWAP_BE16(__a) (__a)
-    #define SWAP_BE32(__a) (__a)
-    #define SWAP_BE64(__a) (__a)
-    
-    /* HFS is always big endian, no swapping needed */
-    #define SWAP_HFSMDB(__a)
-    #define SWAP_HFSPLUSVH(__a)
-
-/************************/
-/* LITTLE ENDIAN Macros */
-/************************/
-#elif BYTE_ORDER == LITTLE_ENDIAN
+#if 0
+typedef struct {
+	u_int16_t u16;
+} __packed u_big_int16_t;
+
+typedef struct {
+	u_int32_t u32;
+} __packed u_big_int32_t;
+
+typedef struct {
+	u_int64_t u64;
+} __packed u_big_int64_t;
+
+    #define SWAP_BE16(__a) 							NXSwapBigShortToHost ((__a).u16)
+	#define SET_SWAP_BE16(__d, __a)					(__d).u16 = NXSwapBigShortToHost(__a)
+    #define SWAP_BE32(__a) 							NXSwapBigLongToHost ((__a).u32)
+	#define SET_SWAP_BE32(__d, __a)					(__d).u32 = NXSwapBigLongToHost(__a)
+    #define SWAP_BE64(__a) 							NXSwapBigLongLongToHost ((__a).u64)
+    #define SET_SWAP_BE64(__d, __a) 				(__d).u64 = NXSwapBigLongLongToHost (__a)
+#else
+typedef u_int16_t u_big_int16_t;
+typedef u_int32_t u_big_int32_t;
+typedef u_int64_t u_big_int64_t;
 
-    /* HFS is always big endian, make swaps actually swap */
     #define SWAP_BE16(__a) 							NXSwapBigShortToHost (__a)
+	#define SET_SWAP_BE16(__d, __a)					(__d) = NXSwapBigShortToHost(__a)
     #define SWAP_BE32(__a) 							NXSwapBigLongToHost (__a)
+	#define SET_SWAP_BE32(__d, __a)					(__d) = NXSwapBigLongToHost(__a)
     #define SWAP_BE64(__a) 							NXSwapBigLongLongToHost (__a)
-    
-    #define SWAP_HFSMDB(__a)						hfs_swap_HFSMasterDirectoryBlock ((__a))
-    #define SWAP_HFSPLUSVH(__a)						hfs_swap_HFSPlusVolumeHeader ((__a))
-
-#else
-#warning Unknown byte order
-#error
+    #define SET_SWAP_BE64(__d, __a) 				(__d) = NXSwapBigLongLongToHost (__a)
 #endif
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-void hfs_swap_HFSMasterDirectoryBlock (void *buf);
-void hfs_swap_HFSPlusVolumeHeader (void *buf);
-
 #ifdef __cplusplus
 }
 #endif
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/fsck_hfs.c diskdev_cmds/fsck_hfs.tproj/fsck_hfs.c
--- diskdev_cmds.org/fsck_hfs.tproj/fsck_hfs.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/fsck_hfs.c	2003-07-04 15:23:42.000000000 +0200
@@ -26,13 +26,16 @@
 #include <sys/param.h>
 #include <sys/mount.h>
 #include <sys/ioctl.h>
-#include <dev/disk.h>
+#include <sys/vfs.h>
+//#include <dev/disk.h>
 
-#include <hfs/hfs_mount.h>
+//#include <hfs/hfs_mount.h>
 
 #include <errno.h>
 #include <fcntl.h>
+#include <signal.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 
@@ -68,7 +71,7 @@ static int checkfilesys __P((char * file
 static int setup __P((char *dev));
 static void usage __P((void));
 
-void
+int
 main(argc, argv)
  int	argc;
  char	*argv[];
@@ -77,7 +80,8 @@ main(argc, argv)
 	int ret;
 	extern int optind;
 
-	if (progname = strrchr(*argv, '/'))
+	progname = strrchr(*argv, '/');
+	if (progname)
 		++progname;
 	else
 		progname = *argv;
@@ -221,6 +225,7 @@ checkfilesys(char * filesys)
 				return (EEXIT);
 			}
 		}
+#if __APPLE__
 	} else {
 		struct statfs stfs_buf;
 		/*
@@ -231,6 +236,7 @@ checkfilesys(char * filesys)
 		else
 			flags = 0;
 		ckfini(flags & MNT_RDONLY);
+#endif
 	}
 
 	/* XXX free any allocated memory here */
@@ -238,19 +244,22 @@ checkfilesys(char * filesys)
 	if (!fsmodified)
 		return ((result == 0) ? 0 : EEXIT);
 	if (hotroot) {
-		struct hfs_mount_args args;
 		/*
 		 * We modified the root.  Do a mount update on
 		 * it, unless it is read-write, so we can continue.
 		 */
 		if (!preen)
 			printf("\n***** FILE SYSTEM WAS MODIFIED *****\n");
+#if __APPLE__
 		if (flags & MNT_RDONLY) {		
+			struct hfs_mount_args args;
+
 			bzero(&args, sizeof(args));
 			flags |= MNT_UPDATE | MNT_RELOAD;
 			if (mount("hfs", "/", flags, &args) == 0)
 				return (0);
 		}
+#endif
 		if (!preen)
 			printf("\n***** REBOOT NOW *****\n");
 		sync();
@@ -277,11 +286,19 @@ setup(char *dev)
 		printf("Can't stat %s: %s\n", dev, strerror(errno));
 		return (0);
 	}
+#if __APPLE__   
 	if ((statb.st_mode & S_IFMT) != S_IFCHR) {
 		pfatal("%s is not a character device", dev);
 		if (reply("CONTINUE") == 0)
 			return (0);
 	}
+#else
+	if (!S_ISBLK(statb.st_mode) && !S_ISREG(statb.st_mode)) {
+		pfatal("%s is not a block device", dev);
+		if (reply("CONTINUE") == 0)
+			return (0);
+	}
+#endif
 	if ((fsreadfd = open(dev, O_RDONLY)) < 0) {
 		printf("Can't open %s: %s\n", dev, strerror(errno));
 		return (0);
@@ -299,7 +316,11 @@ setup(char *dev)
 		printf("\n");
 
 	/* Initialize the cache */
+#if __APPLE__
 	ioctl(fsreadfd, DKIOCBLKSIZE, &devBlockSize);
+#else
+	devBlockSize = 512;
+#endif
 	if (CacheInit (&fscache, fsreadfd, fswritefd, devBlockSize,
 			CACHE_IOSIZE, CACHE_BLOCKS, CACHE_HASHSIZE) != EOK) {
 		pfatal("Can't initialize disk cache\n");
diff -Npur diskdev_cmds.org/fsck_hfs.tproj/utilities.c diskdev_cmds/fsck_hfs.tproj/utilities.c
--- diskdev_cmds.org/fsck_hfs.tproj/utilities.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/fsck_hfs.tproj/utilities.c	2003-07-07 15:43:33.000000000 +0200
@@ -60,13 +60,16 @@
 #include <ctype.h>
 #include <err.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <unistd.h> 
 
 #include "fsck_hfs.h"
 
+#if __APPLE__
 static char *rawname __P((char *name));
 static char *unrawname __P((char *name));
+#endif
 
 
 int
@@ -156,6 +159,7 @@ ckfini(markclean)
 char *
 blockcheck(char *origname)
 {
+#if __APPLE__
 	struct stat stslash, stblock, stchar;
 	char *newname, *raw;
 	int retried = 0;
@@ -193,6 +197,7 @@ retry:
 		retried++;
 		goto retry;
 	}
+#endif
 	/*
 	 * Not a block or character device, just return name and
 	 * let the caller decide whether to use it.
@@ -201,6 +206,7 @@ retry:
 }
 
 
+#if __APPLE__
 static char *
 rawname(char *name)
 
@@ -238,6 +244,7 @@ unrawname(char *name)
 
 	return (name);
 }
+#endif
 
 
 void
diff -Npur diskdev_cmds.org/include/architecture/byte_order.h diskdev_cmds/include/architecture/byte_order.h
--- diskdev_cmds.org/include/architecture/byte_order.h	1970-01-01 01:00:00.000000000 +0100
+++ diskdev_cmds/include/architecture/byte_order.h	2003-05-05 13:07:12.000000000 +0200
@@ -0,0 +1,25 @@
+#ifndef	_ARCHITECTURE_BYTE_ORDER_H_
+#define _ARCHITECTURE_BYTE_ORDER_H_
+
+#include <endian.h>
+#include <byteswap.h>
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+
+#define __LITTLE_ENDIAN__
+
+#define NXSwapBigShortToHost(x)	bswap_16(x)
+#define NXSwapBigLongToHost(x) bswap_32(x)
+#define NXSwapBigLongLongToHost(x) bswap_64(x)
+
+#elif __BYTE_ORDER == __BIG_ENDIAN
+
+#define __BIG_ENDIAN__
+
+#define NXSwapBigShortToHost(x)	(x)
+#define NXSwapBigLongToHost(x) (x)
+#define NXSwapBigLongLongToHost(x) (x)
+
+#endif
+
+#endif
diff -Npur diskdev_cmds.org/include/bitstring.h diskdev_cmds/include/bitstring.h
--- diskdev_cmds.org/include/bitstring.h	1970-01-01 01:00:00.000000000 +0100
+++ diskdev_cmds/include/bitstring.h	2003-04-24 13:55:55.000000000 +0200
@@ -0,0 +1,164 @@
+/*
+ * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * The contents of this file constitute Original Code as defined in and
+ * are subject to the Apple Public Source License Version 1.1 (the
+ * "License").  You may not use this file except in compliance with the
+ * License.  Please obtain a copy of the License at
+ * http://www.apple.com/publicsource and read it before using this file.
+ * 
+ * This Original Code and all software distributed under the License are
+ * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
+ * License for the specific language governing rights and limitations
+ * under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Paul Vixie.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)bitstring.h	8.1 (Berkeley) 7/19/93
+ */
+
+#ifndef _BITSTRING_H_
+#define	_BITSTRING_H_
+
+typedef	unsigned char bitstr_t;
+
+/* internal macros */
+				/* byte of the bitstring bit is in */
+#define	_bit_byte(bit) \
+	((bit) >> 3)
+
+				/* mask for the bit within its byte */
+#define	_bit_mask(bit) \
+	(1 << ((bit)&0x7))
+
+/* external macros */
+				/* bytes in a bitstring of nbits bits */
+#define	bitstr_size(nbits) \
+	((((nbits) - 1) >> 3) + 1)
+
+				/* allocate a bitstring */
+#define	bit_alloc(nbits) \
+	(bitstr_t *)calloc(1, \
+	    (unsigned int)bitstr_size(nbits) * sizeof(bitstr_t))
+
+				/* allocate a bitstring on the stack */
+#define	bit_decl(name, nbits) \
+	(name)[bitstr_size(nbits)]
+
+				/* is bit N of bitstring name set? */
+#define	bit_test(name, bit) \
+	((name)[_bit_byte(bit)] & _bit_mask(bit))
+
+				/* set bit N of bitstring name */
+#define	bit_set(name, bit) \
+	(name)[_bit_byte(bit)] |= _bit_mask(bit)
+
+				/* clear bit N of bitstring name */
+#define	bit_clear(name, bit) \
+	(name)[_bit_byte(bit)] &= ~_bit_mask(bit)
+
+				/* clear bits start ... stop in bitstring */
+#define	bit_nclear(name, start, stop) { \
+	register bitstr_t *_name = name; \
+	register int _start = start, _stop = stop; \
+	register int _startbyte = _bit_byte(_start); \
+	register int _stopbyte = _bit_byte(_stop); \
+	if (_startbyte == _stopbyte) { \
+		_name[_startbyte] &= ((0xff >> (8 - (_start&0x7))) | \
+				      (0xff << ((_stop&0x7) + 1))); \
+	} else { \
+		_name[_startbyte] &= 0xff >> (8 - (_start&0x7)); \
+		while (++_startbyte < _stopbyte) \
+			_name[_startbyte] = 0; \
+		_name[_stopbyte] &= 0xff << ((_stop&0x7) + 1); \
+	} \
+}
+
+				/* set bits start ... stop in bitstring */
+#define	bit_nset(name, start, stop) { \
+	register bitstr_t *_name = name; \
+	register int _start = start, _stop = stop; \
+	register int _startbyte = _bit_byte(_start); \
+	register int _stopbyte = _bit_byte(_stop); \
+	if (_startbyte == _stopbyte) { \
+		_name[_startbyte] |= ((0xff << (_start&0x7)) & \
+				    (0xff >> (7 - (_stop&0x7)))); \
+	} else { \
+		_name[_startbyte] |= 0xff << ((_start)&0x7); \
+		while (++_startbyte < _stopbyte) \
+	    		_name[_startbyte] = 0xff; \
+		_name[_stopbyte] |= 0xff >> (7 - (_stop&0x7)); \
+	} \
+}
+
+				/* find first bit clear in name */
+#define	bit_ffc(name, nbits, value) { \
+	register bitstr_t *_name = name; \
+	register int _byte, _nbits = nbits; \
+	register int _stopbyte = _bit_byte(_nbits), _value = -1; \
+	for (_byte = 0; _byte <= _stopbyte; ++_byte) \
+		if (_name[_byte] != 0xff) { \
+			_value = _byte << 3; \
+			for (_stopbyte = _name[_byte]; (_stopbyte&0x1); \
+			    ++_value, _stopbyte >>= 1); \
+			break; \
+		} \
+	*(value) = _value; \
+}
+
+				/* find first bit set in name */
+#define	bit_ffs(name, nbits, value) { \
+	register bitstr_t *_name = name; \
+	register int _byte, _nbits = nbits; \
+	register int _stopbyte = _bit_byte(_nbits), _value = -1; \
+	for (_byte = 0; _byte <= _stopbyte; ++_byte) \
+		if (_name[_byte]) { \
+			_value = _byte << 3; \
+			for (_stopbyte = _name[_byte]; !(_stopbyte&0x1); \
+			    ++_value, _stopbyte >>= 1); \
+			break; \
+		} \
+	*(value) = _value; \
+}
+
+#endif /* !_BITSTRING_H_ */
diff -Npur diskdev_cmds.org/include/hfs/hfs_format.h diskdev_cmds/include/hfs/hfs_format.h
--- diskdev_cmds.org/include/hfs/hfs_format.h	1970-01-01 01:00:00.000000000 +0100
+++ diskdev_cmds/include/hfs/hfs_format.h	2003-05-05 16:51:14.000000000 +0200
@@ -0,0 +1,638 @@
+/*
+ * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * The contents of this file constitute Original Code as defined in and
+ * are subject to the Apple Public Source License Version 1.1 (the
+ * "License").  You may not use this file except in compliance with the
+ * License.  Please obtain a copy of the License at
+ * http://www.apple.com/publicsource and read it before using this file.
+ * 
+ * This Original Code and all software distributed under the License are
+ * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
+ * License for the specific language governing rights and limitations
+ * under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+#ifndef __HFS_FORMAT__
+#define __HFS_FORMAT__
+
+#include <sys/appleapiopts.h>
+
+/*
+ * hfs_format.c
+ *
+ * This file describes the on-disk format for HFS and HFS Plus volumes.
+ * The HFS Plus volume format is desciibed in detail in Apple Technote 1150.
+ *
+ * http://developer.apple.com/technotes/tn/tn1150.html
+ *
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* some on-disk hfs structures have 68K alignment (misaligned) */
+#if __APPLE__
+#pragma options align=mac68k
+#else
+#define __packed __attribute__ ((packed))
+#endif
+
+/* Signatures used to differentiate between HFS and HFS Plus volumes */
+enum {
+	kHFSSigWord		= 0x4244,	/* 'BD' in ASCII */
+	kHFSPlusSigWord		= 0x482B,	/* 'H+' in ASCII */
+	kHFSJSigWord		= 0x484a,	/* 'HJ' in ASCII */
+	kHFSPlusVersion		= 0x0004,	/* will change as format changes */
+						/* version 4 shipped with Mac OS 8.1 */
+	kHFSPlusMountVersion	= 0x31302E30,	/* '10.0' for Mac OS X */
+	kHFSJMountVersion	= 0x4846534a	/* 'HFSJ' for journaled HFS+ on OS X */
+};
+
+
+#ifdef __APPLE_API_PRIVATE
+/*
+ * Mac OS X has a special directory for linked and unlinked files (HFS Plus only).
+ * This directory and its contents are never exported from the filesystem under
+ * Mac OS X.
+ *
+ * To make this folder name sort last,  it has embedded null prefix.
+ * (0xC0, 0x80 in UTF-8)
+ */
+#define HFSPLUSMETADATAFOLDER  "\xC0\x80\xC0\x80\xC0\x80\xC0\x80HFS+ Private Data"
+
+/*
+ * Files in the HFS Private Data folder have one of the following prefixes
+ * followed by a decimal number (no leading zeros).  For indirect nodes this
+ * number is a 32 bit random number.  For unlinked (deleted) files that are
+ * still open, the number is the file ID for that file.
+ *
+ * e.g.  iNode7182000 and temp3296
+ */
+#define HFS_INODE_PREFIX	"iNode"
+#define HFS_DELETE_PREFIX	"temp"
+
+#endif /* __APPLE_API_PRIVATE */
+
+/*
+ * Indirect link files (hard links) have the following type/creator.
+ */
+enum {
+	kHardLinkFileType = 0x686C6E6B,  /* 'hlnk' */
+	kHFSPlusCreator   = 0x6866732B   /* 'hfs+' */
+};
+
+
+/* Unicode strings are used for HFS Plus file and folder names */
+struct HFSUniStr255 {
+	u_int16_t	length;		/* number of unicode characters */
+	u_int16_t	unicode[255];	/* unicode characters */
+} __packed;
+typedef struct HFSUniStr255 HFSUniStr255;
+typedef const HFSUniStr255 *ConstHFSUniStr255Param;
+
+enum {
+	kHFSMaxVolumeNameChars		= 27,
+	kHFSMaxFileNameChars		= 31,
+	kHFSPlusMaxFileNameChars	= 255
+};
+
+
+/* Extent overflow file data structures */
+
+/* HFS Extent key */
+struct HFSExtentKey {
+	u_int8_t 	keyLength;	/* length of key, excluding this field */
+	u_int8_t 	forkType;	/* 0 = data fork, FF = resource fork */
+	u_int32_t 	fileID;		/* file ID */
+	u_int16_t 	startBlock;	/* first file allocation block number in this extent */
+} __packed;
+typedef struct HFSExtentKey HFSExtentKey;
+
+/* HFS Plus Extent key */
+struct HFSPlusExtentKey {
+	u_int16_t 	keyLength;		/* length of key, excluding this field */
+	u_int8_t 	forkType;		/* 0 = data fork, FF = resource fork */
+	u_int8_t 	pad;			/* make the other fields align on 32-bit boundary */
+	u_int32_t 	fileID;			/* file ID */
+	u_int32_t 	startBlock;		/* first file allocation block number in this extent */
+} __packed;
+typedef struct HFSPlusExtentKey HFSPlusExtentKey;
+
+/* Number of extent descriptors per extent record */
+enum {
+	kHFSExtentDensity	= 3,
+	kHFSPlusExtentDensity	= 8
+};
+
+/* HFS extent descriptor */
+struct HFSExtentDescriptor {
+	u_int16_t 	startBlock;		/* first allocation block */
+	u_int16_t 	blockCount;		/* number of allocation blocks */
+} __packed;
+typedef struct HFSExtentDescriptor HFSExtentDescriptor;
+
+/* HFS Plus extent descriptor */
+struct HFSPlusExtentDescriptor {
+	u_int32_t 	startBlock;		/* first allocation block */
+	u_int32_t 	blockCount;		/* number of allocation blocks */
+} __packed;
+typedef struct HFSPlusExtentDescriptor HFSPlusExtentDescriptor;
+
+/* HFS extent record */
+typedef HFSExtentDescriptor HFSExtentRecord[3];
+
+/* HFS Plus extent record */
+typedef HFSPlusExtentDescriptor HFSPlusExtentRecord[8];
+
+
+/* Finder information */
+struct FndrFileInfo {
+	u_int32_t 	fdType;		/* file type */
+	u_int32_t 	fdCreator;	/* file creator */
+	u_int16_t 	fdFlags;	/* Finder flags */
+	struct {
+	    int16_t	v;		/* file's location */
+	    int16_t	h;
+	} fdLocation;
+	int16_t 	opaque;
+} __packed;
+typedef struct FndrFileInfo FndrFileInfo;
+
+struct FndrDirInfo {
+	struct {			/* folder's window rectangle */
+	    int16_t	top;
+	    int16_t	left;
+	    int16_t	bottom;
+	    int16_t	right;
+	} frRect;
+	u_int16_t frFlags;	/* Finder flags */
+	struct {
+	    u_int16_t	v;		/* folder's location */
+	    u_int16_t	h;
+	} frLocation;
+	int16_t 	opaque;
+} __packed;
+typedef struct FndrDirInfo FndrDirInfo;
+
+struct FndrOpaqueInfo {
+	int8_t opaque[16];
+} __packed;
+typedef struct FndrOpaqueInfo FndrOpaqueInfo;
+
+
+/* HFS Plus Fork data info - 80 bytes */
+struct HFSPlusForkData {
+	u_int64_t 		logicalSize;	/* fork's logical size in bytes */
+	u_int32_t 		clumpSize;	/* fork's clump size in bytes */
+	u_int32_t 		totalBlocks;	/* total blocks used by this fork */
+	HFSPlusExtentRecord 	extents;	/* initial set of extents */
+} __packed;
+typedef struct HFSPlusForkData HFSPlusForkData;
+
+
+/* Mac OS X has 16 bytes worth of "BSD" info.
+ *
+ * Note:  Mac OS 9 implementations and applications
+ * should preserve, but not change, this information.
+ */
+struct HFSPlusBSDInfo {
+	u_int32_t 	ownerID;	/* user or group ID of file/folder owner */
+	u_int32_t 	groupID;	/* additional user of group ID */
+	u_int8_t 	adminFlags;	/* super-user changeable flags */
+	u_int8_t 	ownerFlags;	/* owner changeable flags */
+	u_int16_t 	fileMode;	/* file type and permission bits */
+	union {
+	    u_int32_t	iNodeNum;	/* indirect node number (hard links only) */
+	    u_int32_t	linkCount;	/* links that refer to this indirect node */
+	    u_int32_t	rawDevice;	/* special file device (FBLK and FCHR only) */
+	} special;
+} __packed;
+typedef struct HFSPlusBSDInfo HFSPlusBSDInfo;
+
+
+/* Catalog file data structures */
+
+enum {
+	kHFSRootParentID		= 1,	/* Parent ID of the root folder */
+	kHFSRootFolderID		= 2,	/* Folder ID of the root folder */
+	kHFSExtentsFileID		= 3,	/* File ID of the extents file */
+	kHFSCatalogFileID		= 4,	/* File ID of the catalog file */
+	kHFSBadBlockFileID		= 5,	/* File ID of the bad allocation block file */
+	kHFSAllocationFileID		= 6,	/* File ID of the allocation file (HFS Plus only) */
+	kHFSStartupFileID		= 7,	/* File ID of the startup file (HFS Plus only) */
+	kHFSAttributesFileID		= 8,	/* File ID of the attribute file (HFS Plus only) */
+	kHFSBogusExtentFileID		= 15,	/* Used for exchanging extents in extents file */
+	kHFSFirstUserCatalogNodeID	= 16
+};
+
+/* HFS catalog key */
+struct HFSCatalogKey {
+	u_int8_t 	keyLength;		/* key length (in bytes) */
+	u_int8_t 	reserved;		/* reserved (set to zero) */
+	u_int32_t 	parentID;		/* parent folder ID */
+	u_char 		nodeName[kHFSMaxFileNameChars + 1]; /* catalog node name */
+} __packed;
+typedef struct HFSCatalogKey HFSCatalogKey;
+
+/* HFS Plus catalog key */
+struct HFSPlusCatalogKey {
+	u_int16_t 		keyLength;	/* key length (in bytes) */
+	u_int32_t 		parentID;	/* parent folder ID */
+	HFSUniStr255 		nodeName;	/* catalog node name */
+} __packed;
+typedef struct HFSPlusCatalogKey HFSPlusCatalogKey;
+
+/* Catalog record types */
+enum {
+	/* HFS Catalog Records */
+	kHFSFolderRecord		= 0x0100,	/* Folder record */
+	kHFSFileRecord			= 0x0200,	/* File record */
+	kHFSFolderThreadRecord		= 0x0300,	/* Folder thread record */
+	kHFSFileThreadRecord		= 0x0400,	/* File thread record */
+
+	/* HFS Plus Catalog Records */
+	kHFSPlusFolderRecord		= 1,		/* Folder record */
+	kHFSPlusFileRecord		= 2,		/* File record */
+	kHFSPlusFolderThreadRecord	= 3,		/* Folder thread record */
+	kHFSPlusFileThreadRecord	= 4		/* File thread record */
+};
+
+
+/* Catalog file record flags */
+enum {
+	kHFSFileLockedBit	= 0x0000,	/* file is locked and cannot be written to */
+	kHFSFileLockedMask	= 0x0001,
+	kHFSThreadExistsBit	= 0x0001,	/* a file thread record exists for this file */
+	kHFSThreadExistsMask	= 0x0002
+};
+
+
+/* HFS catalog folder record - 70 bytes */
+struct HFSCatalogFolder {
+	int16_t 		recordType;		/* == kHFSFolderRecord */
+	u_int16_t 		flags;			/* folder flags */
+	u_int16_t 		valence;		/* folder valence */
+	u_int32_t		folderID;		/* folder ID */
+	u_int32_t 		createDate;		/* date and time of creation */
+	u_int32_t 		modifyDate;		/* date and time of last modification */
+	u_int32_t 		backupDate;		/* date and time of last backup */
+	FndrDirInfo 		userInfo;		/* Finder information */
+	FndrOpaqueInfo		finderInfo;		/* additional Finder information */
+	u_int32_t 		reserved[4];		/* reserved - initialized as zero */
+} __packed;
+typedef struct HFSCatalogFolder HFSCatalogFolder;
+
+/* HFS Plus catalog folder record - 88 bytes */
+struct HFSPlusCatalogFolder {
+	int16_t 		recordType;		/* == kHFSPlusFolderRecord */
+	u_int16_t 		flags;			/* file flags */
+	u_int32_t 		valence;		/* folder's valence (limited to 2^16 in Mac OS) */
+	u_int32_t 		folderID;		/* folder ID */
+	u_int32_t 		createDate;		/* date and time of creation */
+	u_int32_t 		contentModDate;		/* date and time of last content modification */
+	u_int32_t 		attributeModDate;	/* date and time of last attribute modification */
+	u_int32_t 		accessDate;		/* date and time of last access (MacOS X only) */
+	u_int32_t 		backupDate;		/* date and time of last backup */
+	HFSPlusBSDInfo		bsdInfo;		/* permissions (for MacOS X) */
+	FndrDirInfo 		userInfo;		/* Finder information */
+	FndrOpaqueInfo	 	finderInfo;		/* additional Finder information */
+	u_int32_t 		textEncoding;		/* hint for name conversions */
+	u_int32_t 		reserved;		/* reserved - initialized as zero */
+} __packed;
+typedef struct HFSPlusCatalogFolder HFSPlusCatalogFolder;
+
+/* HFS catalog file record - 102 bytes */
+struct HFSCatalogFile {
+	int16_t 		recordType;		/* == kHFSFileRecord */
+	u_int8_t 		flags;			/* file flags */
+	int8_t 			fileType;		/* file type (unused ?) */
+	FndrFileInfo 		userInfo;		/* Finder information */
+	u_int32_t 		fileID;			/* file ID */
+	u_int16_t 		dataStartBlock;		/* not used - set to zero */
+	int32_t 		dataLogicalSize;	/* logical EOF of data fork */
+	int32_t 		dataPhysicalSize;	/* physical EOF of data fork */
+	u_int16_t		rsrcStartBlock;		/* not used - set to zero */
+	int32_t			rsrcLogicalSize;	/* logical EOF of resource fork */
+	int32_t			rsrcPhysicalSize;	/* physical EOF of resource fork */
+	u_int32_t		createDate;		/* date and time of creation */
+	u_int32_t		modifyDate;		/* date and time of last modification */
+	u_int32_t		backupDate;		/* date and time of last backup */
+	FndrOpaqueInfo		finderInfo;		/* additional Finder information */
+	u_int16_t		clumpSize;		/* file clump size (not used) */
+	HFSExtentRecord		dataExtents;		/* first data fork extent record */
+	HFSExtentRecord		rsrcExtents;		/* first resource fork extent record */
+	u_int32_t		reserved;		/* reserved - initialized as zero */
+} __packed;
+typedef struct HFSCatalogFile HFSCatalogFile;
+
+/* HFS Plus catalog file record - 248 bytes */
+struct HFSPlusCatalogFile {
+	int16_t 		recordType;		/* == kHFSPlusFileRecord */
+	u_int16_t 		flags;			/* file flags */
+	u_int32_t 		reserved1;		/* reserved - initialized as zero */
+	u_int32_t 		fileID;			/* file ID */
+	u_int32_t 		createDate;		/* date and time of creation */
+	u_int32_t 		contentModDate;		/* date and time of last content modification */
+	u_int32_t 		attributeModDate;	/* date and time of last attribute modification */
+	u_int32_t 		accessDate;		/* date and time of last access (MacOS X only) */
+	u_int32_t 		backupDate;		/* date and time of last backup */
+	HFSPlusBSDInfo 		bsdInfo;		/* permissions (for MacOS X) */
+	FndrFileInfo 		userInfo;		/* Finder information */
+	FndrOpaqueInfo	 	finderInfo;		/* additional Finder information */
+	u_int32_t 		textEncoding;		/* hint for name conversions */
+	u_int32_t 		reserved2;		/* reserved - initialized as zero */
+
+	/* Note: these start on double long (64 bit) boundry */
+	HFSPlusForkData 	dataFork;		/* size and block data for data fork */
+	HFSPlusForkData 	resourceFork;		/* size and block data for resource fork */
+} __packed;
+typedef struct HFSPlusCatalogFile HFSPlusCatalogFile;
+
+/* HFS catalog thread record - 46 bytes */
+struct HFSCatalogThread {
+	int16_t 	recordType;		/* == kHFSFolderThreadRecord or kHFSFileThreadRecord */
+	int32_t 	reserved[2];		/* reserved - initialized as zero */
+	u_int32_t 	parentID;		/* parent ID for this catalog node */
+	u_char 		nodeName[kHFSMaxFileNameChars + 1]; /* name of this catalog node */
+} __packed;
+typedef struct HFSCatalogThread HFSCatalogThread;
+
+/* HFS Plus catalog thread record -- 264 bytes */
+struct HFSPlusCatalogThread {
+	int16_t 	recordType;		/* == kHFSPlusFolderThreadRecord or kHFSPlusFileThreadRecord */
+	int16_t 	reserved;		/* reserved - initialized as zero */
+	u_int32_t 	parentID;		/* parent ID for this catalog node */
+	HFSUniStr255 	nodeName;		/* name of this catalog node (variable length) */
+} __packed;
+typedef struct HFSPlusCatalogThread HFSPlusCatalogThread;
+
+#ifdef __APPLE_API_UNSTABLE
+/*
+  	These are the types of records in the attribute B-tree.  The values were
+  	chosen so that they wouldn't conflict with the catalog record types.
+*/
+enum {
+	kHFSPlusAttrInlineData	= 0x10,		/* if size <  kAttrOverflowSize */
+	kHFSPlusAttrForkData	= 0x20,		/* if size >= kAttrOverflowSize */
+	kHFSPlusAttrExtents	= 0x30		/* overflow extents for large attributes */
+};
+
+
+/*
+  	HFSPlusAttrInlineData
+  	For small attributes, whose entire value is stored within this one
+  	B-tree record.
+  	There would not be any other records for this attribute.
+*/
+struct HFSPlusAttrInlineData {
+	u_int32_t 	recordType;		/* == kHFSPlusAttrInlineData*/
+	u_int32_t 	reserved;
+	u_int32_t 	logicalSize;		/* size in bytes of userData*/
+	u_int8_t 	userData[2];		/* variable length; space allocated is a multiple of 2 bytes*/
+} __packed;
+typedef struct HFSPlusAttrInlineData HFSPlusAttrInlineData;
+
+
+/*
+  	HFSPlusAttrForkData
+  	For larger attributes, whose value is stored in allocation blocks.
+  	If the attribute has more than 8 extents, there will be additonal
+  	records (of type HFSPlusAttrExtents) for this attribute.
+*/
+struct HFSPlusAttrForkData {
+	u_int32_t 	recordType;		/* == kHFSPlusAttrForkData*/
+	u_int32_t 	reserved;
+	HFSPlusForkData theFork;		/* size and first extents of value*/
+} __packed;
+typedef struct HFSPlusAttrForkData HFSPlusAttrForkData;
+
+/*
+  	HFSPlusAttrExtents
+  	This record contains information about overflow extents for large,
+  	fragmented attributes.
+*/
+struct HFSPlusAttrExtents {
+	u_int32_t 		recordType;	/* == kHFSPlusAttrExtents*/
+	u_int32_t 		reserved;
+	HFSPlusExtentRecord	extents;	/* additional extents*/
+} __packed;
+typedef struct HFSPlusAttrExtents HFSPlusAttrExtents;
+
+/*	A generic Attribute Record*/
+union HFSPlusAttrRecord {
+	u_int32_t 		recordType;
+	HFSPlusAttrInlineData 	inlineData;
+	HFSPlusAttrForkData 	forkData;
+	HFSPlusAttrExtents 	overflowExtents;
+};
+typedef union HFSPlusAttrRecord HFSPlusAttrRecord;
+
+/* Key and node lengths */
+enum {
+	kHFSPlusExtentKeyMaximumLength = sizeof(HFSPlusExtentKey) - sizeof(u_int16_t),
+	kHFSExtentKeyMaximumLength	= sizeof(HFSExtentKey) - sizeof(u_int8_t),
+	kHFSPlusCatalogKeyMaximumLength = sizeof(HFSPlusCatalogKey) - sizeof(u_int16_t),
+	kHFSPlusCatalogKeyMinimumLength = kHFSPlusCatalogKeyMaximumLength - sizeof(HFSUniStr255) + sizeof(u_int16_t),
+	kHFSCatalogKeyMaximumLength	= sizeof(HFSCatalogKey) - sizeof(u_int8_t),
+	kHFSCatalogKeyMinimumLength	= kHFSCatalogKeyMaximumLength - (kHFSMaxFileNameChars + 1) + sizeof(u_int8_t),
+	kHFSPlusCatalogMinNodeSize	= 4096,
+	kHFSPlusExtentMinNodeSize	= 512,
+	kHFSPlusAttrMinNodeSize		= 4096
+};
+#endif /* __APPLE_API_UNSTABLE */
+
+/* HFS and HFS Plus volume attribute bits */
+enum {
+							/* Bits 0-6 are reserved (always cleared by MountVol call) */
+	kHFSVolumeHardwareLockBit	= 7,		/* volume is locked by hardware */
+	kHFSVolumeUnmountedBit		= 8,		/* volume was successfully unmounted */
+	kHFSVolumeSparedBlocksBit	= 9,		/* volume has bad blocks spared */
+	kHFSVolumeNoCacheRequiredBit = 10,		/* don't cache volume blocks (i.e. RAM or ROM disk) */
+	kHFSBootVolumeInconsistentBit = 11,		/* boot volume is inconsistent (System 7.6 and later) */
+	kHFSCatalogNodeIDsReusedBit = 12,
+	kHFSVolumeJournaledBit = 13,			/* this volume has a journal on it */
+							/* Bit 14 is reserved for future use */
+	kHFSVolumeSoftwareLockBit	= 15,		/* volume is locked by software */
+
+	kHFSVolumeHardwareLockMask	= 1 << kHFSVolumeHardwareLockBit,
+	kHFSVolumeUnmountedMask		= 1 << kHFSVolumeUnmountedBit,
+	kHFSVolumeSparedBlocksMask	= 1 << kHFSVolumeSparedBlocksBit,
+	kHFSVolumeNoCacheRequiredMask = 1 << kHFSVolumeNoCacheRequiredBit,
+	kHFSBootVolumeInconsistentMask = 1 << kHFSBootVolumeInconsistentBit,
+	kHFSCatalogNodeIDsReusedMask = 1 << kHFSCatalogNodeIDsReusedBit,
+	kHFSVolumeJournaledMask	= 1 << kHFSVolumeJournaledBit,
+	kHFSVolumeSoftwareLockMask	= 1 << kHFSVolumeSoftwareLockBit,
+	kHFSMDBAttributesMask		= 0x8380
+};
+
+
+/* HFS Master Directory Block - 162 bytes */
+/* Stored at sector #2 (3rd sector) and second-to-last sector. */
+struct HFSMasterDirectoryBlock {
+	u_int16_t 		drSigWord;	/* == kHFSSigWord */
+	u_int32_t 		drCrDate;	/* date and time of volume creation */
+	u_int32_t 		drLsMod;	/* date and time of last modification */
+	u_int16_t 		drAtrb;		/* volume attributes */
+	u_int16_t 		drNmFls;	/* number of files in root folder */
+	u_int16_t 		drVBMSt;	/* first block of volume bitmap */
+	u_int16_t 		drAllocPtr;	/* start of next allocation search */
+	u_int16_t 		drNmAlBlks;	/* number of allocation blocks in volume */
+	u_int32_t 		drAlBlkSiz;	/* size (in bytes) of allocation blocks */
+	u_int32_t 		drClpSiz;	/* default clump size */
+	u_int16_t 		drAlBlSt;	/* first allocation block in volume */
+	u_int32_t 		drNxtCNID;	/* next unused catalog node ID */
+	u_int16_t 		drFreeBks;	/* number of unused allocation blocks */
+	u_char 			drVN[kHFSMaxVolumeNameChars + 1];  /* volume name */
+	u_int32_t 		drVolBkUp;	/* date and time of last backup */
+	u_int16_t 		drVSeqNum;	/* volume backup sequence number */
+	u_int32_t 		drWrCnt;	/* volume write count */
+	u_int32_t 		drXTClpSiz;	/* clump size for extents overflow file */
+	u_int32_t 		drCTClpSiz;	/* clump size for catalog file */
+	u_int16_t 		drNmRtDirs;	/* number of directories in root folder */
+	u_int32_t 		drFilCnt;	/* number of files in volume */
+	u_int32_t 		drDirCnt;	/* number of directories in volume */
+	u_int32_t 		drFndrInfo[8];	/* information used by the Finder */
+	u_int16_t 		drEmbedSigWord;	/* embedded volume signature (formerly drVCSize) */
+	HFSExtentDescriptor	drEmbedExtent;	/* embedded volume location and size (formerly drVBMCSize and drCtlCSize) */
+	u_int32_t		drXTFlSize;	/* size of extents overflow file */
+	HFSExtentRecord		drXTExtRec;	/* extent record for extents overflow file */
+	u_int32_t 		drCTFlSize;	/* size of catalog file */
+	HFSExtentRecord 	drCTExtRec;	/* extent record for catalog file */
+} __packed;
+typedef struct HFSMasterDirectoryBlock	HFSMasterDirectoryBlock;
+
+
+/* HFS Plus Volume Header - 512 bytes */
+/* Stored at sector #2 (3rd sector) and second-to-last sector. */
+struct HFSPlusVolumeHeader {
+	u_int16_t 	signature;		/* == kHFSPlusSigWord */
+	u_int16_t 	version;		/* == kHFSPlusVersion */
+	u_int32_t 	attributes;		/* volume attributes */
+	u_int32_t 	lastMountedVersion;	/* implementation version which last mounted volume */
+//XXXdbg	u_int32_t 	reserved;		/* reserved - initialized as zero */
+	u_int32_t 	journalInfoBlock;	/* block addr of journal info (if volume is journaled, zero otherwise) */
+
+	u_int32_t 	createDate;		/* date and time of volume creation */
+	u_int32_t 	modifyDate;		/* date and time of last modification */
+	u_int32_t 	backupDate;		/* date and time of last backup */
+	u_int32_t 	checkedDate;		/* date and time of last disk check */
+
+	u_int32_t 	fileCount;		/* number of files in volume */
+	u_int32_t 	folderCount;		/* number of directories in volume */
+
+	u_int32_t 	blockSize;		/* size (in bytes) of allocation blocks */
+	u_int32_t 	totalBlocks;		/* number of allocation blocks in volume (includes this header and VBM*/
+	u_int32_t 	freeBlocks;		/* number of unused allocation blocks */
+
+	u_int32_t 	nextAllocation;		/* start of next allocation search */
+	u_int32_t 	rsrcClumpSize;		/* default resource fork clump size */
+	u_int32_t 	dataClumpSize;		/* default data fork clump size */
+	u_int32_t 	nextCatalogID;		/* next unused catalog node ID */
+
+	u_int32_t 	writeCount;		/* volume write count */
+	u_int64_t 	encodingsBitmap;	/* which encodings have been use  on this volume */
+
+	u_int8_t 	finderInfo[32];		/* information used by the Finder */
+
+	HFSPlusForkData	 allocationFile;	/* allocation bitmap file */
+	HFSPlusForkData  extentsFile;		/* extents B-tree file */
+	HFSPlusForkData  catalogFile;		/* catalog B-tree file */
+	HFSPlusForkData  attributesFile;	/* extended attributes B-tree file */
+	HFSPlusForkData	 startupFile;		/* boot file (secondary loader) */
+} __packed;
+typedef struct HFSPlusVolumeHeader HFSPlusVolumeHeader;
+
+
+/* B-tree structures */
+
+enum BTreeKeyLimits{
+	kMaxKeyLength	= 520
+};
+
+union BTreeKey{
+	u_int8_t	length8;
+	u_int16_t	length16;
+	u_int8_t	rawData [kMaxKeyLength+2];
+};
+typedef union BTreeKey BTreeKey;
+
+/* BTNodeDescriptor -- Every B-tree node starts with these fields. */
+struct BTNodeDescriptor {
+	u_int32_t	fLink;			/* next node at this level*/
+	u_int32_t 	bLink;			/* previous node at this level*/
+	int8_t 		kind;			/* kind of node (leaf, index, header, map)*/
+	u_int8_t 	height;			/* zero for header, map; child is one more than parent*/
+	u_int16_t 	numRecords;		/* number of records in this node*/
+	u_int16_t 	reserved;		/* reserved - initialized as zero */
+} __packed;
+typedef struct BTNodeDescriptor BTNodeDescriptor;
+
+/* Constants for BTNodeDescriptor kind */
+enum {
+	kBTLeafNode	= -1,
+	kBTIndexNode	= 0,
+	kBTHeaderNode	= 1,
+	kBTMapNode	= 2
+};
+
+/* BTHeaderRec -- The first record of a B-tree header node */
+struct BTHeaderRec {
+	u_int16_t	treeDepth;		/* maximum height (usually leaf nodes) */
+	u_int32_t 	rootNode;		/* node number of root node */
+	u_int32_t 	leafRecords;		/* number of leaf records in all leaf nodes */
+	u_int32_t 	firstLeafNode;		/* node number of first leaf node */
+	u_int32_t 	lastLeafNode;		/* node number of last leaf node */
+	u_int16_t 	nodeSize;		/* size of a node, in bytes */
+	u_int16_t 	maxKeyLength;		/* reserved */
+	u_int32_t 	totalNodes;		/* total number of nodes in tree */
+	u_int32_t 	freeNodes;		/* number of unused (free) nodes in tree */
+	u_int16_t 	reserved1;		/* unused */
+	u_int32_t 	clumpSize;		/* reserved */
+	u_int8_t 	btreeType;		/* reserved */
+	u_int8_t 	reserved2;		/* reserved */
+	u_int32_t 	attributes;		/* persistent attributes about the tree */
+	u_int32_t 	reserved3[16];		/* reserved */
+} __packed;
+typedef struct BTHeaderRec BTHeaderRec;
+
+/* Constants for BTHeaderRec attributes */
+enum {
+	kBTBadCloseMask		 = 0x00000001,	/* reserved */
+	kBTBigKeysMask		 = 0x00000002,	/* key length field is 16 bits */
+	kBTVariableIndexKeysMask = 0x00000004	/* keys in index nodes are variable length */
+};
+
+/* JournalInfoBlock - Structure that describes where our journal lives */
+struct JournalInfoBlock {
+	u_int32_t	flags;
+    	u_int32_t       device_signature[8];  // signature used to locate our device.
+	u_int64_t       offset;               // byte offset to the journal on the device
+	u_int64_t       size;                 // size in bytes of the journal
+	u_int32_t 	reserved[32];
+} __packed;
+typedef struct JournalInfoBlock JournalInfoBlock;
+
+enum {
+    kJIJournalInFSMask          = 0x00000001,
+    kJIJournalOnOtherDeviceMask = 0x00000002,
+    kJIJournalNeedInitMask      = 0x00000004
+};
+
+
+#if __APPLE__
+#pragma options align=reset
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HFS_FORMAT__ */
diff -Npur diskdev_cmds.org/include/sys/appleapiopts.h diskdev_cmds/include/sys/appleapiopts.h
--- diskdev_cmds.org/include/sys/appleapiopts.h	1970-01-01 01:00:00.000000000 +0100
+++ diskdev_cmds/include/sys/appleapiopts.h	2003-04-10 18:45:28.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * The contents of this file constitute Original Code as defined in and
+ * are subject to the Apple Public Source License Version 1.1 (the
+ * "License").  You may not use this file except in compliance with the
+ * License.  Please obtain a copy of the License at
+ * http://www.apple.com/publicsource and read it before using this file.
+ * 
+ * This Original Code and all software distributed under the License are
+ * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
+ * License for the specific language governing rights and limitations
+ * under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+
+#ifndef __SYS_APPLEAPIOPTS_H__
+#define __SYS_APPLEAPIOPTS_H__
+
+
+#ifndef __APPLE_API_STANDARD
+#define __APPLE_API_STANDARD
+#endif /* __APPLE_API_STANDARD */
+
+#ifndef __APPLE_API_STABLE
+#define __APPLE_API_STABLE
+#endif /* __APPLE_API_STABLE */
+
+#ifndef __APPLE_API_STRICT_CONFORMANCE
+
+#ifndef __APPLE_API_EVOLVING
+#define __APPLE_API_EVOLVING
+#endif /* __APPLE_API_EVOLVING */
+
+#ifndef __APPLE_API_UNSTABLE
+#define __APPLE_API_UNSTABLE
+#endif /* __APPLE_API_UNSTABLE */
+
+#ifndef __APPLE_API_PRIVATE
+#define __APPLE_API_PRIVATE
+#endif /* __APPLE_API_PRIVATE */
+
+#ifndef __APPLE_API_OBSOLETE
+#define __APPLE_API_OBSOLETE
+#endif /* __APPLE_API_OBSOLETE */
+
+#endif /* __APPLE_API_STRICT_CONFORMANCE */
+
+#endif /* __SYS_APPLEAPIOPTS_H__ */
+
diff -Npur diskdev_cmds.org/newfs_hfs.tproj/Makefile.lnx diskdev_cmds/newfs_hfs.tproj/Makefile.lnx
--- diskdev_cmds.org/newfs_hfs.tproj/Makefile.lnx	1970-01-01 01:00:00.000000000 +0100
+++ diskdev_cmds/newfs_hfs.tproj/Makefile.lnx	2003-07-07 15:22:33.000000000 +0200
@@ -0,0 +1,11 @@
+CFILES = makehfs.c newfs_hfs.c
+OFILES = $(CFILES:.c=.o)
+
+all: newfs_hfs
+
+newfs_hfs: $(OFILES)
+
+clean:
+	$(RM) newfs_hfs $(OFILES)
+
+.PHONY : FORCE clean
diff -Npur diskdev_cmds.org/newfs_hfs.tproj/hfs_endian.h diskdev_cmds/newfs_hfs.tproj/hfs_endian.h
--- diskdev_cmds.org/newfs_hfs.tproj/hfs_endian.h	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/newfs_hfs.tproj/hfs_endian.h	2003-07-04 15:28:03.000000000 +0200
@@ -31,36 +31,36 @@
 #include <hfs/hfs_format.h>
 #include <architecture/byte_order.h>
 
-/*********************/
-/* BIG ENDIAN Macros */
-/*********************/
-#if BYTE_ORDER == BIG_ENDIAN
-
-    /* HFS is always big endian, make swaps into no-ops */
-    #define SWAP_BE16(__a) (__a)
-    #define SWAP_BE32(__a) (__a)
-    #define SWAP_BE64(__a) (__a)
-    
-    /* HFS is always big endian, no swapping needed */
-    #define SWAP_HFSMDB(__a)
-    #define SWAP_HFSPLUSVH(__a)
-
-/************************/
-/* LITTLE ENDIAN Macros */
-/************************/
-#elif BYTE_ORDER == LITTLE_ENDIAN
+#if 0
+typedef struct {
+	u_int16_t u16;
+} __packed u_big_int16_t;
+
+typedef struct {
+	u_int32_t u32;
+} __packed u_big_int32_t;
+
+typedef struct {
+	u_int64_t u64;
+} __packed u_big_int64_t;
+
+    #define SWAP_BE16(__a) 							NXSwapBigShortToHost ((__a).u16)
+	#define SET_SWAP_BE16(__d, __a)					(__d).u16 = NXSwapBigShortToHost(__a)
+    #define SWAP_BE32(__a) 							NXSwapBigLongToHost ((__a).u32)
+	#define SET_SWAP_BE32(__d, __a)					(__d).u32 = NXSwapBigLongToHost(__a)
+    #define SWAP_BE64(__a) 							NXSwapBigLongLongToHost ((__a).u64)
+    #define SET_SWAP_BE64(__d, __a) 				(__d).u64 = NXSwapBigLongLongToHost (__a)
+#else
+typedef u_int16_t u_big_int16_t;
+typedef u_int32_t u_big_int32_t;
+typedef u_int64_t u_big_int64_t;
 
-    /* HFS is always big endian, make swaps actually swap */
     #define SWAP_BE16(__a) 							NXSwapBigShortToHost (__a)
+	#define SET_SWAP_BE16(__d, __a)					(__d) = NXSwapBigShortToHost(__a)
     #define SWAP_BE32(__a) 							NXSwapBigLongToHost (__a)
+	#define SET_SWAP_BE32(__d, __a)					(__d) = NXSwapBigLongToHost(__a)
     #define SWAP_BE64(__a) 							NXSwapBigLongLongToHost (__a)
-    
-    #define SWAP_HFSMDB(__a)						hfs_swap_HFSMasterDirectoryBlock ((__a))
-    #define SWAP_HFSPLUSVH(__a)						hfs_swap_HFSPlusVolumeHeader ((__a));
-
-#else
-#warning Unknown byte order
-#error
+    #define SET_SWAP_BE64(__d, __a) 				(__d) = NXSwapBigLongLongToHost (__a)
 #endif
 
 #ifdef __cplusplus
diff -Npur diskdev_cmds.org/newfs_hfs.tproj/makehfs.c diskdev_cmds/newfs_hfs.tproj/makehfs.c
--- diskdev_cmds.org/newfs_hfs.tproj/makehfs.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/newfs_hfs.tproj/makehfs.c	2003-04-29 17:28:35.000000000 +0200
@@ -45,8 +45,10 @@
 #include <stdio.h>
 #include <string.h>
 
+#if __APPLE__
 #include <CoreFoundation/CFString.h>
 extern Boolean _CFStringGetFileSystemRepresentation(CFStringRef string, UInt8 *buffer, CFIndex maxBufLen);
+#endif
 
 
 #include <hfs/hfs_format.h>
@@ -129,12 +131,12 @@ static UInt32 UTCToLocal __P((UInt32 utc
 static UInt32 DivideAndRoundUp __P((UInt32 numerator, UInt32 denominator));
 
 static int ConvertUTF8toUnicode __P((const UInt8* source, UInt32 bufsize,
-		UniChar* unibuf, UInt16 *charcount));
+		UniChar* unibuf, u_big_int16_t *charcount));
 
 
 void SETOFFSET (void *buffer, UInt16 btNodeSize, SInt16 recOffset, SInt16 vecOffset);
 #define SETOFFSET(buf,ndsiz,offset,rec)		\
-	(*(SInt16 *)((UInt8 *)(buf) + (ndsiz) + (-2 * (rec))) = (SWAP_BE16 (offset)))
+	SET_SWAP_BE16(*(u_big_int16_t*)((UInt8 *)(buf) + (ndsiz) + (-2 * (rec))), (offset))
 
 #define BYTESTOBLKS(bytes,blks)		DivideAndRoundUp((bytes),(blks))
 
@@ -176,7 +178,7 @@ make_hfs(const DriveInfo *driveInfo,
 	mdbp = (HFS_MDB*)malloc((size_t)kBytesPerSector);
 	nodeBuffer = malloc(8192);  /* max bitmap bytes is 8192 bytes */
 	if (nodeBuffer == NULL || mdbp == NULL) 
-		err(1, NULL);
+		exit(1);
 
 	/* MDB Initialized in native byte order */
 	InitMDB(defaults, driveInfo->totalSectors, mdbp);
@@ -184,12 +186,12 @@ make_hfs(const DriveInfo *driveInfo,
 	
 	/*--- ZERO OUT BEGINNING OF DISK (bitmap and b-trees):  */
 	
-	diskBlocksUsed = (mdbp->drAlBlSt + 1) +
-		(mdbp->drXTFlSize + mdbp->drCTFlSize) / kBytesPerSector;
+	diskBlocksUsed = (SWAP_BE16(mdbp->drAlBlSt) + 1) +
+		(SWAP_BE32(mdbp->drXTFlSize) + SWAP_BE32(mdbp->drCTFlSize)) / kBytesPerSector;
 	if (defaults->flags & kMakeHFSWrapper) {
-		diskBlocksUsed += MAX(kDTDB_Size, mdbp->drAlBlkSiz) / kBytesPerSector;
-		diskBlocksUsed += MAX(sizeof(hfswrap_readme), mdbp->drAlBlkSiz) / kBytesPerSector;
-		diskBlocksUsed += MAX(24 * 1024, mdbp->drAlBlkSiz) / kBytesPerSector;
+		diskBlocksUsed += MAX(kDTDB_Size, SWAP_BE32(mdbp->drAlBlkSiz)) / kBytesPerSector;
+		diskBlocksUsed += MAX(sizeof(hfswrap_readme), SWAP_BE32(mdbp->drAlBlkSiz)) / kBytesPerSector;
+		diskBlocksUsed += MAX(24 * 1024, SWAP_BE32(mdbp->drAlBlkSiz)) / kBytesPerSector;
 	}
 	ClearDisk(driveInfo, 0, diskBlocksUsed);
 	/* also clear out last 8 sectors (4K) */
@@ -198,59 +200,59 @@ make_hfs(const DriveInfo *driveInfo,
 	/* If this is a wrapper, add boot files... */
 	if (defaults->flags & kMakeHFSWrapper) {
 
-		sector = mdbp->drAlBlSt + 
-			 mdbp->drXTFlSize/kBytesPerSector +
-			 mdbp->drCTFlSize/kBytesPerSector;
+		sector = SWAP_BE16(mdbp->drAlBlSt) + 
+			 SWAP_BE32(mdbp->drXTFlSize)/kBytesPerSector +
+			 SWAP_BE32(mdbp->drCTFlSize)/kBytesPerSector;
 
 		WriteDesktopDB(defaults, driveInfo, sector, nodeBuffer, &mapNodes);
 
 		if (mapNodes > 0)
 			WriteMapNodes(driveInfo, (sector + 1), 1, mapNodes, kHFSNodeSize, nodeBuffer);
 
-		gDTDBFork.logicalSize = MAX(kDTDB_Size, mdbp->drAlBlkSiz);
-		gDTDBFork.startBlock = (sector - mdbp->drAlBlSt) / sectorsPerBlock;
-		gDTDBFork.blockCount = BYTESTOBLKS(gDTDBFork.logicalSize, mdbp->drAlBlkSiz);
-		gDTDBFork.physicalSize = gDTDBFork.blockCount * mdbp->drAlBlkSiz;
+		gDTDBFork.logicalSize = MAX(kDTDB_Size, SWAP_BE32(mdbp->drAlBlkSiz));
+		gDTDBFork.startBlock = (sector - SWAP_BE16(mdbp->drAlBlSt)) / sectorsPerBlock;
+		gDTDBFork.blockCount = BYTESTOBLKS(gDTDBFork.logicalSize, SWAP_BE32(mdbp->drAlBlkSiz));
+		gDTDBFork.physicalSize = gDTDBFork.blockCount * SWAP_BE32(mdbp->drAlBlkSiz);
 
 		sector += gDTDBFork.physicalSize / kBytesPerSector;
 
 		WriteReadMeFile(driveInfo, sector, &gReadMeFork.logicalSize);
 		gReadMeFork.startBlock = gDTDBFork.startBlock + gDTDBFork.blockCount;
-		gReadMeFork.blockCount = BYTESTOBLKS(gReadMeFork.logicalSize, mdbp->drAlBlkSiz);
-		gReadMeFork.physicalSize = gReadMeFork.blockCount * mdbp->drAlBlkSiz;
+		gReadMeFork.blockCount = BYTESTOBLKS(gReadMeFork.logicalSize, SWAP_BE32(mdbp->drAlBlkSiz));
+		gReadMeFork.physicalSize = gReadMeFork.blockCount * SWAP_BE32(mdbp->drAlBlkSiz);
 
 		sector += gReadMeFork.physicalSize / kBytesPerSector;
 
 		WriteSystemFile(driveInfo, sector, &gSystemFork.logicalSize);
 		gSystemFork.startBlock = gReadMeFork.startBlock + gReadMeFork.blockCount;
-		gSystemFork.blockCount = BYTESTOBLKS(gSystemFork.logicalSize, mdbp->drAlBlkSiz);
-		gSystemFork.physicalSize = gSystemFork.blockCount * mdbp->drAlBlkSiz;
+		gSystemFork.blockCount = BYTESTOBLKS(gSystemFork.logicalSize, SWAP_BE32(mdbp->drAlBlkSiz));
+		gSystemFork.physicalSize = gSystemFork.blockCount * SWAP_BE32(mdbp->drAlBlkSiz);
 
-		(UInt16)mdbp->drFreeBks -= gDTDBFork.blockCount +
+		SET_SWAP_BE16(mdbp->drFreeBks, SWAP_BE16(mdbp->drFreeBks) - gDTDBFork.blockCount +
 				   	gReadMeFork.blockCount +
 				   	gSystemFork.blockCount +
-					defaults->hfsWrapperFreeBlks;
-		mdbp->drEmbedExtent.startBlock = mdbp->drNmAlBlks - (UInt16)mdbp->drFreeBks;
-		mdbp->drEmbedExtent.blockCount = (UInt16)mdbp->drFreeBks;
-		(UInt16)mdbp->drFreeBks = defaults->hfsWrapperFreeBlks;
+					defaults->hfsWrapperFreeBlks);
+		SET_SWAP_BE16(mdbp->drEmbedExtent.startBlock, SWAP_BE16(mdbp->drNmAlBlks) - SWAP_BE16(mdbp->drFreeBks));
+		SET_SWAP_BE16(mdbp->drEmbedExtent.blockCount, SWAP_BE16(mdbp->drFreeBks));
+		SET_SWAP_BE16(mdbp->drFreeBks, defaults->hfsWrapperFreeBlks);
 	}
 
 
 	/*--- WRITE ALLOCATION BITMAP TO DISK:  */
 
-	WriteBitmap(driveInfo, mdbp->drVBMSt, mdbp->drNmAlBlks - (UInt16)mdbp->drFreeBks, nodeBuffer);
+	WriteBitmap(driveInfo, SWAP_BE16(mdbp->drVBMSt), SWAP_BE16(mdbp->drNmAlBlks) - SWAP_BE16(mdbp->drFreeBks), nodeBuffer);
 
 
 	/*--- WRITE FILE EXTENTS B*-TREE TO DISK:  */
 
-	sector = mdbp->drAlBlSt;	/* reset */
+	sector = SWAP_BE16(mdbp->drAlBlSt);	/* reset */
 	WriteExtentsFile(driveInfo, sector, defaults, &mdbp->drEmbedExtent, nodeBuffer, &bytesUsed, &mapNodes);
 
 	if (mapNodes > 0)
 		WriteMapNodes(driveInfo, (sector + bytesUsed/kBytesPerSector),
 			bytesUsed/kHFSNodeSize, mapNodes, kHFSNodeSize, nodeBuffer);
 
-	sector += (mdbp->drXTFlSize/kBytesPerSector);
+	sector += (SWAP_BE32(mdbp->drXTFlSize)/kBytesPerSector);
 
 
 	/*--- WRITE CATALOG B*-TREE TO DISK:  */
@@ -264,10 +266,10 @@ make_hfs(const DriveInfo *driveInfo,
 
 	/*--- WRITE MASTER DIRECTORY BLOCK TO DISK:  */
 	
-	*plusSectors = mdbp->drEmbedExtent.blockCount *
-		(mdbp->drAlBlkSiz / driveInfo->sectorSize);
-	*plusOffset = mdbp->drAlBlSt + mdbp->drEmbedExtent.startBlock *
-		(mdbp->drAlBlkSiz / driveInfo->sectorSize);
+	*plusSectors = SWAP_BE16(mdbp->drEmbedExtent.blockCount) *
+		(SWAP_BE32(mdbp->drAlBlkSiz) / driveInfo->sectorSize);
+	*plusOffset = SWAP_BE16(mdbp->drAlBlSt) + SWAP_BE16(mdbp->drEmbedExtent.startBlock) *
+		(SWAP_BE32(mdbp->drAlBlkSiz) / driveInfo->sectorSize);
 
 	/* write mdb last in case we fail along the way */
 
@@ -308,20 +310,20 @@ make_hfsplus(const DriveInfo *driveInfo,
 
 	header = (HFSPlusVolumeHeader*)malloc((size_t)kBytesPerSector);
 	if (header == NULL)
-		err(1, NULL);
+		exit(1);
 
 	/* VH Initialized in native byte order */
 	InitVH(defaults, driveInfo->totalSectors, header);
 
-	sectorsPerBlock = header->blockSize / kBytesPerSector;
+	sectorsPerBlock = SWAP_BE32(header->blockSize) / kBytesPerSector;
 
 
 	/*--- ZERO OUT BEGINNING OF DISK:  */
 
-	volumeBlocksUsed = header->totalBlocks - header->freeBlocks - 1;
-	if ( header->blockSize == 512 )
+	volumeBlocksUsed = SWAP_BE32(header->totalBlocks) - SWAP_BE32(header->freeBlocks) - 1;
+	if ( SWAP_BE32(header->blockSize) == 512 )
 		volumeBlocksUsed--;
-	bytesUsed = (header->totalBlocks - header->freeBlocks) * sectorsPerBlock;
+	bytesUsed = (SWAP_BE32(header->totalBlocks) - SWAP_BE32(header->freeBlocks)) * sectorsPerBlock;
 	ClearDisk(driveInfo, 0, bytesUsed);
 	/* also clear out last 8 sectors (4K) */
 	ClearDisk(driveInfo, driveInfo->totalSectors - 8, 8);
@@ -330,8 +332,8 @@ make_hfsplus(const DriveInfo *driveInfo,
 
 	temp = Largest( defaults->catalogNodeSize * 2,
 			defaults->extentsNodeSize,
-			header->blockSize,
-			(header->totalBlocks - header->freeBlocks) / 8 );
+			SWAP_BE32(header->blockSize),
+			(SWAP_BE32(header->totalBlocks) - SWAP_BE32(header->freeBlocks)) / 8 );
 	/* 
 	 * If size is not a mutiple of 512, round up to nearest sector
 	 */
@@ -340,39 +342,39 @@ make_hfsplus(const DriveInfo *driveInfo,
 	
 	nodeBuffer = valloc((size_t)temp);
 	if (nodeBuffer == NULL)
-		err(1, NULL);
+		exit(1);
 
 
 		
 	/*--- WRITE ALLOCATION BITMAP BITS TO DISK:  */
 
-	sector = header->allocationFile.extents[0].startBlock * sectorsPerBlock;
-	bits = header->totalBlocks - header->freeBlocks;
-	bits -= (header->blockSize == 512) ? 2 : 1;
+	sector = SWAP_BE32(header->allocationFile.extents[0].startBlock) * sectorsPerBlock;
+	bits = SWAP_BE32(header->totalBlocks) - SWAP_BE32(header->freeBlocks);
+	bits -= (SWAP_BE32(header->blockSize) == 512) ? 2 : 1;
 	WriteBitmap(driveInfo, sector, bits, nodeBuffer);
 
 	/*
 	 * Write alternate Volume Header bitmap bit to allocations file at
 	 * 2nd to last sector on HFS+ volume
 	 */
-	if (header->totalBlocks > kBitsPerSector)
+	if (SWAP_BE32(header->totalBlocks) > kBitsPerSector)
 		bzero(nodeBuffer, kBytesPerSector);
-	MarkBitInAllocationBuffer( header, header->totalBlocks - 1, nodeBuffer, &sector );
+	MarkBitInAllocationBuffer( header, SWAP_BE32(header->totalBlocks) - 1, nodeBuffer, &sector );
 
-	if ( header->blockSize == 512 ) {
+	if ( SWAP_BE32(header->blockSize) == 512 ) {
 		UInt32	sector2;
-		MarkBitInAllocationBuffer( header, header->totalBlocks - 2,
+		MarkBitInAllocationBuffer( header, SWAP_BE32(header->totalBlocks) - 2,
 			nodeBuffer, &sector2 );
 		
 		/* cover the case when altVH and last block are on different bitmap sectors. */
 		if ( sector2 != sector ) {
 			bzero(nodeBuffer, kBytesPerSector);
-			MarkBitInAllocationBuffer(header, header->totalBlocks - 1,
+			MarkBitInAllocationBuffer(header, SWAP_BE32(header->totalBlocks) - 1,
 				nodeBuffer, &sector);
 			WriteBuffer(driveInfo, sector, kBytesPerSector, nodeBuffer);
 
 			bzero(nodeBuffer, kBytesPerSector);
-			MarkBitInAllocationBuffer(header, header->totalBlocks - 2,
+			MarkBitInAllocationBuffer(header, SWAP_BE32(header->totalBlocks) - 2,
 				nodeBuffer, &sector);
 		}
 	}
@@ -384,7 +386,7 @@ make_hfsplus(const DriveInfo *driveInfo,
 	btNodeSize = defaults->extentsNodeSize;
 	sectorsPerNode = btNodeSize/kBytesPerSector;
 
-	sector = header->extentsFile.extents[0].startBlock * sectorsPerBlock;
+	sector = SWAP_BE32(header->extentsFile.extents[0].startBlock) * sectorsPerBlock;
 	WriteExtentsFile(driveInfo, sector, defaults, NULL, nodeBuffer, &bytesUsed, &mapNodes);
 
 	if (mapNodes > 0)
@@ -397,7 +399,7 @@ make_hfsplus(const DriveInfo *driveInfo,
 	btNodeSize = defaults->catalogNodeSize;
 	sectorsPerNode = btNodeSize/kBytesPerSector;
 
-	sector = header->catalogFile.extents[0].startBlock * sectorsPerBlock;
+	sector = SWAP_BE32(header->catalogFile.extents[0].startBlock) * sectorsPerBlock;
 	WriteCatalogFile(driveInfo, sector, defaults, header, nodeBuffer, &bytesUsed, &mapNodes);
 
 	if (mapNodes > 0)
@@ -406,7 +408,7 @@ make_hfsplus(const DriveInfo *driveInfo,
 
 	/*--- JOURNALING SETUP */
 	if (defaults->journaledHFS) {
-	    sector = header->journalInfoBlock * sectorsPerBlock;
+	    sector = SWAP_BE32(header->journalInfoBlock) * sectorsPerBlock;
 	    WriteJournalInfo(driveInfo, sector, defaults, header, nodeBuffer);
 	}
 
@@ -437,7 +439,7 @@ make_hfsplus(const DriveInfo *driveInfo,
 static void
 WriteMDB (const DriveInfo *driveInfo, HFS_MDB *mdbp)
 {
-	SWAP_HFSMDB (mdbp);
+	//SWAP_HFSMDB (mdbp);
 
 	WriteBuffer(driveInfo, kMDBStart, kBytesPerSector, mdbp);
 	WriteBuffer(driveInfo, driveInfo->totalSectors - 2, kBytesPerSector, mdbp);
@@ -476,29 +478,30 @@ InitMDB(hfsparams_t *defaults, UInt32 dr
 		bitmapBlocks = ((driveBlocks / (alBlkSize >> kLog2SectorSize)) +
 				kBitsPerSector-1) / kBitsPerSector;
 
-	mdbp->drAlBlSt = kVolBitMapStart + bitmapBlocks;  /* in sectors (disk blocks) */
+	SET_SWAP_BE16(mdbp->drAlBlSt, kVolBitMapStart + bitmapBlocks);  /* in sectors (disk blocks) */
 
 	/* If requested, round up block start to a multiple of "alignment" blocks */
 	if (alignment != 0)
-		mdbp->drAlBlSt = ((mdbp->drAlBlSt + alignment - 1) / alignment) * alignment;
+		SET_SWAP_BE16(mdbp->drAlBlSt, ((SWAP_BE16(mdbp->drAlBlSt) + alignment - 1) / alignment) * alignment);
 	
 	/* Now find out how many whole allocation blocks remain... */
-	numAlBlks = (driveBlocks - mdbp->drAlBlSt - kTailBlocks) /
+	numAlBlks = (driveBlocks - SWAP_BE16(mdbp->drAlBlSt) - kTailBlocks) /
 			(alBlkSize >> kLog2SectorSize);
 
 	timeStamp = UTCToLocal(defaults->createDate);
 	
-	mdbp->drSigWord = kHFSSigWord;
-	mdbp->drCrDate = timeStamp;
-	mdbp->drLsMod = timeStamp;
-	mdbp->drAtrb = kHFSVolumeUnmountedMask;
-	mdbp->drVBMSt = kVolBitMapStart;
-	mdbp->drNmAlBlks = numAlBlks;
-	mdbp->drAlBlkSiz = alBlkSize;
-	mdbp->drClpSiz = defaults->dataClumpSize;
-	mdbp->drNxtCNID = defaults->nextFreeFileID;
-	(UInt16)mdbp->drFreeBks = numAlBlks;
-	
+	SET_SWAP_BE16(mdbp->drSigWord, kHFSSigWord);
+	SET_SWAP_BE32(mdbp->drCrDate, timeStamp);
+	SET_SWAP_BE32(mdbp->drLsMod, timeStamp);
+	SET_SWAP_BE16(mdbp->drAtrb, kHFSVolumeUnmountedMask);
+	SET_SWAP_BE16(mdbp->drVBMSt, kVolBitMapStart);
+	SET_SWAP_BE16(mdbp->drNmAlBlks, numAlBlks);
+	SET_SWAP_BE32(mdbp->drAlBlkSiz, alBlkSize);
+	SET_SWAP_BE32(mdbp->drClpSiz, defaults->dataClumpSize);
+	SET_SWAP_BE32(mdbp->drNxtCNID, defaults->nextFreeFileID);
+	SET_SWAP_BE16(mdbp->drFreeBks, numAlBlks);
+
+#if __APPLE__
 	/*
 	 * Map UTF-8 input into a Mac encoding.
 	 * On conversion errors "untitled" is used as a fallback.
@@ -527,32 +530,38 @@ InitMDB(hfsparams_t *defaults, UInt32 dr
 		bcopy(&mdbp->drVN[1], defaults->volumeName, mdbp->drVN[0]);
 		defaults->volumeName[mdbp->drVN[0]] = '\0';
 	}
-	
-	mdbp->drWrCnt = kWriteSeqNum;
-
-	mdbp->drXTFlSize = mdbp->drXTClpSiz = defaults->extentsClumpSize;
-	mdbp->drXTExtRec[0].startBlock = 0;
-	mdbp->drXTExtRec[0].blockCount = mdbp->drXTFlSize / alBlkSize;
-	(UInt16)mdbp->drFreeBks -= mdbp->drXTExtRec[0].blockCount;
-
-	mdbp->drCTFlSize = mdbp->drCTClpSiz = defaults->catalogClumpSize;
-	mdbp->drCTExtRec[0].startBlock = mdbp->drXTExtRec[0].startBlock +
-					 mdbp->drXTExtRec[0].blockCount;
-	mdbp->drCTExtRec[0].blockCount = mdbp->drCTFlSize / alBlkSize;
-	(UInt16)mdbp->drFreeBks -= mdbp->drCTExtRec[0].blockCount;
+#else
+	mdbp->drVN[0] = strlen(defaults->volumeName);
+	bcopy(defaults->volumeName, &mdbp->drVN[1], mdbp->drVN[0]);
+#endif
+	
+	SET_SWAP_BE32(mdbp->drWrCnt, kWriteSeqNum);
+
+	SET_SWAP_BE32(mdbp->drXTFlSize, defaults->extentsClumpSize);
+	SET_SWAP_BE32(mdbp->drXTClpSiz, defaults->extentsClumpSize);
+	SET_SWAP_BE16(mdbp->drXTExtRec[0].startBlock, 0);
+	SET_SWAP_BE16(mdbp->drXTExtRec[0].blockCount, SWAP_BE32(mdbp->drXTFlSize) / alBlkSize);
+	SET_SWAP_BE16(mdbp->drFreeBks, SWAP_BE16(mdbp->drFreeBks) - SWAP_BE16(mdbp->drXTExtRec[0].blockCount));
+
+	SET_SWAP_BE32(mdbp->drCTFlSize, defaults->catalogClumpSize);
+	SET_SWAP_BE32(mdbp->drCTClpSiz, defaults->catalogClumpSize);
+	SET_SWAP_BE16(mdbp->drCTExtRec[0].startBlock, SWAP_BE16(mdbp->drXTExtRec[0].startBlock) +
+					 SWAP_BE16(mdbp->drXTExtRec[0].blockCount));
+	SET_SWAP_BE16(mdbp->drCTExtRec[0].blockCount, SWAP_BE32(mdbp->drCTFlSize) / alBlkSize);
+	SET_SWAP_BE16(mdbp->drFreeBks, SWAP_BE16(mdbp->drFreeBks) - SWAP_BE16(mdbp->drCTExtRec[0].blockCount));
 
 	if (defaults->flags & kMakeHFSWrapper) {
-		mdbp->drFilCnt = mdbp->drNmFls = kWapperFileCount;
-		mdbp->drNxtCNID += kWapperFileCount;
+		SET_SWAP_BE32(mdbp->drFilCnt, kWapperFileCount);
+		SET_SWAP_BE16(mdbp->drNmFls, kWapperFileCount);
+		SET_SWAP_BE32(mdbp->drNxtCNID, SWAP_BE32(mdbp->drNxtCNID) + kWapperFileCount);
 
 		/* set blessed system folder to be root folder (2) */
-		mdbp->drFndrInfo[0] = kHFSRootFolderID;
+		SET_SWAP_BE32(mdbp->drFndrInfo[0] ,kHFSRootFolderID);
 
-		mdbp->drEmbedSigWord = kHFSPlusSigWord;
+		SET_SWAP_BE16(mdbp->drEmbedSigWord, kHFSPlusSigWord);
 
 		/* software lock it and tag as having "bad" blocks */
-		mdbp->drAtrb |= kHFSVolumeSparedBlocksMask;
-		mdbp->drAtrb |= kHFSVolumeSoftwareLockMask;
+		SET_SWAP_BE16(mdbp->drAtrb, SWAP_BE16(mdbp->drAtrb) | kHFSVolumeSparedBlocksMask | kHFSVolumeSoftwareLockMask);
 	}
 }
 
@@ -568,7 +577,7 @@ InitMDB(hfsparams_t *defaults, UInt32 dr
 static void
 WriteVH (const DriveInfo *driveInfo, HFSPlusVolumeHeader *hp)
 {
-	SWAP_HFSPLUSVH (hp);
+	//SWAP_HFSPLUSVH (hp);
 
 	WriteBuffer(driveInfo, 2, kBytesPerSector, hp);
 	WriteBuffer(driveInfo, driveInfo->totalSectors - 2, kBytesPerSector, hp);
@@ -612,83 +621,83 @@ InitVH(hfsparams_t *defaults, UInt64 sec
 	/* note: add 2 for the Alternate VH, and VH */
 	blocksUsed = 2 + burnedBlocksBeforeVH + burnedBlocksAfterAltVH + bitmapBlocks;
 
-	hp->signature = kHFSPlusSigWord;
-	hp->version = kHFSPlusVersion;
-	hp->attributes = kHFSVolumeUnmountedMask;
-	hp->lastMountedVersion = kHFSPlusMountVersion;
+	SET_SWAP_BE16(hp->signature, kHFSPlusSigWord);
+	SET_SWAP_BE16(hp->version, kHFSPlusVersion);
+	SET_SWAP_BE32(hp->attributes, kHFSVolumeUnmountedMask);
+	SET_SWAP_BE32(hp->lastMountedVersion, kHFSPlusMountVersion);
 
 	/* NOTE: create date is in local time, not GMT!  */
-	hp->createDate = UTCToLocal(defaults->createDate);
-	hp->modifyDate = defaults->createDate;
-	hp->backupDate = 0;
-	hp->checkedDate = defaults->createDate;
+	SET_SWAP_BE32(hp->createDate, UTCToLocal(defaults->createDate));
+	SET_SWAP_BE32(hp->modifyDate, defaults->createDate);
+	SET_SWAP_BE32(hp->backupDate, 0);
+	SET_SWAP_BE32(hp->checkedDate, defaults->createDate);
 
 //	hp->fileCount = 0;
 //	hp->folderCount = 0;
 
-	hp->blockSize = blockSize;
-	hp->totalBlocks = blockCount;
-	hp->freeBlocks = blockCount;	/* will be adjusted at the end */
-
-	hp->rsrcClumpSize = defaults->rsrcClumpSize;
-	hp->dataClumpSize = defaults->dataClumpSize;
-	hp->nextCatalogID = defaults->nextFreeFileID;
-	hp->encodingsBitmap = 1;	/* just set to MacRoman */
+	SET_SWAP_BE32(hp->blockSize, blockSize);
+	SET_SWAP_BE32(hp->totalBlocks, blockCount);
+	SET_SWAP_BE32(hp->freeBlocks, blockCount);	/* will be adjusted at the end */
+
+	SET_SWAP_BE32(hp->rsrcClumpSize, defaults->rsrcClumpSize);
+	SET_SWAP_BE32(hp->dataClumpSize, defaults->dataClumpSize);
+	SET_SWAP_BE32(hp->nextCatalogID, defaults->nextFreeFileID);
+	SET_SWAP_BE64(hp->encodingsBitmap, 1);	/* just set to MacRoman */
 
 	/* set up allocation bitmap file */
-	hp->allocationFile.clumpSize = defaults->allocationClumpSize;
-	hp->allocationFile.logicalSize = defaults->allocationClumpSize;
-	hp->allocationFile.totalBlocks = bitmapBlocks;
-  	hp->allocationFile.extents[0].startBlock = 1 + burnedBlocksBeforeVH;
-	hp->allocationFile.extents[0].blockCount = bitmapBlocks;
+	SET_SWAP_BE32(hp->allocationFile.clumpSize, defaults->allocationClumpSize);
+	SET_SWAP_BE64(hp->allocationFile.logicalSize, defaults->allocationClumpSize);
+	SET_SWAP_BE32(hp->allocationFile.totalBlocks, bitmapBlocks);
+  	SET_SWAP_BE32(hp->allocationFile.extents[0].startBlock, 1 + burnedBlocksBeforeVH);
+	SET_SWAP_BE32(hp->allocationFile.extents[0].blockCount, bitmapBlocks);
 	
 	/* set up journal files */
 	if (defaults->journaledHFS) {
-		hp->fileCount           = 2;
-		hp->attributes         |= kHFSVolumeJournaledMask;
-		hp->lastMountedVersion  = kHFSJMountVersion;
-		hp->nextCatalogID      += 2;
+		SET_SWAP_BE32(hp->fileCount, 2);
+		SET_SWAP_BE32(hp->attributes, SWAP_BE32(hp->attributes) | kHFSVolumeJournaledMask);
+		SET_SWAP_BE32(hp->lastMountedVersion, kHFSJMountVersion);
+		SET_SWAP_BE32(hp->nextCatalogID, SWAP_BE32(hp->nextCatalogID) + 2);
 
 		/*
 		 * Allocate 1 block for the journalInfoBlock the
 		 * journal file size is pass in hfsparams_t
 		 */
-	    hp->journalInfoBlock = hp->allocationFile.extents[0].startBlock +
-				   hp->allocationFile.extents[0].blockCount;
+	    SET_SWAP_BE32(hp->journalInfoBlock, SWAP_BE32(hp->allocationFile.extents[0].startBlock) +
+				   SWAP_BE32(hp->allocationFile.extents[0].blockCount));
 	    blocksUsed += 1 + ((defaults->journalSize) / blockSize);
-	    nextBlock = hp->journalInfoBlock + 1 + (defaults->journalSize / blockSize);
+	    nextBlock = SWAP_BE32(hp->journalInfoBlock) + 1 + (defaults->journalSize / blockSize);
 	} else {
-	    hp->journalInfoBlock = 0;
-	    nextBlock = hp->allocationFile.extents[0].startBlock +
-			hp->allocationFile.extents[0].blockCount;
+	    SET_SWAP_BE32(hp->journalInfoBlock, 0);
+	    nextBlock = SWAP_BE32(hp->allocationFile.extents[0].startBlock) +
+			SWAP_BE32(hp->allocationFile.extents[0].blockCount);
 	}
 
 	/* set up extents b-tree file */
-	hp->extentsFile.clumpSize = defaults->extentsClumpSize;
-	hp->extentsFile.logicalSize = defaults->extentsClumpSize;
-	hp->extentsFile.totalBlocks = defaults->extentsClumpSize / blockSize;
-	hp->extentsFile.extents[0].startBlock = nextBlock;
-	hp->extentsFile.extents[0].blockCount = hp->extentsFile.totalBlocks;
-	blocksUsed += hp->extentsFile.totalBlocks;
+	SET_SWAP_BE32(hp->extentsFile.clumpSize, defaults->extentsClumpSize);
+	SET_SWAP_BE64(hp->extentsFile.logicalSize, defaults->extentsClumpSize);
+	SET_SWAP_BE32(hp->extentsFile.totalBlocks, defaults->extentsClumpSize / blockSize);
+	SET_SWAP_BE32(hp->extentsFile.extents[0].startBlock, nextBlock);
+	SET_SWAP_BE32(hp->extentsFile.extents[0].blockCount, SWAP_BE32(hp->extentsFile.totalBlocks));
+	blocksUsed += SWAP_BE32(hp->extentsFile.totalBlocks);
 
 
 	/* set up catalog b-tree file */
-	hp->catalogFile.clumpSize = defaults->catalogClumpSize;
-	hp->catalogFile.logicalSize = defaults->catalogClumpSize;
-	hp->catalogFile.totalBlocks = defaults->catalogClumpSize / blockSize;
-	hp->catalogFile.extents[0].startBlock =
-		hp->extentsFile.extents[0].startBlock +
-		hp->extentsFile.extents[0].blockCount;
-	hp->catalogFile.extents[0].blockCount = hp->catalogFile.totalBlocks;
-	blocksUsed += hp->catalogFile.totalBlocks;
+	SET_SWAP_BE32(hp->catalogFile.clumpSize, defaults->catalogClumpSize);
+	SET_SWAP_BE64(hp->catalogFile.logicalSize, defaults->catalogClumpSize);
+	SET_SWAP_BE32(hp->catalogFile.totalBlocks, defaults->catalogClumpSize / blockSize);
+	SET_SWAP_BE32(hp->catalogFile.extents[0].startBlock,
+		SWAP_BE32(hp->extentsFile.extents[0].startBlock) +
+		SWAP_BE32(hp->extentsFile.extents[0].blockCount));
+	SET_SWAP_BE32(hp->catalogFile.extents[0].blockCount, SWAP_BE32(hp->catalogFile.totalBlocks));
+	blocksUsed += SWAP_BE32(hp->catalogFile.totalBlocks);
 
-	hp->freeBlocks -= blocksUsed;
+	SET_SWAP_BE32(hp->freeBlocks, SWAP_BE32(hp->freeBlocks) - blocksUsed);
 	
 	/*
 	 * Add some room for the catalog file to grow...
 	 */
-	hp->nextAllocation = blocksUsed - 1 - burnedBlocksAfterAltVH +
-		10 * (hp->catalogFile.clumpSize / hp->blockSize);
+	SET_SWAP_BE32(hp->nextAllocation, blocksUsed - 1 - burnedBlocksAfterAltVH +
+		10 * (SWAP_BE32(hp->catalogFile.clumpSize) / SWAP_BE32(hp->blockSize)));
 }
 
 
@@ -760,7 +769,7 @@ WriteExtentsFile(const DriveInfo *driveI
 	/* FILL IN THE NODE DESCRIPTOR:  */
 	ndp = (BTNodeDescriptor *)buffer;
 	ndp->kind			= kBTHeaderNode;
-	ndp->numRecords		= SWAP_BE16 (3);
+	SET_SWAP_BE16(ndp->numRecords, 3);
 	offset = sizeof(BTNodeDescriptor);
 
 	SETOFFSET(buffer, nodeSize, offset, 1);
@@ -773,25 +782,25 @@ WriteExtentsFile(const DriveInfo *driveI
     //	bthp->firstLeafNode	= 0;
     //	bthp->lastLeafNode	= 0;
     //	bthp->leafRecords	= 0;
-	bthp->nodeSize		= SWAP_BE16 (nodeSize);
-	bthp->totalNodes	= SWAP_BE32 (fileSize / nodeSize);
-	bthp->freeNodes		= SWAP_BE32 (SWAP_BE32 (bthp->totalNodes) - 1);  /* header */
-	bthp->clumpSize		= SWAP_BE32 (fileSize);
+	SET_SWAP_BE16(bthp->nodeSize, nodeSize);
+	SET_SWAP_BE32(bthp->totalNodes, fileSize / nodeSize);
+	SET_SWAP_BE32(bthp->freeNodes, SWAP_BE32(bthp->totalNodes) - 1);  /* header */
+	SET_SWAP_BE32(bthp->clumpSize, fileSize);
 
 	if (dp->signature == kHFSPlusSigWord) {
-		bthp->attributes	|= SWAP_BE32 (kBTBigKeysMask);
-		bthp->maxKeyLength	=  SWAP_BE16 (kHFSPlusExtentKeyMaximumLength);
+		SET_SWAP_BE32(bthp->attributes, SWAP_BE32(bthp->attributes) | kBTBigKeysMask);
+		SET_SWAP_BE16(bthp->maxKeyLength, kHFSPlusExtentKeyMaximumLength);
 	} else {
-		bthp->maxKeyLength	= SWAP_BE16 (kHFSExtentKeyMaximumLength);
+		SET_SWAP_BE16(bthp->maxKeyLength, kHFSExtentKeyMaximumLength);
 
 		/* wrapper has a bad-block extent record */
 		if (wrapper) {
-			bthp->treeDepth		= SWAP_BE16 (SWAP_BE16 (bthp->treeDepth) + 1);
-			bthp->leafRecords	= SWAP_BE32 (SWAP_BE32 (bthp->leafRecords) + 1);
-			bthp->rootNode		= SWAP_BE32 (1);
-			bthp->firstLeafNode	= SWAP_BE32 (1);
-			bthp->lastLeafNode	= SWAP_BE32 (1);
-			bthp->freeNodes		= SWAP_BE32 (SWAP_BE32 (bthp->freeNodes) - 1);
+			SET_SWAP_BE16(bthp->treeDepth, SWAP_BE16(bthp->treeDepth) + 1);
+			SET_SWAP_BE32(bthp->leafRecords, SWAP_BE32(bthp->leafRecords) + 1);
+			SET_SWAP_BE32(bthp->rootNode, 1);
+			SET_SWAP_BE32(bthp->firstLeafNode, 1);
+			SET_SWAP_BE32(bthp->lastLeafNode, 1);
+			SET_SWAP_BE32(bthp->freeNodes, SWAP_BE32(bthp->freeNodes) - 1);
 		}
 	}
 	offset += sizeof(BTHeaderRec);
@@ -813,14 +822,14 @@ WriteExtentsFile(const DriveInfo *driveI
 	if (SWAP_BE32 (bthp->totalNodes) > nodeBitsInHeader) {
 		UInt32	nodeBitsInMapNode;
 		
-		ndp->fLink		= SWAP_BE32 (SWAP_BE32 (bthp->lastLeafNode) + 1);
+		SET_SWAP_BE32(ndp->fLink, SWAP_BE32 (bthp->lastLeafNode) + 1);
 		nodeBitsInMapNode = 8 * (nodeSize
 						- sizeof(BTNodeDescriptor)
 						- (2 * sizeof(SInt16))
 						- 2 );
 		*mapNodes = (SWAP_BE32 (bthp->totalNodes) - nodeBitsInHeader +
 			(nodeBitsInMapNode - 1)) / nodeBitsInMapNode;
-		bthp->freeNodes = SWAP_BE32 (SWAP_BE32 (bthp->freeNodes) - *mapNodes);
+		SET_SWAP_BE32(bthp->freeNodes, SWAP_BE32 (bthp->freeNodes) - *mapNodes);
 	}
 
 
@@ -863,7 +872,7 @@ InitExtentsRoot(UInt16 btNodeSize, HFSEx
 	 */
 	ndp = (BTNodeDescriptor *)buffer;
 	ndp->kind			= kBTLeafNode;
-	ndp->numRecords		= SWAP_BE16 (1);
+	SET_SWAP_BE16(ndp->numRecords, 1);
 	ndp->height			= 1;
 	offset = sizeof(BTNodeDescriptor);
 
@@ -875,13 +884,13 @@ InitExtentsRoot(UInt16 btNodeSize, HFSEx
 	ekp = (HFSExtentKey *)((UInt8 *) buffer + offset);
 	ekp->keyLength		= kHFSExtentKeyMaximumLength;
 	// ekp->forkType	= 0;
-	ekp->fileID			= SWAP_BE32 (kHFSBadBlockFileID);
+	SET_SWAP_BE32(ekp->fileID, kHFSBadBlockFileID);
 	// ekp->startBlock	= 0;
 	offset += sizeof(HFSExtentKey);
 
 	edp = (HFSExtentRecord *)((UInt8 *)buffer + offset);
-	edp[0]->startBlock	= SWAP_BE16 (bbextp->startBlock);
-	edp[0]->blockCount	= SWAP_BE16 (bbextp->blockCount);
+	SET_SWAP_BE16(edp[0]->startBlock, SWAP_BE16(bbextp->startBlock));
+	SET_SWAP_BE16(edp[0]->blockCount, SWAP_BE16(bbextp->blockCount));
 	offset += sizeof(HFSExtentRecord);
 
 	SETOFFSET(buffer, btNodeSize, offset, 2);
@@ -894,23 +903,14 @@ WriteJournalInfo(const DriveInfo *driveI
 {
     JournalInfoBlock *jibp = buffer;
     
-    memset(buffer, 0xdb, header->blockSize);
+    memset(buffer, 0xdb, SWAP_BE32(header->blockSize));
     memset(jibp, 0, sizeof(JournalInfoBlock));
     
-    jibp->flags   = kJIJournalInFSMask;
-    jibp->flags  |= kJIJournalNeedInitMask;
-    jibp->offset  = (header->journalInfoBlock + 1) * header->blockSize;
-    jibp->size    = dp->journalSize;
-
-    jibp->flags  = SWAP_BE32(jibp->flags);
-    jibp->offset = SWAP_BE32(jibp->offset);
-    jibp->size   = SWAP_BE32(jibp->size);
-    
-    WriteBuffer(driveInfo, startingSector, header->blockSize, buffer);
+    SET_SWAP_BE32(jibp->flags, kJIJournalInFSMask | kJIJournalNeedInitMask);
+    SET_SWAP_BE64(jibp->offset, (SWAP_BE32(header->journalInfoBlock) + 1) * SWAP_BE32(header->blockSize));
+    SET_SWAP_BE64(jibp->size, dp->journalSize);
 
-    jibp->flags  = SWAP_BE32(jibp->flags);
-    jibp->offset = SWAP_BE32(jibp->offset);
-    jibp->size   = SWAP_BE32(jibp->size);
+    WriteBuffer(driveInfo, startingSector, SWAP_BE32(header->blockSize), buffer);
 }
 
 
@@ -947,7 +947,7 @@ WriteCatalogFile(const DriveInfo *driveI
 	/* FILL IN THE NODE DESCRIPTOR:  */
 	ndp = (BTNodeDescriptor *)buffer;
 	ndp->kind			= kBTHeaderNode;
-	ndp->numRecords		= SWAP_BE16 (3);
+	SET_SWAP_BE16(ndp->numRecords, 3);
 	offset = sizeof(BTNodeDescriptor);
 
 	SETOFFSET(buffer, nodeSize, offset, 1);
@@ -955,28 +955,28 @@ WriteCatalogFile(const DriveInfo *driveI
 
 	/* FILL IN THE HEADER RECORD:  */
 	bthp = (BTHeaderRec *)((UInt8 *)buffer + offset);
-	bthp->treeDepth		= SWAP_BE16 (1);
-	bthp->rootNode		= SWAP_BE32 (1);
-	bthp->firstLeafNode	= SWAP_BE32 (1);
-	bthp->lastLeafNode	= SWAP_BE32 (1);
-	bthp->leafRecords	= SWAP_BE32 (dp->journaledHFS ? 6 : 2);
-	bthp->nodeSize		= SWAP_BE16 (nodeSize);
-	bthp->totalNodes	= SWAP_BE32 (fileSize / nodeSize);
-	bthp->freeNodes		= SWAP_BE32 (SWAP_BE32 (bthp->totalNodes) - 2);  /* header and root */
-	bthp->clumpSize		= SWAP_BE32 (fileSize);
+	SET_SWAP_BE16(bthp->treeDepth, 1);
+	SET_SWAP_BE32(bthp->rootNode, 1);
+	SET_SWAP_BE32(bthp->firstLeafNode, 1);
+	SET_SWAP_BE32(bthp->lastLeafNode, 1);
+	SET_SWAP_BE32(bthp->leafRecords, dp->journaledHFS ? 6 : 2);
+	SET_SWAP_BE16(bthp->nodeSize, nodeSize);
+	SET_SWAP_BE32(bthp->totalNodes, fileSize / nodeSize);
+	SET_SWAP_BE32(bthp->freeNodes, SWAP_BE32 (bthp->totalNodes) - 2);  /* header and root */
+	SET_SWAP_BE32(bthp->clumpSize, fileSize);
 
 	if (dp->signature == kHFSPlusSigWord) {
-		bthp->attributes	|= SWAP_BE32 (kBTVariableIndexKeysMask + kBTBigKeysMask);
-		bthp->maxKeyLength	=  SWAP_BE16 (kHFSPlusCatalogKeyMaximumLength);
+		SET_SWAP_BE32(bthp->attributes, SWAP_BE32(bthp->attributes) | kBTVariableIndexKeysMask | kBTBigKeysMask);
+		SET_SWAP_BE16(bthp->maxKeyLength, kHFSPlusCatalogKeyMaximumLength);
 	} else {
-		bthp->maxKeyLength	=  SWAP_BE16 (kHFSCatalogKeyMaximumLength);
+		SET_SWAP_BE16(bthp->maxKeyLength, kHFSCatalogKeyMaximumLength);
 
 		if (dp->flags & kMakeHFSWrapper) {
-			bthp->treeDepth		= SWAP_BE16 (SWAP_BE16 (bthp->treeDepth) + 1);
-			bthp->leafRecords	= SWAP_BE32 (SWAP_BE32 (bthp->leafRecords) + kWapperFileCount);
-			bthp->firstLeafNode	= SWAP_BE32 (SWAP_BE32 (bthp->rootNode) + 1);
-			bthp->lastLeafNode	= SWAP_BE32 (SWAP_BE32 (bthp->firstLeafNode) + 1);
-			bthp->freeNodes		= SWAP_BE32 (SWAP_BE32 (bthp->freeNodes) - 2);  /* tree now split with 2 leaf nodes */
+			SET_SWAP_BE16(bthp->treeDepth, SWAP_BE16 (bthp->treeDepth) + 1);
+			SET_SWAP_BE32(bthp->leafRecords, SWAP_BE32 (bthp->leafRecords) + kWapperFileCount);
+			SET_SWAP_BE32(bthp->firstLeafNode, SWAP_BE32 (bthp->rootNode) + 1);
+			SET_SWAP_BE32(bthp->lastLeafNode, SWAP_BE32 (bthp->firstLeafNode) + 1);
+			SET_SWAP_BE32(bthp->freeNodes, SWAP_BE32 (bthp->freeNodes) - 2);  /* tree now split with 2 leaf nodes */
 		}
 	}
 	offset += sizeof(BTHeaderRec);
@@ -997,14 +997,14 @@ WriteCatalogFile(const DriveInfo *driveI
 	if (SWAP_BE32 (bthp->totalNodes) > nodeBitsInHeader) {
 		UInt32	nodeBitsInMapNode;
 		
-		ndp->fLink = SWAP_BE32 (SWAP_BE32 (bthp->lastLeafNode) + 1);
+		SET_SWAP_BE32(ndp->fLink, SWAP_BE32 (bthp->lastLeafNode) + 1);
 		nodeBitsInMapNode = 8 * (nodeSize
 						- sizeof(BTNodeDescriptor)
 						- (2 * sizeof(SInt16))
 						- 2 );
 		*mapNodes = (SWAP_BE32 (bthp->totalNodes) - nodeBitsInHeader +
 			(nodeBitsInMapNode - 1)) / nodeBitsInMapNode;
-		bthp->freeNodes = SWAP_BE32 (SWAP_BE32 (bthp->freeNodes) - *mapNodes);
+		SET_SWAP_BE32(bthp->freeNodes, SWAP_BE32 (bthp->freeNodes) - *mapNodes);
 	}
 
 	/* 
@@ -1051,9 +1051,11 @@ InitCatalogRoot_HFSPlus(const hfsparams_
 	UInt16					nodeSize;
 	SInt16					offset;
 	UInt32					unicodeBytes;
+#if __APPLE__
 	UInt8 canonicalName[256];
 	CFStringRef cfstr;
 	Boolean	cfOK;
+#endif
 	int index = 0;
 
 	nodeSize = dp->catalogNodeSize;
@@ -1065,7 +1067,7 @@ InitCatalogRoot_HFSPlus(const hfsparams_
 	ndp = (BTNodeDescriptor *)buffer;
 	ndp->kind   = kBTLeafNode;
 	ndp->height = 1;
-	ndp->numRecords = SWAP_BE16 (dp->journaledHFS ? 6 : 2);
+	SET_SWAP_BE16(ndp->numRecords, dp->journaledHFS ? 6 : 2);
 	offset = sizeof(BTNodeDescriptor);
 
 	SETOFFSET(buffer, nodeSize, offset, ++index);
@@ -1074,7 +1076,8 @@ InitCatalogRoot_HFSPlus(const hfsparams_
 	 * First record is always the root directory...
 	 */
 	ckp = (HFSPlusCatalogKey *)((UInt8 *)buffer + offset);
-	
+
+#if __APPLE__
 	/* Use CFString functions to get a HFSPlus Canonical name */
 	cfstr = CFStringCreateWithCString(kCFAllocatorDefault, dp->volumeName, kCFStringEncodingUTF8);
 	cfOK = _CFStringGetFileSystemRepresentation(cfstr, canonicalName, sizeof(canonicalName));
@@ -1091,21 +1094,24 @@ InitCatalogRoot_HFSPlus(const hfsparams_
 		      dp->volumeName, kDefaultVolumeNameStr);
 	}
 	CFRelease(cfstr);
-	ckp->nodeName.length = SWAP_BE16 (ckp->nodeName.length);
+#else
+	ConvertUTF8toUnicode(dp->volumeName, sizeof(ckp->nodeName.unicode),
+					ckp->nodeName.unicode, &ckp->nodeName.length);
+#endif
 
 	unicodeBytes = sizeof(UniChar) * SWAP_BE16 (ckp->nodeName.length);
 
-	ckp->keyLength		= SWAP_BE16 (kHFSPlusCatalogKeyMinimumLength + unicodeBytes);
-	ckp->parentID		= SWAP_BE32 (kHFSRootParentID);
+	SET_SWAP_BE16(ckp->keyLength, kHFSPlusCatalogKeyMinimumLength + unicodeBytes);
+	SET_SWAP_BE32(ckp->parentID, kHFSRootParentID);
 	offset += SWAP_BE16 (ckp->keyLength) + 2;
 
 	cdp = (HFSPlusCatalogFolder *)((UInt8 *)buffer + offset);
-	cdp->recordType		= SWAP_BE16 (kHFSPlusFolderRecord);
-	cdp->valence        = SWAP_BE32 (dp->journaledHFS ? 2 : 0);
-	cdp->folderID		= SWAP_BE32 (kHFSRootFolderID);
-	cdp->createDate		= SWAP_BE32 (dp->createDate);
-	cdp->contentModDate	= SWAP_BE32 (dp->createDate);
-	cdp->textEncoding	= SWAP_BE32 (GetDefaultEncoding());
+	SET_SWAP_BE16(cdp->recordType, kHFSPlusFolderRecord);
+	SET_SWAP_BE32(cdp->valence, dp->journaledHFS ? 2 : 0);
+	SET_SWAP_BE32(cdp->folderID, kHFSRootFolderID);
+	SET_SWAP_BE32(cdp->createDate, dp->createDate);
+	SET_SWAP_BE32(cdp->contentModDate, dp->createDate);
+	SET_SWAP_BE32(cdp->textEncoding, GetDefaultEncoding());
 	offset += sizeof(HFSPlusCatalogFolder);
 
 	SETOFFSET(buffer, nodeSize, offset, ++index);
@@ -1114,15 +1120,15 @@ InitCatalogRoot_HFSPlus(const hfsparams_
 	 * Second record is always the root directory thread...
 	 */
 	tkp = (HFSPlusCatalogKey *)((UInt8 *)buffer + offset);
-	tkp->keyLength		= SWAP_BE16 (kHFSPlusCatalogKeyMinimumLength);
-	tkp->parentID		= SWAP_BE32 (kHFSRootFolderID);
+	SET_SWAP_BE16(tkp->keyLength, kHFSPlusCatalogKeyMinimumLength);
+	SET_SWAP_BE32(tkp->parentID, kHFSRootFolderID);
 	// tkp->nodeName.length = 0;
 
 	offset += SWAP_BE16 (tkp->keyLength) + 2;
 
 	ctp = (HFSPlusCatalogThread *)((UInt8 *)buffer + offset);
-	ctp->recordType		= SWAP_BE16 (kHFSPlusFolderThreadRecord);
-	ctp->parentID		= SWAP_BE32 (kHFSRootParentID);
+	SET_SWAP_BE16(ctp->recordType, kHFSPlusFolderThreadRecord);
+	SET_SWAP_BE32(ctp->parentID, kHFSRootParentID);
 	bcopy(&ckp->nodeName, &ctp->nodeName, sizeof(UInt16) + unicodeBytes);
 	offset += (sizeof(HFSPlusCatalogThread)
 			- (sizeof(ctp->nodeName.unicode) - unicodeBytes) );
@@ -1139,28 +1145,27 @@ InitCatalogRoot_HFSPlus(const hfsparams_
 		ckp = (HFSPlusCatalogKey *)((UInt8 *)buffer + offset);
 		(void) ConvertUTF8toUnicode(HFS_JOURNAL_FILE, sizeof(ckp->nodeName.unicode),
 		                            ckp->nodeName.unicode, &ckp->nodeName.length);
-		ckp->nodeName.length = SWAP_BE16 (ckp->nodeName.length);
 		unicodeBytes = sizeof(UniChar) * SWAP_BE16 (ckp->nodeName.length);
-		ckp->keyLength = SWAP_BE16 (kHFSPlusCatalogKeyMinimumLength + unicodeBytes);
-		ckp->parentID  = SWAP_BE32 (kHFSRootFolderID);
+		SET_SWAP_BE16(ckp->keyLength, kHFSPlusCatalogKeyMinimumLength + unicodeBytes);
+		SET_SWAP_BE32(ckp->parentID, kHFSRootFolderID);
 		offset += SWAP_BE16 (ckp->keyLength) + 2;
 	
 		cfp = (HFSPlusCatalogFile *)((UInt8 *)buffer + offset);
-		cfp->recordType     = SWAP_BE16 (kHFSPlusFileRecord);
-		cfp->fileID         = SWAP_BE32 (dp->nextFreeFileID);
-		cfp->createDate     = SWAP_BE32 (dp->createDate + 1);
-		cfp->contentModDate = SWAP_BE32 (dp->createDate + 1);
-		cfp->textEncoding   = 0;
-
-		cfp->bsdInfo.fileMode     = SWAP_BE16 (S_IFREG);
-		cfp->bsdInfo.ownerFlags   = SWAP_BE16 (UF_NODUMP);
-		cfp->userInfo.fdType	  = SWAP_BE32 (kJournalFileType);
-		cfp->userInfo.fdCreator	  = SWAP_BE32 (kHFSPlusCreator);
-		cfp->userInfo.fdFlags     = SWAP_BE16 (kIsInvisible + kNameLocked);
-		cfp->dataFork.logicalSize = SWAP_BE64 (dp->journalSize);
-		cfp->dataFork.totalBlocks = SWAP_BE32 (dp->journalSize / dp->blockSize);
+		SET_SWAP_BE16(cfp->recordType, kHFSPlusFileRecord);
+		SET_SWAP_BE32(cfp->fileID, dp->nextFreeFileID);
+		SET_SWAP_BE32(cfp->createDate, dp->createDate + 1);
+		SET_SWAP_BE32(cfp->contentModDate, dp->createDate + 1);
+		SET_SWAP_BE32(cfp->textEncoding, 0);
+
+		SET_SWAP_BE16(cfp->bsdInfo.fileMode, S_IFREG);
+		cfp->bsdInfo.ownerFlags = UF_NODUMP;
+		SET_SWAP_BE32(cfp->userInfo.fdType, kJournalFileType);
+		SET_SWAP_BE32(cfp->userInfo.fdCreator, kHFSPlusCreator);
+		SET_SWAP_BE16(cfp->userInfo.fdFlags, kIsInvisible + kNameLocked);
+		SET_SWAP_BE64(cfp->dataFork.logicalSize, dp->journalSize);
+		SET_SWAP_BE32(cfp->dataFork.totalBlocks, dp->journalSize / dp->blockSize);
 
-		cfp->dataFork.extents[0].startBlock = SWAP_BE32 (header->journalInfoBlock + 1);
+		SET_SWAP_BE32(cfp->dataFork.extents[0].startBlock, SWAP_BE32(header->journalInfoBlock) + 1);
 		cfp->dataFork.extents[0].blockCount = cfp->dataFork.totalBlocks;
 
 		offset += sizeof(HFSPlusCatalogFile);
@@ -1171,28 +1176,27 @@ InitCatalogRoot_HFSPlus(const hfsparams_
 		ckp = (HFSPlusCatalogKey *)((UInt8 *)buffer + offset);
 		(void) ConvertUTF8toUnicode(HFS_JOURNAL_INFO, sizeof(ckp->nodeName.unicode),
 		                            ckp->nodeName.unicode, &ckp->nodeName.length);
-		ckp->nodeName.length = SWAP_BE16 (ckp->nodeName.length);
 		unicodeBytes = sizeof(UniChar) * SWAP_BE16 (ckp->nodeName.length);
-		ckp->keyLength = SWAP_BE16 (kHFSPlusCatalogKeyMinimumLength + unicodeBytes);
-		ckp->parentID  = SWAP_BE32 (kHFSRootFolderID);
+		SET_SWAP_BE16(ckp->keyLength, kHFSPlusCatalogKeyMinimumLength + unicodeBytes);
+		SET_SWAP_BE32(ckp->parentID, kHFSRootFolderID);
 		offset += SWAP_BE16 (ckp->keyLength) + 2;
 	
 		cfp = (HFSPlusCatalogFile *)((UInt8 *)buffer + offset);
-		cfp->recordType     = SWAP_BE16 (kHFSPlusFileRecord);
-		cfp->fileID         = SWAP_BE32 (dp->nextFreeFileID + 1);
-		cfp->createDate     = SWAP_BE32 (dp->createDate);
-		cfp->contentModDate = SWAP_BE32 (dp->createDate);
-		cfp->textEncoding   = 0;
-
-		cfp->bsdInfo.fileMode     = SWAP_BE16 (S_IFREG);
-		cfp->bsdInfo.ownerFlags   = SWAP_BE16 (UF_NODUMP);
-		cfp->userInfo.fdType	  = SWAP_BE32 (kJournalFileType);
-		cfp->userInfo.fdCreator	  = SWAP_BE32 (kHFSPlusCreator);
-		cfp->userInfo.fdFlags     = SWAP_BE16 (kIsInvisible + kNameLocked);
-		cfp->dataFork.logicalSize = SWAP_BE64(dp->blockSize);;
-		cfp->dataFork.totalBlocks = 1;
+		SET_SWAP_BE16(cfp->recordType, kHFSPlusFileRecord);
+		SET_SWAP_BE32(cfp->fileID, dp->nextFreeFileID + 1);
+		SET_SWAP_BE32(cfp->createDate, dp->createDate);
+		SET_SWAP_BE32(cfp->contentModDate, dp->createDate);
+		SET_SWAP_BE32(cfp->textEncoding, 0);
+
+		SET_SWAP_BE16(cfp->bsdInfo.fileMode, S_IFREG);
+		cfp->bsdInfo.ownerFlags = UF_NODUMP;
+		SET_SWAP_BE32(cfp->userInfo.fdType, kJournalFileType);
+		SET_SWAP_BE32(cfp->userInfo.fdCreator, kHFSPlusCreator);
+		SET_SWAP_BE16(cfp->userInfo.fdFlags, kIsInvisible + kNameLocked);
+		SET_SWAP_BE64(cfp->dataFork.logicalSize, dp->blockSize);
+		SET_SWAP_BE32(cfp->dataFork.totalBlocks, 1);
 
-		cfp->dataFork.extents[0].startBlock = SWAP_BE32 (header->journalInfoBlock);
+		cfp->dataFork.extents[0].startBlock = header->journalInfoBlock;
 		cfp->dataFork.extents[0].blockCount = cfp->dataFork.totalBlocks;
 
 		offset += sizeof(HFSPlusCatalogFile);
@@ -1201,14 +1205,14 @@ InitCatalogRoot_HFSPlus(const hfsparams_
 
 		/* Thread record for file #1 */
 		tkp = (HFSPlusCatalogKey *)((UInt8 *)buffer + offset);
-		tkp->keyLength = SWAP_BE16 (kHFSPlusCatalogKeyMinimumLength);
-		tkp->parentID  = SWAP_BE32 (dp->nextFreeFileID);
-		tkp->nodeName.length = 0;
+		SET_SWAP_BE16(tkp->keyLength, kHFSPlusCatalogKeyMinimumLength);
+		SET_SWAP_BE32(tkp->parentID, dp->nextFreeFileID);
+		SET_SWAP_BE16(tkp->nodeName.length, 0);
 		offset += SWAP_BE16 (tkp->keyLength) + 2;
 	
 		ctp = (HFSPlusCatalogThread *)((UInt8 *)buffer + offset);
-		ctp->recordType = SWAP_BE16 (kHFSPlusFileThreadRecord);
-		ctp->parentID   = SWAP_BE32 (kHFSRootFolderID);
+		SET_SWAP_BE16(ctp->recordType, kHFSPlusFileThreadRecord);
+		SET_SWAP_BE32(ctp->parentID, kHFSRootFolderID);
 		bcopy(nodename1, &ctp->nodeName, sizeof(UInt16) + unicodeBytes);
 		offset += (sizeof(HFSPlusCatalogThread)
 				- (sizeof(ctp->nodeName.unicode) - unicodeBytes) );
@@ -1216,14 +1220,14 @@ InitCatalogRoot_HFSPlus(const hfsparams_
 
 		/* Thread record for file #2 */
 		tkp = (HFSPlusCatalogKey *)((UInt8 *)buffer + offset);
-		tkp->keyLength = SWAP_BE16 (kHFSPlusCatalogKeyMinimumLength);
-		tkp->parentID  = SWAP_BE32 (dp->nextFreeFileID + 1);
-		tkp->nodeName.length = 0;
+		SET_SWAP_BE16(tkp->keyLength, kHFSPlusCatalogKeyMinimumLength);
+		SET_SWAP_BE32(tkp->parentID, dp->nextFreeFileID + 1);
+		SET_SWAP_BE16(tkp->nodeName.length, 0);
 		offset += SWAP_BE16 (tkp->keyLength) + 2;
 	
 		ctp = (HFSPlusCatalogThread *)((UInt8 *)buffer + offset);
-		ctp->recordType = SWAP_BE16 (kHFSPlusFileThreadRecord);
-		ctp->parentID   = SWAP_BE32 (kHFSRootFolderID);
+		SET_SWAP_BE16(ctp->recordType, kHFSPlusFileThreadRecord);
+		SET_SWAP_BE32(ctp->parentID, kHFSRootFolderID);
 		bcopy(nodename2, &ctp->nodeName, sizeof(UInt16) + unicodeBytes);
 		offset += (sizeof(HFSPlusCatalogThread)
 				- (sizeof(ctp->nodeName.unicode) - unicodeBytes) );
@@ -1254,7 +1258,7 @@ InitFirstCatalogLeaf(const hfsparams_t *
 	 */
 	ndp = (BTNodeDescriptor *)buffer;
 	ndp->kind			= kBTLeafNode;
-	ndp->numRecords		= SWAP_BE16 (2);
+	SET_SWAP_BE16(ndp->numRecords, 2);
 	ndp->height			= 1;
 	offset = sizeof(BTNodeDescriptor);
 
@@ -1267,16 +1271,16 @@ InitFirstCatalogLeaf(const hfsparams_t *
 	ckp->nodeName[0]	= strlen(dp->volumeName);
 	bcopy(dp->volumeName, &ckp->nodeName[1], ckp->nodeName[0]);
 	ckp->keyLength		= 1 + 4 + ((ckp->nodeName[0] + 2) & 0xFE);  /* pad to word */
-	ckp->parentID		= SWAP_BE32 (kHFSRootParentID);
+	SET_SWAP_BE32(ckp->parentID, kHFSRootParentID);
 	offset += ckp->keyLength + 1;
 
 	cdp = (HFSCatalogFolder *)((UInt8 *)buffer + offset);
-	cdp->recordType		= SWAP_BE16 (kHFSFolderRecord);
+	SET_SWAP_BE16(cdp->recordType, kHFSFolderRecord);
 	if (wrapper)
-		cdp->valence	= SWAP_BE16 (SWAP_BE16 (cdp->valence) + kWapperFileCount);
-	cdp->folderID		= SWAP_BE32 (kHFSRootFolderID);
-	cdp->createDate		= SWAP_BE32 (timeStamp);
-	cdp->modifyDate		= SWAP_BE32 (timeStamp);
+		SET_SWAP_BE16(cdp->valence, SWAP_BE16 (cdp->valence) + kWapperFileCount);
+	SET_SWAP_BE32(cdp->folderID, kHFSRootFolderID);
+	SET_SWAP_BE32(cdp->createDate, timeStamp);
+	SET_SWAP_BE32(cdp->modifyDate, timeStamp);
 	offset += sizeof(HFSCatalogFolder);
 
 	SETOFFSET(buffer, nodeSize, offset, 2);
@@ -1286,13 +1290,13 @@ InitFirstCatalogLeaf(const hfsparams_t *
 	 */
 	tkp = (HFSCatalogKey *)((UInt8 *)buffer + offset);
 	tkp->keyLength		= kHFSCatalogKeyMinimumLength;
-	tkp->parentID		= SWAP_BE32 (kHFSRootFolderID);
+	SET_SWAP_BE32(tkp->parentID, kHFSRootFolderID);
 	// tkp->nodeName[0] = 0;
 	offset += tkp->keyLength + 2;
 
 	ctp = (HFSCatalogThread *)((UInt8 *)buffer + offset);
-	ctp->recordType		= SWAP_BE16 (kHFSFolderThreadRecord);
-	ctp->parentID		= SWAP_BE32 (kHFSRootParentID);
+	SET_SWAP_BE16(ctp->recordType, kHFSFolderThreadRecord);
+	SET_SWAP_BE32(ctp->parentID, kHFSRootParentID);
 	bcopy(ckp->nodeName, ctp->nodeName, ckp->nodeName[0]+1);
 	offset += sizeof(HFSCatalogThread);
 
@@ -1302,31 +1306,31 @@ InitFirstCatalogLeaf(const hfsparams_t *
 	 * For Wrapper volumes there are more file records...
 	 */
 	if (wrapper) {
-		ndp->fLink				= SWAP_BE32 (3);
-		ndp->numRecords			= SWAP_BE16 (SWAP_BE16 (ndp->numRecords) + 2);
+		SET_SWAP_BE32(ndp->fLink, 3);
+		SET_SWAP_BE16(ndp->numRecords, SWAP_BE16 (ndp->numRecords) + 2);
 
 		/*
 		 * Add "Desktop DB" file...
 		 */
 		ckp = (HFSCatalogKey *)((UInt8 *)buffer + offset);
 		ckp->keyLength			= 1 + 4 + ((kDTDB_Chars + 2) & 0xFE);  /* pad to word */
-		ckp->parentID			= SWAP_BE32 (kHFSRootFolderID);
+		SET_SWAP_BE32(ckp->parentID, kHFSRootFolderID);
 		ckp->nodeName[0]		= kDTDB_Chars;
 		bcopy(kDTDB_Name, &ckp->nodeName[1], kDTDB_Chars);
 		offset += ckp->keyLength + 1;
 
 		cfp = (HFSCatalogFile *)((UInt8 *)buffer + offset);
-		cfp->recordType			= SWAP_BE16 (kHFSFileRecord);
-		cfp->userInfo.fdType	= SWAP_BE32 (kDTDB_Type);
-		cfp->userInfo.fdCreator	= SWAP_BE32 (kDTDB_Creator);
-		cfp->userInfo.fdFlags	= SWAP_BE16 (kIsInvisible);
-		cfp->fileID				= SWAP_BE32 (kDTDB_FileID);
-		cfp->createDate			= SWAP_BE32 (timeStamp);
-		cfp->modifyDate			= SWAP_BE32 (timeStamp);
-		cfp->dataExtents[0].startBlock = SWAP_BE16 (gDTDBFork.startBlock);
-		cfp->dataExtents[0].blockCount = SWAP_BE16 (gDTDBFork.blockCount);
-		cfp->dataPhysicalSize	= SWAP_BE32 (gDTDBFork.physicalSize);
-		cfp->dataLogicalSize	= SWAP_BE32 (gDTDBFork.logicalSize);
+		SET_SWAP_BE16(cfp->recordType, kHFSFileRecord);
+		SET_SWAP_BE32(cfp->userInfo.fdType, kDTDB_Type);
+		SET_SWAP_BE32(cfp->userInfo.fdCreator, kDTDB_Creator);
+		SET_SWAP_BE16(cfp->userInfo.fdFlags, kIsInvisible);
+		SET_SWAP_BE32(cfp->fileID, kDTDB_FileID);
+		SET_SWAP_BE32(cfp->createDate, timeStamp);
+		SET_SWAP_BE32(cfp->modifyDate, timeStamp);
+		SET_SWAP_BE16(cfp->dataExtents[0].startBlock, gDTDBFork.startBlock);
+		SET_SWAP_BE16(cfp->dataExtents[0].blockCount, gDTDBFork.blockCount);
+		SET_SWAP_BE32(cfp->dataPhysicalSize, gDTDBFork.physicalSize);
+		SET_SWAP_BE32(cfp->dataLogicalSize, gDTDBFork.logicalSize);
 		offset += sizeof(HFSCatalogFile);
 
 		SETOFFSET(buffer, nodeSize, offset, 4);
@@ -1336,19 +1340,19 @@ InitFirstCatalogLeaf(const hfsparams_t *
 		 */
 		ckp = (HFSCatalogKey *)((UInt8 *)buffer + offset);
 		ckp->keyLength			= 1 + 4 + ((kDTDF_Chars + 2) & 0xFE);  /* pad to word */
-		ckp->parentID			= SWAP_BE32 (kHFSRootFolderID);
+		SET_SWAP_BE32(ckp->parentID, kHFSRootFolderID);
 		ckp->nodeName[0]		= kDTDF_Chars;
 		bcopy(kDTDF_Name, &ckp->nodeName[1], kDTDF_Chars);
 		offset += ckp->keyLength + 1;
 
 		cfp = (HFSCatalogFile *)((UInt8 *)buffer + offset);
-		cfp->recordType			= SWAP_BE16 (kHFSFileRecord);
-		cfp->userInfo.fdType	= SWAP_BE32 (kDTDF_Type);
-		cfp->userInfo.fdCreator	= SWAP_BE32 (kDTDF_Creator);
-		cfp->userInfo.fdFlags	= SWAP_BE16 (kIsInvisible);
-		cfp->fileID				= SWAP_BE32 (kDTDF_FileID);
-		cfp->createDate			= SWAP_BE32 (timeStamp);
-		cfp->modifyDate			= SWAP_BE32 (timeStamp);
+		SET_SWAP_BE16(cfp->recordType, kHFSFileRecord);
+		SET_SWAP_BE32(cfp->userInfo.fdType, kDTDF_Type);
+		SET_SWAP_BE32(cfp->userInfo.fdCreator, kDTDF_Creator);
+		SET_SWAP_BE16(cfp->userInfo.fdFlags, kIsInvisible);
+		SET_SWAP_BE32(cfp->fileID, kDTDF_FileID);
+		SET_SWAP_BE32(cfp->createDate, timeStamp);
+		SET_SWAP_BE32(cfp->modifyDate, timeStamp);
 		offset += sizeof(HFSCatalogFile);
 
 		SETOFFSET(buffer, nodeSize, offset, 5);
@@ -1374,9 +1378,9 @@ InitSecondCatalogLeaf(const hfsparams_t 
 	 * All nodes have a node descriptor...
 	 */
 	ndp = (BTNodeDescriptor *)buffer;
-	ndp->bLink		= SWAP_BE32 (2);
+	SET_SWAP_BE32(ndp->bLink, 2);
 	ndp->kind		= kBTLeafNode;
-	ndp->numRecords	= SWAP_BE16 (3);
+	SET_SWAP_BE16(ndp->numRecords, 3);
 	ndp->height		= 1;
 	offset = sizeof(BTNodeDescriptor);
 
@@ -1387,19 +1391,19 @@ InitSecondCatalogLeaf(const hfsparams_t 
 	 */
 	ckp = (HFSCatalogKey *)((UInt8 *)buffer + offset);
 	ckp->keyLength			= 1 + 4 + ((kFinder_Chars + 2) & 0xFE);  /* pad to word */
-	ckp->parentID			= SWAP_BE32 (kHFSRootFolderID);
+	SET_SWAP_BE32(ckp->parentID, kHFSRootFolderID);
 	ckp->nodeName[0]		= kFinder_Chars;
 	bcopy(kFinder_Name, &ckp->nodeName[1], kFinder_Chars);
 	offset += ckp->keyLength + 1;
 
 	cfp = (HFSCatalogFile *)((UInt8 *)buffer + offset);
-	cfp->recordType			= SWAP_BE16 (kHFSFileRecord);
-	cfp->userInfo.fdType	= SWAP_BE32 (kFinder_Type);
-	cfp->userInfo.fdCreator	= SWAP_BE32 (kFinder_Creator);
-	cfp->userInfo.fdFlags	= SWAP_BE16 (kIsInvisible + kNameLocked + kHasBeenInited);
-	cfp->fileID				= SWAP_BE32 (kFinder_FileID);
-	cfp->createDate			= SWAP_BE32 (timeStamp);
-	cfp->modifyDate			= SWAP_BE32 (timeStamp);
+	SET_SWAP_BE16(cfp->recordType, kHFSFileRecord);
+	SET_SWAP_BE32(cfp->userInfo.fdType, kFinder_Type);
+	SET_SWAP_BE32(cfp->userInfo.fdCreator, kFinder_Creator);
+	SET_SWAP_BE16(cfp->userInfo.fdFlags, kIsInvisible + kNameLocked + kHasBeenInited);
+	SET_SWAP_BE32(cfp->fileID, kFinder_FileID);
+	SET_SWAP_BE32(cfp->createDate, timeStamp);
+	SET_SWAP_BE32(cfp->modifyDate, timeStamp);
 	offset += sizeof(HFSCatalogFile);
 
 	SETOFFSET(buffer, nodeSize, offset, 2);
@@ -1409,23 +1413,23 @@ InitSecondCatalogLeaf(const hfsparams_t 
 	 */
 	ckp = (HFSCatalogKey *)((UInt8 *)buffer + offset);
 	ckp->keyLength			= 1 + 4 + ((kReadMe_Chars + 2) & 0xFE);  /* pad to word */
-	ckp->parentID			= SWAP_BE32 (kHFSRootFolderID);
+	SET_SWAP_BE32(ckp->parentID, kHFSRootFolderID);
 	ckp->nodeName[0]		= kReadMe_Chars;
 	bcopy(kReadMe_Name, &ckp->nodeName[1], kReadMe_Chars);
 	offset += ckp->keyLength + 1;
 
 	cfp = (HFSCatalogFile *)((UInt8 *)buffer + offset);
-	cfp->recordType			= SWAP_BE16 (kHFSFileRecord);
-	cfp->userInfo.fdType	= SWAP_BE32 (kReadMe_Type);
-	cfp->userInfo.fdCreator	= SWAP_BE32 (kReadMe_Creator);
-	cfp->userInfo.fdFlags	= SWAP_BE16 (kIsInvisible);
-	cfp->fileID				= SWAP_BE32 (kReadMe_FileID);
-	cfp->createDate			= SWAP_BE32 (timeStamp);
-	cfp->modifyDate			= SWAP_BE32 (timeStamp);
-	cfp->dataExtents[0].startBlock = SWAP_BE16 (gReadMeFork.startBlock);
-	cfp->dataExtents[0].blockCount = SWAP_BE16 (gReadMeFork.blockCount);
-	cfp->dataPhysicalSize	= SWAP_BE32 (gReadMeFork.physicalSize);
-	cfp->dataLogicalSize	= SWAP_BE32 (gReadMeFork.logicalSize);
+	SET_SWAP_BE16(cfp->recordType, kHFSFileRecord);
+	SET_SWAP_BE32(cfp->userInfo.fdType, kReadMe_Type);
+	SET_SWAP_BE32(cfp->userInfo.fdCreator, kReadMe_Creator);
+	SET_SWAP_BE16(cfp->userInfo.fdFlags, kIsInvisible);
+	SET_SWAP_BE32(cfp->fileID, kReadMe_FileID);
+	SET_SWAP_BE32(cfp->createDate, timeStamp);
+	SET_SWAP_BE32(cfp->modifyDate, timeStamp);
+	SET_SWAP_BE16(cfp->dataExtents[0].startBlock, gReadMeFork.startBlock);
+	SET_SWAP_BE16(cfp->dataExtents[0].blockCount, gReadMeFork.blockCount);
+	SET_SWAP_BE32(cfp->dataPhysicalSize, gReadMeFork.physicalSize);
+	SET_SWAP_BE32(cfp->dataLogicalSize, gReadMeFork.logicalSize);
 	offset += sizeof(HFSCatalogFile);
 
 	SETOFFSET(buffer, nodeSize, offset, 3);
@@ -1435,23 +1439,23 @@ InitSecondCatalogLeaf(const hfsparams_t 
 	 */
 	ckp = (HFSCatalogKey *)((UInt8 *)buffer + offset);
 	ckp->keyLength			= 1 + 4 + ((kSystem_Chars + 2) & 0xFE);  /* pad to word */
-	ckp->parentID			= SWAP_BE32 (kHFSRootFolderID);
+	SET_SWAP_BE32(ckp->parentID, kHFSRootFolderID);
 	ckp->nodeName[0]		= kSystem_Chars;
 	bcopy(kSystem_Name, &ckp->nodeName[1], kSystem_Chars);
 	offset += ckp->keyLength + 1;
 
 	cfp = (HFSCatalogFile *)((UInt8 *)buffer + offset);
-	cfp->recordType			= SWAP_BE16 (kHFSFileRecord);
-	cfp->userInfo.fdType	= SWAP_BE32 (kSystem_Type);
-	cfp->userInfo.fdCreator	= SWAP_BE32 (kSystem_Creator);
-	cfp->userInfo.fdFlags	= SWAP_BE16 (kIsInvisible + kNameLocked + kHasBeenInited);
-	cfp->fileID				= SWAP_BE32 (kSystem_FileID);
-	cfp->createDate			= SWAP_BE32 (timeStamp);
-	cfp->modifyDate			= SWAP_BE32 (timeStamp);
-	cfp->rsrcExtents[0].startBlock = SWAP_BE16 (gSystemFork.startBlock);
-	cfp->rsrcExtents[0].blockCount = SWAP_BE16 (gSystemFork.blockCount);
-	cfp->rsrcPhysicalSize	= SWAP_BE32 (gSystemFork.physicalSize);
-	cfp->rsrcLogicalSize	= SWAP_BE32 (gSystemFork.logicalSize);
+	SET_SWAP_BE16(cfp->recordType, kHFSFileRecord);
+	SET_SWAP_BE32(cfp->userInfo.fdType, kSystem_Type);
+	SET_SWAP_BE32(cfp->userInfo.fdCreator, kSystem_Creator);
+	SET_SWAP_BE16(cfp->userInfo.fdFlags, kIsInvisible + kNameLocked + kHasBeenInited);
+	SET_SWAP_BE32(cfp->fileID, kSystem_FileID);
+	SET_SWAP_BE32(cfp->createDate, timeStamp);
+	SET_SWAP_BE32(cfp->modifyDate, timeStamp);
+	SET_SWAP_BE16(cfp->rsrcExtents[0].startBlock, gSystemFork.startBlock);
+	SET_SWAP_BE16(cfp->rsrcExtents[0].blockCount, gSystemFork.blockCount);
+	SET_SWAP_BE32(cfp->rsrcPhysicalSize, gSystemFork.physicalSize);
+	SET_SWAP_BE32(cfp->rsrcLogicalSize, gSystemFork.logicalSize);
 	offset += sizeof(HFSCatalogFile);
 
 	SETOFFSET(buffer, nodeSize, offset, 4);
@@ -1463,7 +1467,7 @@ InitCatalogRoot_HFS(const hfsparams_t *d
 {
 	BTNodeDescriptor	*ndp;
 	HFSCatalogKey		*ckp;
-	UInt32				*prp;	/* pointer record */
+	u_big_int32_t		*prp;	/* pointer record */
 	UInt16				nodeSize;
 	SInt16				offset;
 
@@ -1475,7 +1479,7 @@ InitCatalogRoot_HFS(const hfsparams_t *d
 	 */
 	ndp = (BTNodeDescriptor *)buffer;
 	ndp->kind		= kBTIndexNode;
-	ndp->numRecords	= SWAP_BE16 (2);
+	SET_SWAP_BE16(ndp->numRecords, 2);
 	ndp->height		= 2;
 	offset = sizeof(BTNodeDescriptor);
 
@@ -1486,13 +1490,13 @@ InitCatalogRoot_HFS(const hfsparams_t *d
 	 */
 	ckp = (HFSCatalogKey *)((UInt8 *)buffer + offset);
 	ckp->keyLength		= kHFSCatalogKeyMaximumLength;
-	ckp->parentID		= SWAP_BE32 (kHFSRootParentID);
+	SET_SWAP_BE32(ckp->parentID, kHFSRootParentID);
 	ckp->nodeName[0]	= strlen(dp->volumeName);
 	bcopy(dp->volumeName, &ckp->nodeName[1], ckp->nodeName[0]);
 	offset += ckp->keyLength + 1;
 
-	prp = (UInt32 *)((UInt8 *)buffer + offset);
-	*prp				= SWAP_BE32 (2);	/* point to first leaf node */
+	prp = (u_big_int32_t *)((UInt8 *)buffer + offset);
+	SET_SWAP_BE32(*prp, 2);	/* point to first leaf node */
 	offset += sizeof(UInt32);
 
 	SETOFFSET(buffer, nodeSize, offset, 2);
@@ -1502,13 +1506,13 @@ InitCatalogRoot_HFS(const hfsparams_t *d
 	 */
 	ckp = (HFSCatalogKey *)((UInt8 *)buffer + offset);
 	ckp->keyLength		= kHFSCatalogKeyMaximumLength;
-	ckp->parentID		= SWAP_BE32 (kHFSRootFolderID);
+	SET_SWAP_BE32(ckp->parentID, kHFSRootFolderID);
 	ckp->nodeName[0]	= kFinder_Chars;
 	bcopy(kFinder_Name, &ckp->nodeName[1], kFinder_Chars);
 	offset += ckp->keyLength + 1;
 
-	prp = (UInt32 *)((UInt8 *)buffer + offset);
-	*prp				= SWAP_BE32 (3);	/* point to last leaf node */
+	prp = (u_big_int32_t *)((UInt8 *)buffer + offset);
+	SET_SWAP_BE32(*prp, 3);	/* point to last leaf node */
 	offset += sizeof(UInt32);
 
 	SETOFFSET(buffer, nodeSize, offset, 3);
@@ -1538,7 +1542,7 @@ WriteDesktopDB(const hfsparams_t *dp, co
 	/* FILL IN THE NODE DESCRIPTOR:  */
 	ndp = (BTNodeDescriptor *)buffer;
 	ndp->kind		= kBTHeaderNode;
-	ndp->numRecords	= SWAP_BE16 (3);
+	SET_SWAP_BE16(ndp->numRecords, 3);
 	offset = sizeof(BTNodeDescriptor);
 
 	SETOFFSET(buffer, nodeSize, offset, 1);
@@ -1550,11 +1554,11 @@ WriteDesktopDB(const hfsparams_t *dp, co
     //	bthp->firstLeafNode	= 0;
     //	bthp->lastLeafNode	= 0;
     //	bthp->leafRecords	= 0;
-	bthp->nodeSize		= SWAP_BE16 (nodeSize);
-	bthp->maxKeyLength	= SWAP_BE16 (37);
-	bthp->totalNodes	= SWAP_BE32 (fileSize / nodeSize);
-	bthp->freeNodes		= SWAP_BE32 (SWAP_BE32 (bthp->totalNodes) - 1);  /* header */
-	bthp->clumpSize		= SWAP_BE32 (fileSize);
+	SET_SWAP_BE16(bthp->nodeSize, nodeSize);
+	SET_SWAP_BE16(bthp->maxKeyLength, 37);
+	SET_SWAP_BE32(bthp->totalNodes, fileSize / nodeSize);
+	SET_SWAP_BE32(bthp->freeNodes, SWAP_BE32 (bthp->totalNodes) - 1);  /* header */
+	SET_SWAP_BE32(bthp->clumpSize, fileSize);
 	bthp->btreeType		= 0xFF;
 	offset += sizeof(BTHeaderRec);
 
@@ -1578,14 +1582,14 @@ WriteDesktopDB(const hfsparams_t *dp, co
 	if (SWAP_BE32 (bthp->totalNodes) > nodeBitsInHeader) {
 		UInt32	nodeBitsInMapNode;
 		
-		ndp->fLink = SWAP_BE32 (SWAP_BE32 (bthp->lastLeafNode) + 1);
+		SET_SWAP_BE32(ndp->fLink, SWAP_BE32 (bthp->lastLeafNode) + 1);
 		nodeBitsInMapNode = 8 * (nodeSize
 						- sizeof(BTNodeDescriptor)
 						- (2 * sizeof(SInt16))
 						- 2 );
 		*mapNodes = (SWAP_BE32 (bthp->totalNodes) - nodeBitsInHeader +
 		            (nodeBitsInMapNode - 1)) / nodeBitsInMapNode;
-		bthp->freeNodes = SWAP_BE32 (SWAP_BE32 (bthp->freeNodes) - *mapNodes);
+		SET_SWAP_BE32(bthp->freeNodes, SWAP_BE32 (bthp->freeNodes) - *mapNodes);
 	}
 
 	/* 
@@ -1624,7 +1628,7 @@ WriteSystemFile(const DriveInfo *dip, UI
 		errx(1, "hfsbootdata file too big.");
 
 	if ((buf = malloc(writesize)) == NULL)
-		err(1, NULL);
+		exit(1);
 	
 	if ((fd = open(HFS_BOOT_DATA, O_RDONLY, 0)) < 0)
 		err(1, "open %s", HFS_BOOT_DATA);
@@ -1659,7 +1663,7 @@ WriteReadMeFile(const DriveInfo *dip, UI
 	writesize = ROUNDUP(datasize, dip->sectorSize);
 
 	if ((buf = malloc(writesize)) == NULL)
-		err(1, NULL);
+		exit(1);
 	
 	bcopy(hfswrap_readme, buf, datasize);
 	if (writesize > datasize)
@@ -1688,7 +1692,7 @@ WriteMapNodes(const DriveInfo *driveInfo
 	bzero(buffer, btNodeSize);
 
 	nd->kind		= kBTMapNode;
-	nd->numRecords	= SWAP_BE16 (1);
+	SET_SWAP_BE16(nd->numRecords, 1);
 	
 	/* note: must belong word aligned (hence the extra -2) */
 	mapRecordBytes = btNodeSize - sizeof(BTNodeDescriptor) - 2*sizeof(SInt16) - 2;	
@@ -1705,9 +1709,9 @@ WriteMapNodes(const DriveInfo *driveInfo
 	 */
 	for (i = 0; i < mapNodes; i++) {
 		if ((i + 1) < mapNodes)
-			nd->fLink = SWAP_BE32 (++firstMapNode);  /* point to next map node */
+			SET_SWAP_BE32(nd->fLink, ++firstMapNode);  /* point to next map node */
 		else
-			nd->fLink = 0;  /* this is the last map node */
+			SET_SWAP_BE32(nd->fLink, 0);  /* this is the last map node */
 
 		WriteBuffer(driveInfo, diskStart, btNodeSize, buffer);
 			
@@ -1738,7 +1742,7 @@ ClearDisk(const DriveInfo *driveInfo, UI
 
 	tempBuffer = valloc((size_t)bufferSize);
 	if (tempBuffer == NULL)
-		err(1, NULL);
+		exit(1);
 
 	bzero(tempBuffer, bufferSize);
 
@@ -1767,7 +1771,7 @@ WriteBuffer(const DriveInfo *driveInfo, 
 	off_t sector;
 
 	if ((byteCount % driveInfo->sectorSize) != 0)
-		errx(1, "WriteBuffer: byte count %ld is not sector size multiple", byteCount);
+		errx(1, "WriteBuffer: byte count %u is not sector size multiple", byteCount);
 
 	sector = driveInfo->sectorOffset + startingSector;
 
@@ -1775,7 +1779,7 @@ WriteBuffer(const DriveInfo *driveInfo, 
 		err(1, "seek (sector %qd)", sector);
 
 	if (write(driveInfo->fd, buffer, byteCount) != byteCount)
-		err(1, "write (sector %qd, %ld bytes)", sector, byteCount);
+		err(1, "write (sector %qd, %u bytes)", sector, byteCount);
 }
 
 
@@ -1812,9 +1816,9 @@ static void MarkBitInAllocationBuffer( H
 	UInt16 bitInSector = allocationBlock % kBitsPerSector;
 	UInt16 bitPosition = allocationBlock % 8;
 	
-	sectorsPerBlock = header->blockSize / kBytesPerSector;
+	sectorsPerBlock = SWAP_BE32(header->blockSize) / kBytesPerSector;
 
-	*sector = (header->allocationFile.extents[0].startBlock * sectorsPerBlock) +
+	*sector = (SWAP_BE32(header->allocationFile.extents[0].startBlock) * sectorsPerBlock) +
 		  (allocationBlock / kBitsPerSector);
 	
 	byteP = (UInt8 *)sectorBuffer + (bitInSector >> 3);
@@ -1889,13 +1893,13 @@ GetDefaultEncoding()
 
 static int
 ConvertUTF8toUnicode(const UInt8* source, UInt32 bufsize, UniChar* unibuf,
-	UInt16 *charcount)
+	u_big_int16_t *charcount)
 {
 	UInt8 byte;
 	UniChar* target;
 	UniChar* targetEnd;
 
-	*charcount = 0;
+	SET_SWAP_BE16(*charcount, 0);
 	target = unibuf;
 	targetEnd = (UniChar *)((UInt8 *)unibuf + bufsize);
 
@@ -1906,9 +1910,9 @@ ConvertUTF8toUnicode(const UInt8* source
 			if (byte == ':')	/* ':' is mapped to '/' */
 				byte = '/';
 
-			*target++ = SWAP_BE16 (byte);
+			SET_SWAP_BE16(*target++, byte);
 		} else {
-			UniChar ch;
+			UInt16 ch;
 			UInt8 seq = (byte >> 4);
 
 			switch (seq) {
@@ -1937,11 +1941,11 @@ ConvertUTF8toUnicode(const UInt8* source
 			if (target >= targetEnd)
 				return (ENOBUFS);
 
-			*target++ = SWAP_BE16 (ch);
+			SET_SWAP_BE16(*target++, ch);
 		}
 	}
 
-	*charcount = target - unibuf;
+	SET_SWAP_BE16(*charcount, target - unibuf);
 
 	return (0);
 }
diff -Npur diskdev_cmds.org/newfs_hfs.tproj/newfs_hfs.c diskdev_cmds/newfs_hfs.tproj/newfs_hfs.c
--- diskdev_cmds.org/newfs_hfs.tproj/newfs_hfs.c	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/newfs_hfs.tproj/newfs_hfs.c	2003-07-08 12:40:16.000000000 +0200
@@ -40,13 +40,16 @@
 #include <ctype.h>
 #include <syslog.h>
 #include <unistd.h>
+#include <time.h>
 
 #include <sys/ioctl.h>
 #include <sys/mount.h>
 #include <sys/param.h>
 #include <sys/stat.h>
 
+#if __APPLE__
 #include <IOKit/storage/IOMediaBSDClient.h>
+#endif
 
 #include <hfs/hfs_format.h>
 #include "newfs_hfs.h"
@@ -133,11 +136,14 @@ main(argc, argv)
 	extern int optind;
 	int ch;
 	int forceHFS;
+#if __APPLE__
 	char *cp, *special;
 	struct statfs *mp;
 	int n;
-	
-	if (progname = strrchr(*argv, '/'))
+#endif
+
+	progname = strrchr(*argv, '/');
+	if (progname)
 		++progname;
 	else
 		progname = *argv;
@@ -212,6 +218,7 @@ main(argc, argv)
 	if (argc != 1)
 		usage();
 
+#if __APPLE__
 	special = argv[0];
 	cp = strrchr(special, '/');
 	if (cp != 0)
@@ -220,6 +227,9 @@ main(argc, argv)
 		special++;
 	(void) sprintf(rawdevice, "%sr%s", _PATH_DEV, special);
 	(void) sprintf(blkdevice, "%s%s", _PATH_DEV, special);
+#else
+	strcpy(rawdevice, argv[0]);
+#endif
 
 	if (forceHFS && gJournaled) {
 		fprintf(stderr, "-h -J: incompatible options specified\n");
@@ -234,6 +244,7 @@ main(argc, argv)
 		exit(1);
 	}
 
+#if __APPLE__
 	/*
 	 * Check if target device is aready mounted
 	 */
@@ -246,14 +257,17 @@ main(argc, argv)
 			fatal("%s is mounted on %s", blkdevice, mp->f_mntonname);
 		++mp;
 	}
+#endif
 
 	if (hfs_newfs(rawdevice, forceHFS, true) < 0) {
+#if __APPLE__
 		/* On ENXIO error use the block device (to get de-blocking) */
 		if (errno == ENXIO) {
 			if (hfs_newfs(blkdevice, forceHFS, false) < 0)
-				err(1, NULL);
+				exit(1);
 		} else
-			err(1, NULL);
+#endif
+			exit(1);
 	}
 
 	exit(0);
@@ -267,7 +281,7 @@ static void getnodeopts(char* optlist)
 	char *p;
 	UInt32 ndsize;
 	
-	while((ndarg = strsep(&strp, ",")) != NULL && *ndarg != NULL) {
+	while((ndarg = strsep(&strp, ",")) != NULL && *ndarg != 0) {
 
 		p = strchr(ndarg, '=');
 		if (p == NULL)
@@ -277,20 +291,20 @@ static void getnodeopts(char* optlist)
 
 		switch (*ndarg) {
 		case 'c':
-			if (ndsize < 4096 || ndsize > 32768 || (ndsize & ndsize-1) != 0)
+			if (ndsize < 4096 || ndsize > 32768 || (ndsize & (ndsize-1)) != 0)
 				fatal("%s: invalid catalog b-tree node size", ndarg);
 			catnodesiz = ndsize;
 			gUserCatNodeSize = TRUE;
 			break;
 
 		case 'e':
-			if (ndsize < 1024 || ndsize > 32768 || (ndsize & ndsize-1) != 0)
+			if (ndsize < 1024 || ndsize > 32768 || (ndsize & (ndsize-1)) != 0)
 				fatal("%s: invalid extents b-tree node size", ndarg);
 			extnodesiz = ndsize;
 			break;
 
 		case 'a':
-			if (ndsize < 1024 || ndsize > 32768 || (ndsize & ndsize-1) != 0)
+			if (ndsize < 1024 || ndsize > 32768 || (ndsize & (ndsize-1)) != 0)
 				fatal("%s: invalid atrribute b-tree node size", ndarg);
 			atrnodesiz = ndsize;
 			break;
@@ -309,7 +323,7 @@ static void getclumpopts(char* optlist)
 	char *p;
 	UInt32 clpblocks;
 	
-	while((ndarg = strsep(&strp, ",")) != NULL && *ndarg != NULL) {
+	while((ndarg = strsep(&strp, ",")) != NULL && *ndarg != 0) {
 
 		p = strchr(ndarg, '=');
 		if (p == NULL)
@@ -369,14 +383,14 @@ static void validate_hfsplus_block_size(
 		}
 	} else {
 		/* Make sure a user-specified block size is reasonable */
-		if ((gBlockSize & gBlockSize-1) != 0)
+		if ((gBlockSize & (gBlockSize-1)) != 0)
 			fatal("%s: bad HFS Plus allocation block size (must be a power of two)", optarg);
 	
 		if ((sectorCount / (gBlockSize / sectorSize)) > 0xFFFFFFFF)
 			fatal("%s: block size is too small for %lld sectors", optarg, gBlockSize, sectorCount);
 
 		if (gBlockSize < HFSOPTIMALBLKSIZE)
-			warnx("Warning: %ld is a non-optimal block size (4096 would be a better choice)", gBlockSize);
+			warnx("Warning: %u is a non-optimal block size (4096 would be a better choice)", gBlockSize);
 	}
 }
 
@@ -390,7 +404,9 @@ hfs_newfs(char *device, int forceHFS, in
 	int fso = 0;
 	int retval = 0;
 	hfsparams_t defaults = {0};
+#if __APPLE__
 	u_int64_t maxSectorsPerIO;
+#endif
 
 	if (gNoCreate) {
 		fso = open( device, O_RDONLY | O_NDELAY, 0 );
@@ -404,6 +420,7 @@ hfs_newfs(char *device, int forceHFS, in
 	if (fstat( fso, &stbuf) < 0)
 		fatal("%s: %s", device, strerror(errno));
 
+#if __APPLE__
 	if (ioctl(fso, DKIOCGETBLOCKCOUNT, &dip.totalSectors) < 0)
 		fatal("%s: %s", device, strerror(errno));
 
@@ -414,6 +431,30 @@ hfs_newfs(char *device, int forceHFS, in
 		dip.sectorsPerIO = (128 * 1024) / dip.sectorSize;  /* use 128K as default */
 	else
 		dip.sectorsPerIO = maxSectorsPerIO;
+#else
+#ifndef BLKGETSIZE
+#define BLKGETSIZE		_IO(0x12,96)
+#endif
+#ifndef BLKGETSIZE64
+#define BLKGETSIZE64	_IOR(0x12,114,size_t)
+#endif
+
+	dip.sectorSize = 512;
+	dip.sectorsPerIO = 256;
+	if (S_ISREG(stbuf.st_mode)) {
+		dip.totalSectors = stbuf.st_size / 512;
+	} else if (S_ISBLK(stbuf.st_mode)) {
+		unsigned long size;
+		u_int64_t size64;
+		if (!ioctl(fso, BLKGETSIZE64, &size64))
+			dip.totalSectors = size64 / 512;
+		else if (!ioctl(fso, BLKGETSIZE, &size))
+			dip.totalSectors = size;
+		else
+			fatal("%s: %s", device, strerror(errno));
+	} else
+		fatal("%s: is not a block device", device);
+#endif
 	/*
          * The make_hfs code currentlydoes 512 byte sized I/O.
          * If the sector size is bigger than 512, start over
@@ -572,7 +613,7 @@ static void hfsplus_params (UInt64 secto
 	defaults->catalogClumpSize = clumpSize;
 	defaults->catalogNodeSize = catnodesiz;
 	if (gBlockSize < 4096 && gBlockSize < catnodesiz)
-		warnx("Warning: block size %ld is less than catalog b-tree node size %ld", gBlockSize, catnodesiz);
+		warnx("Warning: block size %u is less than catalog b-tree node size %u", gBlockSize, catnodesiz);
 
 	if (extclumpblks == 0) {
 		clumpSize = CalcHFSPlusBTreeClumpSize(gBlockSize, extnodesiz, sectorCount, FALSE);
@@ -585,7 +626,7 @@ static void hfsplus_params (UInt64 secto
 	defaults->extentsClumpSize = clumpSize;
 	defaults->extentsNodeSize = extnodesiz;
 	if (gBlockSize < extnodesiz)
-		warnx("Warning: block size %ld is less than extents b-tree node size %ld", gBlockSize, extnodesiz);
+		warnx("Warning: block size %d is less than extents b-tree node size %d", gBlockSize, extnodesiz);
 
 	if (atrclumpblks == 0) {
 		clumpSize = 0;
@@ -630,22 +671,22 @@ static void hfsplus_params (UInt64 secto
 
 	if (gNoCreate) {
 		if (!gWrapper)
-			printf("%qd sectors (%lu bytes per sector)\n", sectorCount, sectorSize);
+			printf("%Lu sectors (%u bytes per sector)\n", sectorCount, sectorSize);
 		printf("HFS Plus format parameters:\n");
 		printf("\tvolume name: \"%s\"\n", gVolumeName);
-		printf("\tblock-size: %lu\n", defaults->blockSize);
-		printf("\ttotal blocks: %lu\n", totalBlocks);
+		printf("\tblock-size: %u\n", defaults->blockSize);
+		printf("\ttotal blocks: %u\n", totalBlocks);
 		if (gJournaled)
 			printf("\tjournal-size: %dk\n", (int)defaults->journalSize/1024);
-		printf("\tfirst free catalog node id: %lu\n", defaults->nextFreeFileID);
-		printf("\tcatalog b-tree node size: %lu\n", defaults->catalogNodeSize);
-		printf("\tinitial catalog file size: %lu\n", defaults->catalogClumpSize);
-		printf("\textents b-tree node size: %lu\n", defaults->extentsNodeSize);
-		printf("\tinitial extents file size: %lu\n", defaults->extentsClumpSize);
-		printf("\tinitial allocation file size: %lu (%lu blocks)\n",
+		printf("\tfirst free catalog node id: %u\n", defaults->nextFreeFileID);
+		printf("\tcatalog b-tree node size: %u\n", defaults->catalogNodeSize);
+		printf("\tinitial catalog file size: %u\n", defaults->catalogClumpSize);
+		printf("\textents b-tree node size: %u\n", defaults->extentsNodeSize);
+		printf("\tinitial extents file size: %u\n", defaults->extentsClumpSize);
+		printf("\tinitial allocation file size: %u (%u blocks)\n",
 			defaults->allocationClumpSize, defaults->allocationClumpSize / gBlockSize);
-		printf("\tdata fork clump size: %lu\n", defaults->dataClumpSize);
-		printf("\tresource fork clump size: %lu\n", defaults->rsrcClumpSize);
+		printf("\tdata fork clump size: %u\n", defaults->dataClumpSize);
+		printf("\tresource fork clump size: %u\n", defaults->rsrcClumpSize);
 	}
 }
 
@@ -723,19 +764,19 @@ static void hfs_params(UInt32 sectorCoun
 			((freewrapperblks * 512) + defaults->blockSize - 1) / defaults->blockSize;
 	
 	if (gNoCreate) {
-		printf("%ld sectors at %ld bytes per sector\n", sectorCount, sectorSize);
+		printf("%u sectors at %u bytes per sector\n", sectorCount, sectorSize);
 		printf("%s format parameters:\n", gWrapper ? "HFS Wrapper" : "HFS");
 		printf("\tvolume name: \"%s\"\n", gVolumeName);
-		printf("\tblock-size: %ld\n", defaults->blockSize);
-		printf("\ttotal blocks: %ld\n", sectorCount / (alBlkSize / sectorSize) );
-		printf("\tfirst free catalog node id: %ld\n", defaults->nextFreeFileID);
-		printf("\tinitial catalog file size: %ld\n", defaults->catalogClumpSize);
-		printf("\tinitial extents file size: %ld\n", defaults->extentsClumpSize);
-		printf("\tfile clump size: %ld\n", defaults->dataClumpSize);
+		printf("\tblock-size: %u\n", defaults->blockSize);
+		printf("\ttotal blocks: %u\n", sectorCount / (alBlkSize / sectorSize) );
+		printf("\tfirst free catalog node id: %u\n", defaults->nextFreeFileID);
+		printf("\tinitial catalog file size: %u\n", defaults->catalogClumpSize);
+		printf("\tinitial extents file size: %u\n", defaults->extentsClumpSize);
+		printf("\tfile clump size: %u\n", defaults->dataClumpSize);
 		if (defaults->hfsWrapperFreeBlks)
-			printf("\twrapper free space: %ld\n", defaults->hfsWrapperFreeBlks * alBlkSize);
+			printf("\twrapper free space: %u\n", defaults->hfsWrapperFreeBlks * alBlkSize);
 		if (hfsgrowblks)
-			printf("\twrapper growable from %ld to %ld sectors\n", sectorCount, hfsgrowblks);
+			printf("\twrapper growable from %u to %u sectors\n", sectorCount, hfsgrowblks);
 	}
 }
 
@@ -747,7 +788,7 @@ clumpsizecalc(UInt32 clumpblocks)
 
 	clumpsize = (UInt64)clumpblocks * (UInt64)gBlockSize;
 		
-	if (clumpsize & (UInt64)0xFFFFFFFF00000000)
+	if (clumpsize & (UInt64)0xFFFFFFFF00000000ULL)
 		fatal("=%ld: too many blocks for clump size!", clumpblocks);
 
 	return ((UInt32)clumpsize);
diff -Npur diskdev_cmds.org/newfs_hfs.tproj/newfs_hfs.h diskdev_cmds/newfs_hfs.tproj/newfs_hfs.h
--- diskdev_cmds.org/newfs_hfs.tproj/newfs_hfs.h	2003-04-09 23:36:58.000000000 +0200
+++ diskdev_cmds/newfs_hfs.tproj/newfs_hfs.h	2003-04-29 17:30:05.000000000 +0200
@@ -22,7 +22,30 @@
  * @APPLE_LICENSE_HEADER_END@
  */
  
+#if __APPLE__
 #include <CoreFoundation/CFBase.h>
+#else
+#include "hfs_endian.h"
+
+typedef int8_t		SInt8;
+typedef int16_t		SInt16;
+typedef int32_t		SInt32;
+typedef int64_t		SInt64;
+
+typedef u_int8_t	UInt8;
+typedef u_int16_t	UInt16;
+typedef u_int32_t	UInt32;
+typedef u_int64_t	UInt64;
+
+typedef u_big_int16_t	UniChar;
+
+enum {
+	false		= 0,
+	true		= 1
+};
+
+#define UF_NODUMP	0x00000001	/* do not dump file */
+#endif
 
 /*
  * Mac OS Finder flags
@@ -124,33 +147,33 @@ enum {
 #define kDTDF_FileID	16
 #define kDTDF_Name	"Desktop DF"
 #define kDTDF_Chars	10
-#define kDTDF_Type	'DTFL'
-#define kDTDF_Creator	'DMGR'
+#define kDTDF_Type	0x4454464c	/* 'DTFL' */
+#define kDTDF_Creator	0x444d4752	/* 'DMGR' */
 
 #define kDTDB_FileID	17
 #define kDTDB_Name	"Desktop DB"
 #define kDTDB_Chars	10
-#define kDTDB_Type	'BTFL'
-#define kDTDB_Creator	'DMGR'
+#define kDTDB_Type	0x4254464c	/* 'BTFL' */
+#define kDTDB_Creator	0x444d4752	/* 'DMGR' */
 #define kDTDB_Size	1024
 
 #define kReadMe_FileID	18
 #define kReadMe_Name	"ReadMe"
 #define kReadMe_Chars	6
-#define kReadMe_Type	'ttro'
-#define kReadMe_Creator	'ttxt'
+#define kReadMe_Type	0x7474726f	/* 'ttro' */
+#define kReadMe_Creator	0x74747874	/* 'ttxt' */
 
 #define kFinder_FileID	19
 #define kFinder_Name	"Finder"
 #define kFinder_Chars	6
-#define kFinder_Type	'FNDR'
-#define kFinder_Creator	'MACS'
+#define kFinder_Type	0x464e4452	/* 'FNDR' */
+#define kFinder_Creator	0x4d414353	/* 'MACS' */
 
 #define kSystem_FileID	20
 #define kSystem_Name	"System"
 #define kSystem_Chars	6
-#define kSystem_Type	'zsys'
-#define kSystem_Creator	'MACS'
+#define kSystem_Type	0x7a737973	/* 'zsys' */
+#define kSystem_Creator	0x4d414353	/* 'MACS' */
 
 
 /*
